<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    错误消息
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/default.css" type="text/css" />
                <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
        <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="index.html" />
        <link rel="next" title="变更和迁移" href="changelog/index.html" />
        <link rel="prev" title="第三方集成问题" href="faq/thirdparty.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy 2.0 Documentation">SQLAlchemy 2.0 Documentation</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="intro.html">概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="tutorial/index.html">SQLAlchemy统一教程</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm/index.html">SQLAlchemy ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="core/index.html">SQLAlchemy 核心</a></span></li>
<li><span class="link-container"><a class="reference external" href="dialects/index.html">方言</a></span></li>
<li><span class="link-container"><a class="reference external" href="faq/index.html">常见问题解答</a></span></li>
<li class="selected"><span class="link-container"><strong>错误消息</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id2">连接和事务</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#x-y-z">队列池大小限制 &lt;x&gt; 溢出 &lt;y&gt;，连接超时，超时 &lt;z&gt;</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dbapi">DBAPI 错误</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#interfaceerror">InterfaceError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#databaseerror">DatabaseError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#dataerror">DataError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#operationalerror">OperationalError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#integrityerror">IntegrityError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#internalerror">InternalError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#programmingerror">ProgrammingError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#notsupportederror">NotSupportedError</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sql">SQL 表达式语言</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#caching-caveats">对象不会生成缓存键，性能影响</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id4">缓存会在存在任何疑问的情况下禁用</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">用于缓存的断言属性</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#compiler-strsqlcompiler-x">Compiler StrSQLCompiler 无法呈现类型为 &lt;x&gt; 的元素</a></span></li>
<li><span class="link-container"><a class="reference external" href="#typeerror-operator-columnproperty-something">TypeError：“&lt;operator&gt;”不支持实例之间的’ColumnProperty’和 &lt;something&gt;</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-8s2b">无法在撤消无效事务之前重新连接。请在继续之前完全回滚（）</a></span></li>
<li><span class="link-container"><a class="reference external" href="#a-foreignkey-expected-named-arguments-if-name-name-constraint-or-constraintname-in-kwargs-use-the-corresponding-explicit-argument-if-providing-the-constraint-name-inline-use-name-name">A ForeignKey’’’ expected named arguments.  If ‘name’, ‘’’name, ‘constraint’, or ‘’’constraintname’ in kwargs, use the corresponding, explicit argument.  If providing the constraint name inline, use name=&lt;name&gt;</a></span></li>
<li><span class="link-container"><a class="reference external" href="#from-selectfrom-subquery">期望的是FROM子句，实际却是Select。创建FROM子句时，请使用.subquery()方法。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#clauseelement">自动为裸clauseelement生成别名</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-xaj2">由于重叠的表，自动为别名生成别名</a></span></li>
<li><span class="link-container"><a class="reference external" href="#flush">一个事务已经回滚了，原因是在 flush 过程中遇到了上一个异常</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationship-delete-orphan">在关系&lt;relationship&gt;中“delete-orphan”级联通常仅在一对多关系的“一”侧上配置，而不是多对一或多对多关系的“多”侧。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#instance-attribute-instance">实例&lt; instance &gt; 已经通过其&lt;attribute&gt;属性与实例&lt;instance&gt;相关联，只允许一个父项。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#x-q-p-s-y">关系 X 将 Q 列复制到 P 列，这与关系(s)：“Y”冲突。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-session-orm-session-expunge-all-persistent">由于   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  已关闭或以其他方式调用了  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expunge_all()</span></code>  方法，因此无法将对象转换为“persistent”状态，因此该标识映射不再有效。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-zlpr">引用声明性表格表单的类型注释不能解释</a></span></li>
<li><span class="link-container"><a class="reference external" href="#cls-python">将 &lt;cls&gt; 转换为数据类时发生 Python 数据类错误</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm">使用按主键的 ORM 按行批量更新需要记录包含主键值的记录</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#asyncio">AsyncIO 异常</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#awaitrequired">AwaitRequired</a></span></li>
<li><span class="link-container"><a class="reference external" href="#missinggreenlet">MissingGreenlet</a></span></li>
<li><span class="link-container"><a class="reference external" href="#no-inspection-available">No Inspection Available</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id12">核心异常类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id13">ORM 异常类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id14">历史遗留异常</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy-2-0">在 SQLAlchemy 2.0 中，&lt;某些函数&gt; 将不再&lt;某些行为&gt;</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-s9r1">此连接处于非活动事务中。请在继续之前执行回滚（）。</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="changelog/index.html">变更和迁移</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="faq/thirdparty.html" title="previous chapter">第三方集成问题</a></li>
                <li><b>Next:</b>
                <a href="changelog/index.html" title="next chapter">变更和迁移</a></li>

            <li><b>Up:</b> <a href="index.html">Home</a></li>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#errors">错误消息</a><ul>
<li><a class="reference internal" href="#id2">连接和事务</a><ul>
<li><a class="reference internal" href="#x-y-z">队列池大小限制 &lt;x&gt; 溢出 &lt;y&gt;，连接超时，超时 &lt;z&gt;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dbapi">DBAPI 错误</a><ul>
<li><a class="reference internal" href="#interfaceerror">InterfaceError</a></li>
<li><a class="reference internal" href="#databaseerror">DatabaseError</a></li>
<li><a class="reference internal" href="#dataerror">DataError</a></li>
<li><a class="reference internal" href="#operationalerror">OperationalError</a></li>
<li><a class="reference internal" href="#integrityerror">IntegrityError</a></li>
<li><a class="reference internal" href="#internalerror">InternalError</a></li>
<li><a class="reference internal" href="#programmingerror">ProgrammingError</a></li>
<li><a class="reference internal" href="#notsupportederror">NotSupportedError</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sql">SQL 表达式语言</a><ul>
<li><a class="reference internal" href="#caching-caveats">对象不会生成缓存键，性能影响</a><ul>
<li><a class="reference internal" href="#id4">缓存会在存在任何疑问的情况下禁用</a></li>
<li><a class="reference internal" href="#id5">用于缓存的断言属性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compiler-strsqlcompiler-x">Compiler StrSQLCompiler 无法呈现类型为 &lt;x&gt; 的元素</a></li>
<li><a class="reference internal" href="#typeerror-operator-columnproperty-something">TypeError：“&lt;operator&gt;”不支持实例之间的’ColumnProperty’和 &lt;something&gt;</a></li>
<li><a class="reference internal" href="#error-8s2b">无法在撤消无效事务之前重新连接。请在继续之前完全回滚（）</a></li>
<li><a class="reference internal" href="#a-foreignkey-expected-named-arguments-if-name-name-constraint-or-constraintname-in-kwargs-use-the-corresponding-explicit-argument-if-providing-the-constraint-name-inline-use-name-name">A ForeignKey’’’ expected named arguments.  If ‘name’, ‘’’name, ‘constraint’, or ‘’’constraintname’ in kwargs, use the corresponding, explicit argument.  If providing the constraint name inline, use name=&lt;name&gt;</a></li>
<li><a class="reference internal" href="#from-selectfrom-subquery">期望的是FROM子句，实际却是Select。创建FROM子句时，请使用.subquery()方法。</a></li>
<li><a class="reference internal" href="#clauseelement">自动为裸clauseelement生成别名</a></li>
<li><a class="reference internal" href="#error-xaj2">由于重叠的表，自动为别名生成别名</a></li>
<li><a class="reference internal" href="#flush">一个事务已经回滚了，原因是在 flush 过程中遇到了上一个异常</a></li>
<li><a class="reference internal" href="#relationship-delete-orphan">在关系&lt;relationship&gt;中“delete-orphan”级联通常仅在一对多关系的“一”侧上配置，而不是多对一或多对多关系的“多”侧。</a></li>
<li><a class="reference internal" href="#instance-attribute-instance">实例&lt; instance &gt; 已经通过其&lt;attribute&gt;属性与实例&lt;instance&gt;相关联，只允许一个父项。</a></li>
<li><a class="reference internal" href="#x-q-p-s-y">关系 X 将 Q 列复制到 P 列，这与关系(s)：“Y”冲突。</a></li>
<li><a class="reference internal" href="#orm-session-orm-session-expunge-all-persistent">由于   <code class="xref py py-class docutils literal notranslate"><span class="pre">_orm.Session</span></code>  已关闭或以其他方式调用了  <code class="xref py py-meth docutils literal notranslate"><span class="pre">_orm.Session.expunge_all()</span></code>  方法，因此无法将对象转换为“persistent”状态，因此该标识映射不再有效。</a></li>
<li><a class="reference internal" href="#error-zlpr">引用声明性表格表单的类型注释不能解释</a></li>
<li><a class="reference internal" href="#cls-python">将 &lt;cls&gt; 转换为数据类时发生 Python 数据类错误</a></li>
<li><a class="reference internal" href="#orm">使用按主键的 ORM 按行批量更新需要记录包含主键值的记录</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asyncio">AsyncIO 异常</a><ul>
<li><a class="reference internal" href="#awaitrequired">AwaitRequired</a></li>
<li><a class="reference internal" href="#missinggreenlet">MissingGreenlet</a></li>
<li><a class="reference internal" href="#no-inspection-available">No Inspection Available</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">核心异常类</a></li>
<li><a class="reference internal" href="#id13">ORM 异常类</a></li>
<li><a class="reference internal" href="#id14">历史遗留异常</a><ul>
<li><a class="reference internal" href="#sqlalchemy-2-0">在 SQLAlchemy 2.0 中，&lt;某些函数&gt; 将不再&lt;某些行为&gt;</a></li>
<li><a class="reference internal" href="#error-s9r1">此连接处于非活动事务中。请在继续之前执行回滚（）。</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar errors" >
        
<section id="errors">
<span id="id1"></span><h1>错误消息<a class="headerlink" href="#errors" title="Permalink to this heading">¶</a></h1>
<p>本节列出 SQLAlchemy 引发的常见错误消息和警告的描述和背景。</p>
<p>SQLAlchemy 通常在 SQLAlchemy 特定的异常中引发错误。
有关这些类的详细信息，请参见   <a class="reference internal" href="core/exceptions.html"><span class="std std-ref">核心异常</span></a>  和   <span class="xref std std-ref">orm_exceptions_toplevel</span> 。</p>
<p>SQLAlchemy 错误大致可分为两类：<strong>编程时错误**和**运行时错误</strong>。
编程时错误是由于使用不正确的参数调用函数或方法或来自无法解决的其他配置导向的方法而引发的。
编程时错误通常是即时的和确定性的。相反，运行时错误表示程序在相应地以任意方式运行时发生的错误，
例如数据库连接被耗尽或发生某些数据相关问题。运行时错误更可能在运行应用程序时的日志中看到，
因为程序在遇到这些状态时，会响应加载和遇到的数据。</p>
<p>由于运行时错误不容易重现，并且通常是作为响应某些任意条件发生的，因此对于调试来说比较困难，
并且也会影响已经投入生产的程序。</p>
<p>在本节中，目标是尝试提供有关一些常见的运行时错误及编程时错误的背景信息。</p>
<section id="id2">
<h2>连接和事务<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<section id="x-y-z">
<span id="error-3o7r"></span><h3>队列池大小限制 &lt;x&gt; 溢出 &lt;y&gt;，连接超时，超时 &lt;z&gt;<a class="headerlink" href="#x-y-z" title="Permalink to this heading">¶</a></h3>
<p>这可能是最常见的运行时错误，
因为它直接涉及应用程序的工作负荷超过了配置的限制，这通常适用于几乎所有 SQLAlchemy 应用程序。</p>
<p>以下是总结此错误的要点，从大多数 SQLAlchemy 用户应该已经熟悉的最基本的要点开始。</p>
<ul>
<li><p><strong>SQLAlchemy 引擎对象默认使用连接池</strong> - 这意味着当使用   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  对象的 SQL 数据库连接资源时，
然后  <span class="xref std std-term">releases</span>  该资源，该数据库连接本身仍连接到数据库，并返回到内部队列，可以再次使用。尽管代码似乎正在
结束与数据库的对话，在许多情况下，应用程序将仍保留一定数量的数据库连接，这些连接在应用程序结束或池显式释放之前一直存在。</p></li>
<li><p>由于池，当应用程序使用 SQL 数据库连接时，通常最常使用的是  <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Engine.connect" title="sqlalchemy.engine.Engine.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.connect()</span></code></a>
或使用 ORM 的查询   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，此操作未必在获取连接对象时立即与数据库建立新连接;
它将查询连接池以获取一个连接，该池通常从中检索要重新使用的现有连接。如果没有可用的连接，池将创建一个
新的数据库连接，但仅在池未超过配置的容量时。</p></li>
<li><p>在大多数情况下使用的默认池名为   <a class="reference internal" href="core/pooling.html#sqlalchemy.pool.QueuePool" title="sqlalchemy.pool.QueuePool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueuePool</span></code></a> 。当您要求此池提供连接而没有可用连接时，
它将创建一个新的连接，<strong>如果播放的总连接数少于配置的值</strong>，这个值等于**池大小加上最大溢出**。这意味着，
如果您已将引擎配置为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql+mysqldb://u:p@host/db&quot;</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_overflow</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span></pre></div>
</div>
<p>上面，   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  将允许任意时间内最多有 <strong>30 个连接</strong>，这不包括已从引擎中分离或失效的连接。如果到达新连接的请求，
并且已有 30 个连接正在应用程序的其他部分中使用，则连接池将在固定的时间内阻塞，然后超时并引发此错误消息。</p>
<p>为了允许同时使用更多的连接，池可以使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.pool_size</span></code>
和  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.max_overflow</span></code>  参数调整，作为   <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code>
函数传递。等待连接可用的超时是通过配置  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.pool_timeout</span></code>  参数来配置的。</p>
</li>
<li><p>通过将  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.max_overflow</span></code>  设置为-1，可以配置池具有无限溢出。在此设置下，
池仍会维护一组固定的连接池，但如果没有可用连接，则不会阻塞对新连接的请求。但是，在此方式下运行时，
如果应用程序存在耗尽所有可用连通性资源的问题，则最终会在数据库本身的可用连接数限制下出现错误。
更严重的是，当应用程序耗尽数据库的连接时，它通常会导致使用了大量资源失败，并且可能会干扰其它应用程序和依赖于连接到数据库的数据库状态机制。</p>
<p>考虑到以上情况，连接池可以被看作是连接使用的**安全阀门**，提供了对流氓应用程序防止整个数据库
变为对所有其他应用程序不可用的重要保护层。在收到此错误消息时，最好修复使用太多连接和/或适当配置限制，
而不是允许无限溢出，这实际上并没有解决根本问题。</p>
</li>
</ul>
<p>是什么导致应用程序使用完所有可用的连接？</p>
<ul>
<li><p><strong>应用程序面临的并发请求数过多</strong> - 这是最直接的原因。如果您有一个运行在允许 30
个并发线程的线程池中的应用程序，并且每个线程使用一个连接，如果您的池未配置为允许同时
有至少30个连接签出，则在您的应用程序接收足够的并发请求后，您将获得此错误。
解决方法是提高池的限制或降低并行线程的数量。</p></li>
<li><dl class="simple">
<dt><strong>应用程序未将连接还回池</strong> - 这是第二个最常见的原因，即应用程序使用连接池，</dt><dd><p>但程序未终止使用此连接资源，而是将其保持打开状态。连接池以及 ORM 的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  均具有逻辑，</p>
</dd>
</dl>
<p>当回收 session 和/或 connection 对象时，会释放底层连接资源，但不能依赖此行为及时释放资源。</p>
<p>发生这种情况的常见原因是应用程序使用 ORM 会话并且在完成涉及该会话的工作后未调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code> 。
解决方法是，确保使用 ORM 会话（如果使用 ORM）或使用 Core 接口绑定的   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  对象在完成工作后被显式关闭，
即通过适当的 <code class="docutils literal notranslate"><span class="pre">.close()</span></code> 方法或使用其中一个可用的上下文管理器（例如 “with:” 语句）正确释放资源。</p>
</li>
<li><p><strong>应用程序尝试运行长时间的事务</strong> - 数据库事务是一种非常昂贵的资源，
不应该**保持空闲等待某个事件发生**。如果应用程序正在等待用户按按钮，或来自长时间运行的作业队列中传递
的结果，或保持打开的持久连接到浏览器，则不要为整个时间**都保持数据库事务打开**。当应用程序需要使用数据库并与事件交互时，
在此时开启一个短寿命的事务，然后关闭它。</p></li>
<li><p><strong>应用程序死锁</strong> - 这也是此错误的常见原因，更难以理解，如果应用程序不能完成其对连接的使用，
无论是由于应用程序侧还是由于数据库侧死锁，应用程序可能会使用完所有可用连接，从而导致其他请求接收此错误。
死锁原因包括：</p>
<ul class="simple">
<li><p>使用诸如 gevent 或 eventlet 等隐式异步系统而未正确 monkeypatch 所有套接字库和驱动程序，</p></li>
</ul>
<p>或者隐式异步系统在未在全面覆盖所有 monkeypatched 驱动程序方法方面存在 bug，
或者非常不常见的情况是，如果异步系统用于 CPU 绑定工作负载，那么使用数据库资源的 greenlets 只需等太长时间才能对其进行处理。
对于绝大多数关系型数据库操作，隐式和显式异步编程框架通常不是必要或适当的；如果应用程序必须在某些功能区域使用异步系统，
最好是让面向数据库业务方法在传递消息到应用程序的异步部分中运行传统线程。</p>
<ul class="simple">
<li><p>数据库侧死锁，例如相互死锁的行</p></li>
<li><p>线程错误，例如互锁的互斥锁，或在同一线程中调用已被锁定的互斥锁</p></li>
</ul>
</li>
</ul>
<p>请记住，除了使用池之外还有一种替代方法，即完全关闭池。
请参见   <a class="reference internal" href="core/pooling.html#pool-switching"><span class="std std-ref">切换连接池实现</span></a>  部分，了解有关此背景信息。但是，请注意，当出现此错误消息时，
它始终由应用程序本身中更大的问题引起；池只有帮助更早地暴露了该问题。</p>
</section>
</section>
<section id="dbapi">
<h2>DBAPI 错误<a class="headerlink" href="#dbapi" title="Permalink to this heading">¶</a></h2>
<p>Python 数据库 API（DBAPI）是定位于数据库驱动程序
的规范，它位于 <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">Pep-249</a> 中。
该 API 指定了适应数据库的完整故障模式所需要的一组异常类。</p>
<p>SQLAlchemy 并不直接生成这些异常。相反，它们被从数据库驱动程序中拦截并由由 SQLAlchemy 提供的异常   <a class="reference internal" href="core/exceptions.html#sqlalchemy.exc.DBAPIError" title="sqlalchemy.exc.DBAPIError"><code class="xref py py-class docutils literal notranslate"><span class="pre">DBAPIError</span></code></a> 包装，
但是该异常中的消息是**由驱动程序生成，而不是 SQLAlchemy 生成的**。</p>
<section id="interfaceerror">
<span id="error-rvf5"></span><h3>InterfaceError<a class="headerlink" href="#interfaceerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库本身而不是与数据库接口相关的错误引发的异常。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
<p>“InterfaceError”有时由驱动程序在上下文中引发，
因为检测到了数据库连接是否断开，或者无法连接到数据库。有关如何处理此问题的提示，请参见   <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>  部分。</p>
</section>
<section id="databaseerror">
<span id="error-4xp6"></span><h3>DatabaseError<a class="headerlink" href="#databaseerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库本身而不是与所传输数据或接口相关的错误引发的异常。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
</section>
<section id="dataerror">
<span id="error-9h9h"></span><h3>DataError<a class="headerlink" href="#dataerror" title="Permalink to this heading">¶</a></h3>
<p>由于处理数据时出现问题（例如被零整除、数字值超出范围等）而引发的异常。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
</section>
<section id="operationalerror">
<span id="error-e3q8"></span><h3>OperationalError<a class="headerlink" href="#operationalerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库的操作而不是程序员控制下的错误相关引发的异常，例如，出现意外断开连接，
数据源名称未找到，无法处理事务，执行期间发生内存分配错误等。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
<p>“OperationalError”是驱动程序在上下文中使用的最常见（但并非唯一）错误类，
因为数据库连接被丢弃，或无法连接到数据库。有关如何处理此问题的提示，请参见   <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>  部分。</p>
</section>
<section id="integrityerror">
<span id="error-gkpj"></span><h3>IntegrityError<a class="headerlink" href="#integrityerror" title="Permalink to this heading">¶</a></h3>
<p>在影响数据库的关系完整性时引发的异常，例如，外键检查失败。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
</section>
<section id="internalerror">
<span id="error-2j85"></span><h3>InternalError<a class="headerlink" href="#internalerror" title="Permalink to this heading">¶</a></h3>
<p>在数据库遇到内部错误时引发的异常，例如，光标不再有效，事务不同步等。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
<p>“InternalError”有时由驱动程序在上下文中引发，
因为检测到了数据库连接是否断开，或者无法连接到数据库。有关如何处理此问题的提示，请参见   <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>  部分。</p>
</section>
<section id="programmingerror">
<span id="error-f405"></span><h3>ProgrammingError<a class="headerlink" href="#programmingerror" title="Permalink to this heading">¶</a></h3>
<p>与编程错误相关的异常，例如，找不到或已存在表，SQL 语句中的语法错误，指定了错误数量的参数等。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
<p>“ProgrammingError”有时由驱动程序在上下文中引发，
因为检测到了数据库连接是否断开，或者无法连接到数据库。有关如何处理此问题的提示，请参见   <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>  部分。</p>
</section>
<section id="notsupportederror">
<span id="error-tw8g"></span><h3>NotSupportedError<a class="headerlink" href="#notsupportederror" title="Permalink to this heading">¶</a></h3>
<p>在使用不支持的方法或数据库 API 的情况下引发的异常，例如，在不支持事务的连接上请求 .rollback()。</p>
<p>这是个   <span class="xref std std-ref">DBAPI 错误</span>  ，并起源于
数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。</p>
</section>
</section>
<section id="sql">
<h2>SQL 表达式语言<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h2>
<section id="caching-caveats">
<span id="error-cprf"></span><span id="id3"></span><h3>对象不会生成缓存键，性能影响<a class="headerlink" href="#caching-caveats" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 版本 1.4 包括一个   <a class="reference internal" href="core/connections.html#sql-caching"><span class="std std-ref">SQL 编译缓存设施</span></a> ，其会使 Core 和 ORM SQL 构造缓存其字符串形式，
以及用于从语句获取结果的其他结构信息，允许相对昂贵的字符串编译过程在下次使用另一构造时跳过。该系统依赖于所有 SQL 构造
（例如   <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> ，  <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  和   <a class="reference internal" href="core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>  对象）实现用于生成完全表示它们的状态的**缓存键**，
到了这个程度影响 SQL 编译过程。</p>
<p>如果警告涉及广泛使用的对象，例如   <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象，并且显示它们影响了大多数 SQL 构造（使用   <a class="reference internal" href="core/connections.html#sql-caching-logging"><span class="std std-ref">使用日志记录估计缓存性能</span></a>
中描述的估计技术），以便缓存通常对于应用程序是未启用的，这将对性能产生负面影响，并且在某些情况下，甚至可能有效地产生了**性能下降**，
与之前的 SQLAlchemy 版本相比。   <a class="reference internal" href="faq/performance.html#faq-new-caching"><span class="std std-ref">为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？</span></a>  在   <a class="reference internal" href="faq/index.html"><span class="std std-ref">常见问题解答</span></a>  部分中介绍了此问题的详细信息。</p>
<p>如果对于某个特殊的后端，具体作用域的建议，例如在 PostgreSQL 中的 <a class="reference external" href="postgresql_insert_on_conflict">“insert on conflict”</a> 构造。
建议使用合理的方法生成缓存键，因此针对特定后端的构造可以缓存它们的 SQL 表示形式。</p>
<section id="id4">
<h4>缓存会在存在任何疑问的情况下禁用<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<p>缓存依赖于能够生成完整表示语句中 <strong>完整的结构</strong> 以使其安全，但保持 <strong>一致</strong> 的“缓存键”。如果某个特定的 SQL 构造（
或类型）没有适当的指令，该构造将无法生成正确的缓存键，因此不能安全地启用缓存：</p>
<ul class="simple">
<li><p>缓存键必须表示 <strong>完整的结构</strong> ：如果使用两个单独的实例的使用可能会导致字符串不同的两个实例，
则使用第一个元素将字符串化时缓存该 SQL 时将使用与第二元素的区别捕获的不同的参数，并且在“第二场”使用该元素时，
会产生错误的 SQL。</p></li>
<li><p>缓存键必须是 <strong>一致的</strong> ：如果构造表示每次都会发生更改的状态，例如文字值，则无法安全地启用缓存，
因为重复使用该构造将会快速填满独特的 SQL 字符串缓存，而这些 SQL 字符串通常不会再次使用，无用地消耗缓存区，从而破坏缓存的目的。</p></li>
</ul>
<p>基于这两个原因，SQLAlchemy 的缓存系统对于决定将 SQL 缓存到对象中变得**极度保守**。</p>
</section>
<section id="id5">
<h4>用于缓存的断言属性<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<p>警告基于以下标准发出。有关更多详细信息，请参见   <a class="reference internal" href="faq/performance.html#faq-new-caching"><span class="std std-ref">为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？</span></a> 。</p>
<ul>
<li><p><a class="reference internal" href="core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> （即我们传递给   <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code>  的 URL 的第一部分指定的模块，例如 <cite>postgresql+psycopg2://</cite>）必须表明它已经得到验证并测试，以支持安全缓存。这由  <a class="reference internal" href="core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache" title="sqlalchemy.engine.Dialect.supports_statement_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Dialect.supports_statement_cache</span></code></a>  属性设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时指示。当使用第三方方言时，请与方言的维护人员咨询，以便他们可以遵循   <a class="reference internal" href="core/connections.html#engine-thirdparty-caching"><span class="std std-ref">步骤，确保可以启用缓存</span></a>  在其方言中，并发布新版本。</p></li>
<li><p>这些类型是从   <a class="reference internal" href="core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>  或   <a class="reference internal" href="core/custom_types.html#sqlalchemy.types.UserDefinedType" title="sqlalchemy.types.UserDefinedType"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedType</span></code></a>  继承的第三方或用户定义类型必须在其定义中包括  <a class="reference internal" href="core/type_api.html#sqlalchemy.types.ExternalType.cache_ok" title="sqlalchemy.types.ExternalType.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ExternalType.cache_ok</span></code></a>
属性，其中包括对所有派生子类都简要描述的该属性定义。如前所述，如果这些数据类型从第三方库导入，则请与该库的维护者商议，以便他们可以提供所需更改以及
发布新版本。</p></li>
<li><p>第三方或用户定义的 SQL 构造，这些构造为某个特定的后端构造专用，例如   <span class="xref std std-ref">pragma_foreign_keys</span> ，均需要使用某些 SQL 编译器类。
不适用于默认的   <code class="xref py py-class docutils literal notranslate"><span class="pre">StrSQLCompiler</span></code> ，也包括复杂的子类，以及为   <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span>  进行设计的对象，应按照需要包括</p>
<blockquote>
<div><p><a class="reference internal" href="core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache" title="sqlalchemy.sql.traversals.HasCacheKey.inherit_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HasCacheKey.inherit_cache</span></code></a>  属性，并根据构造设计将其设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>，按照   <a class="reference internal" href="core/compiler.html#compilerext-caching"><span class="std std-ref">Enabling Caching Support for Custom Constructs</span></a>  中的指南描述。</p>
</div></blockquote>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/connections.html#sql-caching-logging"><span class="std std-ref">使用日志记录估计缓存性能</span></a>  - 可观察缓存行为和效率的背景</p>
<p><a class="reference internal" href="faq/performance.html#faq-new-caching"><span class="std std-ref">为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？</span></a>  - 在   <a class="reference internal" href="faq/index.html"><span class="std std-ref">常见问题解答</span></a>  部分中</p>
</div>
</section>
</section>
<section id="compiler-strsqlcompiler-x">
<span id="error-cd3x"></span><h3>Compiler StrSQLCompiler 无法呈现类型为 &lt;x&gt; 的元素<a class="headerlink" href="#compiler-strsqlcompiler-x" title="Permalink to this heading">¶</a></h3>
<p>通常在尝试对包含非默认编译的元素的 SQL 表达式构造进行字符串转换时发生此错误；
在这种情况下，将命名   <a class="reference internal" href="core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler" title="sqlalchemy.sql.compiler.StrSQLCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrSQLCompiler</span></code></a>  类。
在较少见的情况下，它也可能会发生在某个特定类型的数据库后端上使用错误类型的 SQL 表达式时；在这些情况下，将命名其他类型的 SQL 编译器类，
例如``SQLCompiler`` 或 <code class="docutils literal notranslate"><span class="pre">sqlalchemy.dialects.postgresql.PGCompiler</span></code>。以下是针对字符串化用例更具体的指导方针，但也描述了一般背景。</p>
<p>通常，可以直接对 Core SQL 构造或 ORM   <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  对象进行字符串化，例如使用 <code class="docutils literal notranslate"><span class="pre">print（）</span></code>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<div class='show_sql_print'><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">x_1</span>
</div></pre></div>
</div>
<p>在上面的 SQL 表达式被字符串化时，将使用   <a class="reference internal" href="core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler" title="sqlalchemy.sql.compiler.StrSQLCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrSQLCompiler</span></code></a>  编译器类，这是一个特殊的语句
编译器，当在没有任何特定于方言的信息的情况下对构造进行字符串化时，将使用该编译器类。</p>
<p>然而，有许多构造是特定于某个特定种类的数据库方言的，而   <a class="reference internal" href="core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler" title="sqlalchemy.sql.compiler.StrSQLCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrSQLCompiler</span></code></a>  并不知道如何将它们转换成字符串，
例如 PostgreSQL 中的 “insert on conflict” 构造：</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="kn">import</span> <span class="n">insert</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_table</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insert_stmt</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">my_table</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insert_stmt</span> <span class="o">=</span> <span class="n">insert_stmt</span><span class="o">.</span><span class="n">on_conflict_do_nothing</span><span class="p">(</span><span class="n">index_elements</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">insert_stmt</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span></pre></div>
</div>
<p>…</p>
<p>sqlalchemy.exc.UnsupportedCompilationError:
Compiler &lt;sqlalchemy.sql.compiler.StrSQLCompiler object at 0x7f04fc17e320&gt;
can’t render element of type
&lt;class ‘sqlalchemy.dialects.postgresql.dml.OnConflictDoNothing’&gt;</p>
</div></blockquote>
<p>为了字符串化特定于特定后端的构造，必须使用  <a class="reference internal" href="core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile" title="sqlalchemy.sql.expression.ClauseElement.compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.compile()</span></code></a>  方法，传递   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  或   <a class="reference internal" href="core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a>  对象，
这将调用正确的编译器。 下面我们使用一个 PostgreSQL 方言：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">insert_stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">CONFLICT</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">DO</span><span class="w"> </span><span class="k">NOTHING</span>
</div></pre></div>
</div>
<p>对于 ORM   <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  对象，可以使用  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Query.statement</span></code>  访问语句:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">statement</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">statement</span>
<span class="n">print</span><span class="p">(</span><span class="n">statement</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span></pre></div>
</div>
<p>有关 SQL 元素直接字符串化/编译的额外详细信息，请参见其 FAQ 链接。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="faq/sqlexpressions.html#faq-sql-expression-string"><span class="std std-ref">如何将SQL表达式呈现为字符串，可能带有内联的绑定参数？</span></a></p>
</div>
</section>
<section id="typeerror-operator-columnproperty-something">
<h3>TypeError：“&lt;operator&gt;”不支持实例之间的’ColumnProperty’和 &lt;something&gt;<a class="headerlink" href="#typeerror-operator-columnproperty-something" title="Permalink to this heading">¶</a></h3>
<p>在上下文中使用一个   <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code>  或   <a class="reference internal" href="orm/queryguide/columns.html#sqlalchemy.orm.deferred" title="sqlalchemy.orm.deferred"><code class="xref py py-func docutils literal notranslate"><span class="pre">deferred()</span></code></a>  对象尝试使用 SQL 表达式时，
通常在声明中发生，如下所示：</p>
<blockquote>
<div><dl>
<dt>class Bar(Base):</dt><dd><p>__tablename__ = “bar”</p>
<p>id = Column(Integer, primary_key=True)
cprop = deferred(Column(Integer))</p>
<p>__table_args__ = (CheckConstraint(cprop &gt; 5),)</p>
</dd>
</dl>
</div></blockquote>
<p>上面的“ cprop”属性用于未映射之前，但该“ cprop”属性不是   <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> ,
它是   <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.ColumnProperty" title="sqlalchemy.orm.ColumnProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnProperty</span></code></a> ，这是一个中间对象，因此不具有</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">class<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>_schema.Column</cite> 对象或   <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a>  对象的全部功能，一旦完成声明过程，后者将映射到“ Bar”类。</p>
</dd>
</dl>
</div></blockquote>
<p>虽然   <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.ColumnProperty" title="sqlalchemy.orm.ColumnProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnProperty</span></code></a>  有一个 <code class="docutils literal notranslate"><span class="pre">__clause_element__()</span></code> 方法，它允许它在某些面向列的上下文中工作，
但在上面的示例中，它不能在开放式比较上下文中工作，例如将比较与数字“ 5”作为 SQL 表达式而不是常规 Python 比较。</p>
<p>解决方案是直接访问   <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> ，使用  <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.ColumnProperty.expression" title="sqlalchemy.orm.ColumnProperty.expression"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ColumnProperty.expression</span></code></a> ：</p>
<blockquote>
<div><dl>
<dt>class Bar(Base):</dt><dd><p>__tablename__ = “bar”</p>
<p>id = Column(Integer, primary_key=True)
cprop = deferred(Column(Integer))</p>
<p>__table_args__ = (CheckConstraint(cprop.expression &gt; 5),)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="error-8s2b">
<span id="id6"></span><span id="id7"></span><h3>无法在撤消无效事务之前重新连接。请在继续之前完全回滚（）<a class="headerlink" href="#error-8s2b" title="Permalink to this heading">¶</a></h3>
<p>此错误条件是指   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  被撤销的情况，
无论是因为检测到数据库断开连接，还是因为调用  <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection.invalidate" title="sqlalchemy.engine.Connection.invalidate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.invalidate()</span></code></a> ，但仍存在一个事务，
该事务由  <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection.begin" title="sqlalchemy.engine.Connection.begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.begin()</span></code></a>  方法显式发起，或由连接自动开始在 2.x 系列中发生，当发出任何 SQL 语句时自动开始
到不合法的状态。当连接无效时，任何   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transaction</span></code></a>  正在进行的状态现在都是无效的，
必须显式回滚才能从   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  中删除它。</p>
</section>
<section id="a-foreignkey-expected-named-arguments-if-name-name-constraint-or-constraintname-in-kwargs-use-the-corresponding-explicit-argument-if-providing-the-constraint-name-inline-use-name-name">
<span id="error-9mi2"></span><h3>A ForeignKey’’’ expected named arguments.  If ‘name’, ‘’’name, ‘constraint’, or ‘’’constraintname’ in kwargs, use the corresponding, explicit argument.  If providing the constraint name inline, use name=&lt;name&gt;<a class="headerlink" href="#a-foreignkey-expected-named-arguments-if-name-name-constraint-or-constraintname-in-kwargs-use-the-corresponding-explicit-argument-if-providing-the-constraint-name-inline-use-name-name" title="Permalink to this heading">¶</a></h3>
<p>在创建外键约束时，发生此错误，这是因为 SQLAlchemy 中的关键字参数更改了。
以如下这种格式传递外键约束：</p>
<blockquote>
<div><p>column = Column(Integer, ForeignKey(OtherTable.id))</p>
</div></blockquote>
<p>你需要以以下 format 传外键约束：</p>
<blockquote>
<div><p>column = Column(Integer, ForeignKey(column=OtherTable.id))、</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">StatementError</span><span class="p">:</span> <span class="p">(</span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">)</span>
<span class="n">绑定参数组</span> <span class="mi">1</span> <span class="n">中需要值</span> <span class="s1">&#39;b&#39;</span><span class="err">。</span>
<span class="p">[</span><span class="n">SQL</span><span class="p">:</span> <span class="sa">u</span><span class="s1">&#39;INSERT INTO t (a, b, c) VALUES (?, ?, ?)&#39;</span><span class="p">]</span>
<span class="p">[</span><span class="n">parameters</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}]]</span></pre></div>
</div>
<p>由于“b”是必需的，因此将其传递为“None”，以使INSERT可以继续：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span>
    <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="p">],</span>
<span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="tutorial/dbapi_transactions.html#tutorial-sending-parameters"><span class="std std-ref">发送参数</span></a></p>
</div>
</section>
<section id="from-selectfrom-subquery">
<span id="error-89ve"></span><h3>期望的是FROM子句，实际却是Select。创建FROM子句时，请使用.subquery()方法。<a class="headerlink" href="#from-selectfrom-subquery" title="Permalink to this heading">¶</a></h3>
<p>这涉及到SQLAlchemy 1.4新增的一个更改，其中由函数生成的SELECT语句（例如：func:_expression.select）以及包括联合和文本SELECT表达式等内容在内的SELECT语句不再被视为 _expression.FromClause 对象，并且不能直接放置在另一个SELECT语句的FROM子句中，除非它们首先被包装在一个.Subquery对象中。 这是核心中的一个重要概念变化，完整的理由在：ref:<a href="#id8"><span class="problematic" id="id9">`</span></a>change_4617`中进行了讨论。</p>
<p>示例如下：</p>
<blockquote>
<div><p>m = MetaData()
t = Table(“t”, m, Column(“a”, Integer), Column(“b”, Integer), Column(“c”, Integer))
stmt = select(t)</p>
</div></blockquote>
<p>在以上代码中，stmt 代表一个 SELECT 语句。当我们想要将 stmt 直接用作另一个 SELECT 语句中的FROM子句时，例如我们试图从中查询时，就会出现该错误：</p>
<blockquote>
<div><p>new_stmt_1 = select(stmt)</p>
</div></blockquote>
<p>或者如果我们想将其用于 FROM 子句中，例如在 JOIN 中：</p>
<blockquote>
<div><p>new_stmt_2 = select(some_table).select_from(some_table.join(stmt))</p>
</div></blockquote>
<p>在SQLAlchemy的早期版本中，使用SELECT语句嵌套另一个SELECT语句将会产生一个带有括号的未命名子查询。在许多情况下，MySQL 和 PostgreSQL 等数据库要求 FROM 子句中的子查询具有命名别名，这意味着需要使用 _expression.SelectBase.alias 方法或对于 1.4 版本以降使用 _expression.SelectBase.subquery 方法来进行。在其他数据库中，仍然更清楚地使用别名来解决子查询内列名称的所有歧义。</p>
<p>在实践中，此更改受到多个内部因素的启示，因此正确编写下述两条语句需要使用  <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a>  ：</p>
<blockquote>
<div><p>subq = stmt.subquery()</p>
<p>new_stmt_1 = select(subq)</p>
<p>new_stmt_2 = select(some_table).select_from(some_table.join(subq))</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="changelog/migration_14.html#change-4617"><span class="std std-ref">不再将 SELECT 语句隐式视为 FROM 子句</span></a></p>
</div>
</section>
<section id="clauseelement">
<span id="error-xaj1"></span><h3>自动为裸clauseelement生成别名<a class="headerlink" href="#clauseelement" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>此警告是针对  <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>  方法的常见原因，也适用于</dt><dd><p><a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>   这种”2.0形式”的方法，其中加入可以是</p>
</dd>
</dl>
<p>基于   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  创建的，但目标是映射
到该类或   <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a>  构造的   <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 或其他
核心选择。</p>
<p>例如：</p>
<blockquote>
<div><p>a1 = Address.__table__</p>
<dl class="simple">
<dt>q = (</dt><dd><p>s.query(User)
.join(a1, User.addresses)
.filter(Address.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)
.all()</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>上面的模式还允许选择可选的可选项，例如核心   <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Join" title="sqlalchemy.sql.expression.Join"><code class="xref py py-class docutils literal notranslate"><span class="pre">Join</span></code></a>  或   <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>  对象，
但在这种情况下没有自动适应此元素的适配器，这意味着访问核心元素时需要直接引用。</p>
<blockquote>
<div><p>a1 = Address.__table__.alias()</p>
<dl class="simple">
<dt>q = (</dt><dd><p>s.query(User)
.join(a1, User.addresses)
.filter(a1.c.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)
.all()</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>规定一个链接目标的正确方法是使用映射类本身或   <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-class docutils literal notranslate"><span class="pre">aliased</span></code></a>  对象，对于后一种情况，则使用  <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.PropComparator.of_type" title="sqlalchemy.orm.PropComparator.of_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PropComparator.of_type()</span></code></a>  修改器设置一个别名：</p>
<blockquote>
<div><p># normal join to relationship entity
q = s.query(User).join(User.addresses).filter(Address.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)</p>
<p># name Address target explicitly, not necessary but legal
q = (</p>
<blockquote>
<div><p>s.query(User)
.join(Address, User.addresses)
.filter(Address.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>Join to an alias:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">aliased</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>

<span class="c1"># of_type() form; recommended</span>
<span class="n">q</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">a1</span><span class="p">))</span>
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s2">&quot;ed@foo.com&quot;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># target, onclause form</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s2">&quot;ed@foo.com&quot;</span><span class="p">)</span></pre></div>
</div>
</section>
<section id="error-xaj2">
<span id="id10"></span><h3>由于重叠的表，自动为别名生成别名<a class="headerlink" href="#error-xaj2" title="Permalink to this heading">¶</a></h3>
<p>使用  <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>  方法或遗留的  <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a>  方法进行查询时，
生成此警告通常是关于使用多态继承的表，导致。问题在于，当两个继承模型中的其中之一更改时，两个表的修改可能同时发生。</p>
<p>例如，考虑下面的多态继承映射：</p>
<blockquote>
<div><dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id = Column(Integer, primary_key=True)
manager_id = Column(ForeignKey(“manager.id”))
name = Column(String(50))
type = Column(String(50))</p>
<p>reports_to = relationship(“Manager”, foreign_keys=manager_id)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: type,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id = Column(Integer, ForeignKey(“employee.id”), primary_key=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,
“inherit_condition”: id == Employee.id,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>上述映射包括 Employee 和 Manager 类之间的关系。由于这两个类都使用 “employee” 数据库表，从 SQL 的角度来看，这是一个自联关系。如果我们想要使用 JOIN 从 Employee 和 Manager 模型查询数据，那么在 SQL 层面上，“employee”表需要两次出现在查询中，这意味着它必须被赋予别名。当我们使用 SQLAlchemy ORM 创建这样的 join 时，我们得到的 SQL 如下：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Manager</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Employee</span><span class="o">.</span><span class="n">reports_to</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">SELECT employee.id, employee.manager_id, employee.name,</span>
<span class="go">employee.type, manager_1.id AS id_1, employee_1.id AS id_2,</span>
<span class="go">employee_1.manager_id AS manager_id_1, employee_1.name AS name_1,</span>
<span class="go">employee_1.type AS type_1</span>
<span class="go">FROM employee JOIN</span>
<span class="go">(employee AS employee_1 JOIN manager AS manager_1 ON manager_1.id = employee_1.id)</span>
<span class="go">ON manager_1.id = employee.manager_id</span></pre></div>
</div>
<p>上面的 SQL 使用”employee”表作为“Employee”实体中查询的 FROM，然后连接到右嵌套 JOIN“employee AS employee_1 JOIN manager AS manager_1”，其中“employee”表再次被声明，但作为匿名别名“employee_1”。这是警告信息所指的“自动生成别名”。</p>
<p>当SQLAlchemy从每个ORM行中适配一个Employee和Manager对象时，ORM必须将基于employee_1和manager_1的行调整为未别名的Manager类的行。此处理在内部较为复杂，不符合所有API功能，特别是尝试使用包含_eager等负载时，这些API功能在比这里更深层次的查询中。由于此模式不可靠且涉及难以预见和遵循的隐式决策制定，因此会发出警告，该模式可被视为遗留功能。因此，应显式使用   <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a>  构造。在继承并使用其他基于 join 的映射的情况下，通常最好增加使用  <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat" title="sqlalchemy.orm.aliased"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">aliased.flat</span></code></a>  参数的设置，该参数允许将两个或更多表的 JOIN 通过将表单独用作别名而而不是内嵌 JOIN 来进行别名：</p>
<blockquote>
<div><p>from sqlalchemy.orm import aliased
manager_alias = aliased(Manager, flat=True)
stmt = select(Employee, manager_alias).join(Employee.reports_to.of_type(manager_alias))
print(stmt)</p>
</div></blockquote>
<p>要使用 EAGER LOAD 填充“reports_to”属性，必须引用别名：</p>
<blockquote>
<div><dl class="simple">
<dt>stmt = (</dt><dd><p>select(Employee)
.join(Employee.reports_to.of_type(manager_alias))
.options(contains_eager(Employee.reports_to.of_type(manager_alias)))</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>在非错误场景中，Session.rollback方法无条件到期会话中的所有内容，并且也应避免在没有错误的情况下进行使用。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/cascades.html#unitofwork-cascades"><span class="std std-ref">级联操作</span></a></p>
<p><a class="reference internal" href="orm/cascades.html#cascade-delete-orphan"><span class="std std-ref">delete-orphan</span></a></p>
<p><a class="reference internal" href="#error-bbf1"><span class="std std-ref">实例&lt; instance &gt; 已经通过其&lt;attribute&gt;属性与实例&lt;instance&gt;相关联，只允许一个父项。</span></a></p>
</div>
</section>
<section id="flush">
<span id="error-bhk3"></span><h3>一个事务已经回滚了，原因是在 flush 过程中遇到了上一个异常<a class="headerlink" href="#flush" title="Permalink to this heading">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">类<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Session</cite> 内的 flush 过程在遇到错误时将回滚数据库事务以维护内部一致性。但是，一旦发生这种情况，该会话的事务现在处于“非活动”状态，并且必须由调用应用程序显式回滚以及它会提交某些修改。</p>
</dd>
</dl>
<p>这是ORM使用中经常遇到的错误，通常适用于在ORM的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  操作中尚未正确地安排其“框架”的应用程序。更多细节在   <a class="reference internal" href="faq/sessions.html#faq-session-rollback"><span class="std std-ref">“This Session’s transaction has been rolled back due to a previous exception during flush.” (或类似消息)</span></a>  中进行了描述。</p>
</section>
<section id="relationship-delete-orphan">
<span id="error-bbf0"></span><h3>在关系&lt;relationship&gt;中“delete-orphan”级联通常仅在一对多关系的“一”侧上配置，而不是多对一或多对多关系的“多”侧。<a class="headerlink" href="#relationship-delete-orphan" title="Permalink to this heading">¶</a></h3>
<p>当在多对一或多对多关系上设置“delete-orphan”级联时，将会出现此错误。例如：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
<p>bs = relationship(“B”, back_populates=”a”)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)
a_id = Column(ForeignKey(“a.id”))</p>
<p># 当使用 mapper 配置步骤时，此将发出错误消息
a = relationship(“A”, back_populates=”bs”, cascade=”all, delete-orphan”)</p>
</dd>
</dl>
<p>configure_mappers()</p>
</div></blockquote>
<p>以上，“B.a”上的“delete-orphan”设置表明，当每个引用特定“A”的每个“B”对象被删除时，该“A”应该被删除。也就是说，它表明正在表达“孤儿”将被删除的意图，这些孤儿是指一个“A”对象，在删除与之关联的所有“B”对象后，它将会成为一个孤儿。</p>
<p>“delete-orphan”级联模型不支持此功能。该“孤儿”考虑仅基于单个对象的删除，这将随后将所有引用其的零个或多个对象可视为“孤儿”，从而导致这些对象也被删除。换句话说，它仅设计为跟踪项的创建，这些项基于删除一个而仅有一个“父”对象完全成为孤儿的情况，这是在一对多关系中自然情况，其中在“many”侧上删除对象会导致“one”侧上相关项的后续删除。</p>
<p>此种 mapping 的正确应用方式是在一对多方面上放置级联设置，例如：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
<p>bs = relationship(“B”, back_populates=”a”, cascade=”all, delete-orphan”)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)
a_id = Column(ForeignKey(“a.id”))</p>
<p>a = relationship(“A”, back_populates=”bs”)</p>
</dd>
</dl>
</div></blockquote>
<p>其中的意图是表明当删除“A”时，它所引用的所有“B”对象也将被删除。</p>
<p>然后，错误消息会继续建议使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.single_parent</span></code>  标志。此标志可用于强制对可以允许多个对象引用特定对象的关系的明确处理，因为在每个表之间存在外键关系而实现的关系，并且实际上仅有一个对象实际上都引用给定目标对象。在使用了此标志的遗留模式或其他较少理想的数据库模式中，较少的实际对象实际上会在特定目标对象阵列中引用，而在其他方面，该目标对象看起来可以具有许多“孩子”对象。这种不寻常的情况可以如下所示：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
<p>bs = relationship(“B”, back_populates=”a”)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)
a_id = Column(ForeignKey(“a.id”))</p>
<dl class="simple">
<dt>a = relationship(</dt><dd><p>“A”,
back_populates=”bs”,
single_parent=True,
cascade=”all, delete-orphan”,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>上面的配置将安装验证器，该验证器强制将仅一个 B 与特定 A 相关联，范围在 B.a 关系内。</p>
<p>注意，该验证器的范围有限，并且不会防止从其他方向创建多个“父”。
因此，对于不是一对多关系的关系，更合适的方法是在一个或
多个关系中使用：paramref:<cite>_orm.relationship.back_populates</cite>。
也就是说，如果在这些关系中出现冲突，则应通过更改建模来解决。</p>
<p>总体而言，“delete-orphan”级联通常仅适用于一对多关系的“one”侧，以便在“many”侧上删除对象，而不是反过来。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/cascades.html#unitofwork-cascades"><span class="std std-ref">级联操作</span></a></p>
<p><a class="reference internal" href="orm/cascades.html#cascade-delete-orphan"><span class="std std-ref">delete-orphan</span></a></p>
<p><a class="reference internal" href="#error-bbf0"><span class="std std-ref">在关系&lt;relationship&gt;中“delete-orphan”级联通常仅在一对多关系的“一”侧上配置，而不是多对一或多对多关系的“多”侧。</span></a></p>
</div>
</section>
<section id="instance-attribute-instance">
<span id="error-bbf1"></span><h3>实例&lt; instance &gt; 已经通过其&lt;attribute&gt;属性与实例&lt;instance&gt;相关联，只允许一个父项。<a class="headerlink" href="#instance-attribute-instance" title="Permalink to this heading">¶</a></h3>
<p>当使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.single_parent</span></code>  标志时，如果多个对象同时作为对象的“parent”，则会发出此错误。</p>
<p>例如，考虑以下映射：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)
a_id = Column(ForeignKey(“a.id”))</p>
<dl class="simple">
<dt>a = relationship(</dt><dd><p>“A”,
single_parent=True,
cascade=”all, delete-orphan”,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>其中表明不应多于一个“B”对象引用特定的“A”对象。</p>
<p>以下是安排多个对象作为对象的“parent”时会出现意外错误时，通常导致的错误类型是对   <a class="reference internal" href="#error-bbf0"><span class="std std-ref">在关系&lt;relationship&gt;中“delete-orphan”级联通常仅在一对多关系的“一”侧上配置，而不是多对一或多对多关系的“多”侧。</span></a>  消息的误解。请参阅该消息了解详细信息。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#error-bbf0"><span class="std std-ref">在关系&lt;relationship&gt;中“delete-orphan”级联通常仅在一对多关系的“一”侧上配置，而不是多对一或多对多关系的“多”侧。</span></a></p>
</div>
</section>
<section id="x-q-p-s-y">
<span id="error-qzyx"></span><h3>关系 X 将 Q 列复制到 P 列，这与关系(s)：“Y”冲突。<a class="headerlink" href="#x-q-p-s-y" title="Permalink to this heading">¶</a></h3>
<p>此警告涉及到当两个或多个关系都将写入到相同的列上时，在ORM没有手段协调这些关系。
具体情况而定，解决方案可能是两个关系需要使用参数  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code>  相互连接，
或者其中一个或多个  <span class="xref std std-term">single-table</span>  继承映射没有正确进行配置，可以使用继承条件（inherit condition）级联来解决此问题。等等…应该使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.viewonly</span></code>  来配置关系，以防止冲突写入，或者有时意图完全并且应该配置  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.overlaps</span></code>  来消除每个警告的影响。</p>
<p>对于通常缺少  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code>  的示例，请考虑下面的映射类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面的映射会产生警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: relationship &#39;Child.parent&#39; will copy column parent.id to column child.parent_id,
which conflicts with relationship(s): &#39;Parent.children&#39; (copies parent.id to child.parent_id).</pre></div>
</div>
<p>关系 <code class="docutils literal notranslate"><span class="pre">Child.parent</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 显然是相互冲突的。解决方案是应用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code>  ：</p>
<blockquote>
<div><dl class="simple">
<dt>class Parent(Base):</dt><dd><p>__tablename__ = “parent”
id = Column(Integer, primary_key=True)
children = relationship(“Child”, back_populates=”parent”)</p>
</dd>
<dt>class Child(Base):</dt><dd><p>__tablename__ = “child”
id = Column(Integer, primary_key=True)
parent_id = Column(ForeignKey(“parent.id”))
parent = relationship(“Parent”, back_populates=”children”)</p>
</dd>
</dl>
</div></blockquote>
<p>对于需要更自定义的关系，其中“overlap”情况可能是有意的，并且不能被解决，则可以通过  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.overlaps</span></code>  参数指定名称，其中警告不应发生作用。这通常发生在针对相同基础表的两个或多个关系的情况下，这些表包括限制每种情况下的相关项的自定义  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.primaryjoin</span></code>  条件的情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Child&quot;</span><span class="p">,</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(Parent.id == Child.parent_id, Child.flag == 0)&quot;</span><span class="p">,</span>
        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="n">overlaps</span><span class="o">=</span><span class="s2">&quot;c2, parent&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Child&quot;</span><span class="p">,</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(Parent.id == Child.parent_id, Child.flag == 1)&quot;</span><span class="p">,</span>
        <span class="n">overlaps</span><span class="o">=</span><span class="s2">&quot;c1, parent&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span>

    <span class="n">flag</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在上述代码中，ORM 将知道 <code class="docutils literal notranslate"><span class="pre">Parent.c1</span></code>、<code class="docutils literal notranslate"><span class="pre">Parent.c2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Child.parent</span></code> 之间的重叠是有意的。</p>
</section>
<section id="orm-session-orm-session-expunge-all-persistent">
<span id="error-lkrp"></span><h3>由于   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  已关闭或以其他方式调用了  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expunge_all()</span></code>  方法，因此无法将对象转换为“persistent”状态，因此该标识映射不再有效。<a class="headerlink" href="#orm-session-orm-session-expunge-all-persistent" title="Permalink to this heading">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.26.</span></p>
</div>
<p>此消息是为了适应在关闭或以其他方式调用其  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expunge_all()</span></code>  方法的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  之后仍会迭代会生成 ORM 对象的   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象的情况而添加的。当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  一次性删除所有对象时，该  <span class="xref std std-term">identity map</span>  内部使用的  <span class="xref std std-term">identity map</span>  将被更换为新的，原始的部分会被丢弃。未使用的和未缓冲的   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象将在内部保留对该现已丢弃的标识映射的引用。因此，当消耗   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象时，将产生对象，这些对象不能与该   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  相关联。这是设计的排列，因为通常不建议在创建它的事务上下文之外迭代未缓冲的   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 上下文管理器创建新的 Session</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session_obj</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">))</span>

<span class="c1"># 上下文管理器已关闭，因此 session_obj 在此处关闭，identity</span>
<span class="c1"># 映射被替换</span>

<span class="c1"># 迭代结果对象无法将对象与</span>
<span class="c1"># Session 相关联，因此会引发此错误。</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></pre></div>
</div>
<p>在上述情况下，通常不会发生使用 <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> ORM 扩展，因为当   <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a>  返回类似于同步样式的   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  时，结果已在执行该语句时预先缓冲。这是为了允许在不需要额外的 <code class="docutils literal notranslate"><span class="pre">await</span></code> 调用的情况下调用二次贪婪加载器。</p>
<p>要在使用常规的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中使用上面所述的结果预取方式模拟情况，可以使用 <code class="docutils literal notranslate"><span class="pre">prebuffer_rows</span></code> 执行选项，如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 上下文管理器创建新的 Session</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session_obj</span><span class="p">:</span>
    <span class="c1"># 外部结果预取所有对象</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">),</span> <span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;prebuffer_rows&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">)</span>

<span class="c1"># 上下文管理器已关闭，因此 session_obj 在此处关闭，identity</span>
<span class="c1"># 映射被替换</span>

<span class="c1"># 返回预缓冲对象</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># 但它们被分离，与已关闭的会话有关</span>
<span class="k">assert</span> <span class="n">inspect</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">detached</span>
<span class="k">assert</span> <span class="n">inspect</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="kc">None</span></pre></div>
</div>
<p>在上述代码中，所选的 ORM 对象完全在 <code class="docutils literal notranslate"><span class="pre">session_obj</span></code> 块内生成，与 <code class="docutils literal notranslate"><span class="pre">session_obj</span></code> 相关联，并在   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象中缓冲以进行迭代。在块外部，<code class="docutils literal notranslate"><span class="pre">session_obj</span></code> 被关闭并且摆脱了这些 ORM 对象。迭代   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象将提供这些 ORM 对象，但是由于它们的起始   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  已将它们删除，因此它们将以  <span class="xref std std-term">分离</span>  状态传递。</p>
</section>
<section id="error-zlpr">
<span id="id11"></span><h3>引用声明性表格表单的类型注释不能解释<a class="headerlink" href="#error-zlpr" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 2.0 引入了一种新的   <a class="reference internal" href="orm/declarative_tables.html#orm-declarative-mapped-column"><span class="std std-ref">Annotated Declarative Table</span></a>  声明性系统，该系统通过在类定义中派生使用  <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  注释来注释 ORM 映射属性信息。此形式的要求是所有 ORM 注释必须使用名为   <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  的通用容器才能被正确注释。使用显式  <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  类型注释的旧版 SQLAlchemy 映射，例如使用   <a class="reference internal" href="orm/extensions/mypy.html"><span class="std std-ref">legacy Mypy 扩展</span></a>  为类型支持的那些映射，可能包括不包括使用不包括此通用程序的   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  的指令。</p>
<p>要解决此问题，可以在类被完全迁移到 2.0 语法之前，将这些类标记为具有 <code class="docutils literal notranslate"><span class="pre">__allow_unmapped__</span></code> 布尔属性。有关示例，请参见   <span class="xref std std-ref">migration_20_step_six</span>  中的迁移说明.</p>
</section>
<section id="cls-python">
<span id="error-dcmx"></span><h3>将 &lt;cls&gt; 转换为数据类时发生 Python 数据类错误<a class="headerlink" href="#cls-python" title="Permalink to this heading">¶</a></h3>
<p>此警告是在   <a class="reference internal" href="orm/dataclasses.html#orm-declarative-native-dataclasses"><span class="std std-ref">声明数据类映射</span></a>  中描述的 SQLAlchemy ORM Mapped Dataclasses 功能中添加的，结合非本身声明为数据类的 mixin 类或抽象基类使用时。例如，下面是一个包含非数据类 mixin 类的映射声明及其生成的警告信息：</p>
<blockquote>
<div><p>from __future__ import annotations</p>
<p>import inspect
from typing import Optional
from uuid import uuid4</p>
<p>from sqlalchemy import String
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import MappedAsDataclass</p>
<dl>
<dt>class Mixin:</dt><dd><p>create_user: Mapped[int] = mapped_column()
update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)</p>
</dd>
<dt>class Base(DeclarativeBase, MappedAsDataclass):</dt><dd><p>pass</p>
</dd>
<dt>class User(Base, Mixin):</dt><dd><p>__tablename__ = “sys_user”</p>
<dl class="simple">
<dt>uid: Mapped[str] = mapped_column(</dt><dd><p>String(50), init=False, default_factory=uuid4, primary_key=True</p>
</dd>
</dl>
<p>)
username: Mapped[str] = mapped_column()
email: Mapped[str] = mapped_column()</p>
</dd>
</dl>
</div></blockquote>
<p>如上所述，由于 <code class="docutils literal notranslate"><span class="pre">Mixin</span></code> 本身没有从   <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedAsDataclass</span></code>  派生，因此会生成以下警告：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SADeprecationWarning: When transforming &lt;class &#39;__main__.User&#39;&gt; to a
dataclass, attribute(s) &quot;create_user&quot;, &quot;update_user&quot; originates from
superclass &lt;class
&#39;__main__.Mixin&#39;&gt;, which is not a dataclass. This usage is deprecated and
will raise an error in SQLAlchemy 2.1. When declaring SQLAlchemy
Declarative Dataclasses, ensure that all mixin classes and other
superclasses which include attributes are also a subclass of
MappedAsDataclass.</pre></div>
</div>
<p>解决方法是同样在 <code class="docutils literal notranslate"><span class="pre">Mixin</span></code> 签名中添加   <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedAsDataclass</span></code> ，如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mixin</span><span class="p">(</span><span class="n">MappedAsDataclass</span><span class="p">):</span>
    <span class="n">create_user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">()</span>
    <span class="n">update_user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Python 的  <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>  规范不包括在不是数据类的数据类超类上声明的属性。根据 Python 数据类的行为，类似地，这些字段将被忽略，例如，如以下示例所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">field</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>


<span class="k">class</span> <span class="nc">Mixin</span><span class="p">:</span>
    <span class="n">create_user</span><span class="p">:</span> <span class="n">int</span>
    <span class="n">update_user</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Mixin</span><span class="p">):</span>
    <span class="n">uid</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">()))</span>
    <span class="n">username</span><span class="p">:</span> <span class="n">str</span>
    <span class="n">password</span><span class="p">:</span> <span class="n">str</span>
    <span class="n">email</span><span class="p">:</span> <span class="n">str</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>上述 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类将不在其构造函数中包含 <code class="docutils literal notranslate"><span class="pre">create_user</span></code>，也不会尝试将 <code class="docutils literal notranslate"><span class="pre">update_user</span></code> 解释为数据类属性。这是因为 <code class="docutils literal notranslate"><span class="pre">Mixin</span></code> 不是数据类。</p>
<p>SQLAlchemy 2.0 系列中的数据类特性不正确解决此行为；反过来，数据类混合和具有 SQLAlchemy 映射属性的超类被视为最终的数据类配置的一部分。但是，Pyright 和 Mypy 等类型检查器不会将这些字段视为数据类构造函数的一部分，因为它们根据  <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>  要求应该被忽略。因此，由于其存在是模棱两可的，从 SQLAlchemy 2.1 开始，使用数据类继承 SQLAlchemy 映射属性时，必须将 mixin 类本身成为数据类。</p>
</section>
<section id="orm">
<span id="error-bupq"></span><h3>使用按主键的 ORM 按行批量更新需要记录包含主键值的记录<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h3>
<p>在使用类似以下用法的   <a class="reference internal" href="orm/queryguide/dml.html#orm-queryguide-bulk-update"><span class="std std-ref">ORM基于主键的批量UPDATE</span></a>  功能时，如果记录中不提供主键值，则会发生此错误：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;u_name&quot;</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;patrick&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Patrick Star&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>在上面的示例中，由于带有参数字典的列表结合   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  使用 ORM 执行了启用了 ORM 按主键的按行批量更新，因此参数字典必须包括主键值，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Patrick Star&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Eugene H. Krabs&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>要在没有提供每行主键值的情况下调用 UPDATE 语句，可以使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.connection()</span></code>  方法，以获取当前   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> ，然后使用该方法执行:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;u_name&quot;</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;patrick&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Patrick Star&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
</section>
</section>
<section id="asyncio">
<h2>AsyncIO 异常<a class="headerlink" href="#asyncio" title="Permalink to this heading">¶</a></h2>
<section id="awaitrequired">
<span id="error-xd1r"></span><h3>AwaitRequired<a class="headerlink" href="#awaitrequired" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 异步模式需要使用异步驱动程序连接到 db。
通常在试图使用非兼容  <span class="xref std std-term">DBAPI</span>  时使用异步 SQLAlchemy 版本会引发此错误。</p>
</section>
<section id="missinggreenlet">
<span id="error-xd2s"></span><h3>MissingGreenlet<a class="headerlink" href="#missinggreenlet" title="Permalink to this heading">¶</a></h3>
<p>在未预期的位置启动异步  <span class="xref std std-term">DBAPI</span>  时，会发生此错误，通常是在某个 I/O 中尝试时，使用不直接提供使用 <code class="docutils literal notranslate"><span class="pre">await</span></code> 关键字的调用模式。在使用 ORM 时，这几乎始终是由于使用了  <span class="xref std std-term">lazy loading</span>  所引起的，而在 asyncio 中，则需要额外的步骤和/或备选装入器模式才能使用成功。</p>
</section>
<section id="no-inspection-available">
<span id="error-xd3s"></span><h3>No Inspection Available<a class="headerlink" href="#no-inspection-available" title="Permalink to this heading">¶</a></h3>
<p>在   <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection" title="sqlalchemy.ext.asyncio.AsyncConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncConnection</span></code></a>  或   <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine" title="sqlalchemy.ext.asyncio.AsyncEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncEngine</span></code></a>  对象上直接使用   <a class="reference internal" href="core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a>  函数目前不受支持，因为还没有名称为   <code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code>  的可等待对象。因此，可以通过以下方式获得引用：</p>
<p>使用   <a class="reference internal" href="core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a>  函数，以便它引用   <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection" title="sqlalchemy.ext.asyncio.AsyncConnection.sync_connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sync_connection</span></code></a>  属性的底层对象；然后使用   <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync" title="sqlalchemy.ext.asyncio.AsyncConnection.run_sync"><code class="xref py py-class docutils literal notranslate"><span class="pre">run_sync</span></code></a>  方法，以及执行所需操作的自定义函数来使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code> ：</p>
<blockquote>
<div><dl>
<dt>async def async_main():</dt><dd><dl>
<dt>async with engine.connect() as conn:</dt><dd><dl class="simple">
<dt>tables = await conn.run_sync(</dt><dd><p>lambda sync_conn: inspect(sync_conn).get_table_names()</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</section>
</section>
<section id="id12">
<h2>核心异常类<a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h2>
<p>有关核心异常类，请参见   <a class="reference internal" href="core/exceptions.html"><span class="std std-ref">核心异常</span></a> 。</p>
</section>
<section id="id13">
<h2>ORM 异常类<a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h2>
<p>有关 ORM 异常类，请参见   <span class="xref std std-ref">orm_exceptions_toplevel</span> 。</p>
</section>
<section id="id14">
<h2>历史遗留异常<a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h2>
<p>本节中的异常不适用于当前 SQLAlchemy 版本，但在此提供以适应异常消息的超链接。</p>
<section id="sqlalchemy-2-0">
<span id="error-b8d9"></span><h3>在 SQLAlchemy 2.0 中，&lt;某些函数&gt; 将不再&lt;某些行为&gt;<a class="headerlink" href="#sqlalchemy-2-0" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 2.0 对 Core 和 ORM 组件的众多关键用法模式进行了重大变化。2.0 发布的目标是在 SQLAlchemy 自从早期开始的一些最基本的假设中进行轻微的调整，并提供一个新的简化使用模型，这个模型希望显著更加极简主义，并且在 Core 和 ORM 组件之间更加一致，也更加具有可操作性。</p>
<p>在   <a class="reference internal" href="changelog/migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - 主要迁移指南</span></a>  中引入的 SQLAlchemy 2.0 项目包括综合未来兼容性的系统，该系统集成到 SQLAlchemy 1.4 系列中，这样应用程序就有了一个明确、明显的增量升级路径，以使其成为完全 2.0 兼容。  <code class="xref py py-class docutils literal notranslate"><span class="pre">RemovedIn20Warning</span></code>  弃用警告是该系统的基础，提供有关现有代码库中需要修改的行为的指导。在   <a class="reference internal" href="changelog/migration_14.html#deprecation-20-mode"><span class="std std-ref">SQLAlchemy 2.0 退化模式</span></a>  中可以找到如何启用此警告的概述。</p>
</section>
<section id="error-s9r1">
<span id="id15"></span><h3>此连接处于非活动事务中。请在继续之前执行回滚（）。<a class="headerlink" href="#error-s9r1" title="Permalink to this heading">¶</a></h3>
<p>此错误的条件是在 SQLAlchemy 1.4 之后添加的，并且不适用于 SQLAlchemy 2.0。该错误是指在使用  <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection.begin" title="sqlalchemy.engine.Connection.begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.begin()</span></code></a>  等方法将   <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  放入事务中，然后在该范围内的事务中创建了另一个“标记”事务；然后使用  <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Transaction.rollback" title="sqlalchemy.engine.Transaction.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.rollback()</span></code></a>  或  <a class="reference internal" href="core/connections.html#sqlalchemy.engine.Transaction.close" title="sqlalchemy.engine.Transaction.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Transaction.close()</span></code></a>  回滚或关闭了内部事务，但外部事务仍处于“非活动”状态，并且必须回滚。</p>
<p>该模式类似于：</p>
<blockquote>
<div><p>engine = create_engine(…)</p>
<p>connection = engine.connect()
transaction1 = connection.begin()</p>
<p># 这是一个“子”或“标记”事务，一个基于“真实”事务 transaction1 的逻辑嵌套结构
transaction2 = connection.begin()
transaction2.rollback()</p>
<p># transaction1 仍然存在，并且需要显式回滚，
# 因此这将引发错误。
connection.execute(text(“select 1”))</p>
</div></blockquote>
<p>在上面的代码中，<code class="docutils literal notranslate"><span class="pre">transaction2</span></code> 是一个“标记”事务，它表示外部事务的逻辑嵌套；虽然内部事务可以通过 rollback() 方法回滚整个事务，但是其 commit() 方法没有除了关闭“标记”事务自身的作用。调用 <code class="docutils literal notranslate"><span class="pre">transaction2.rollback()</span></code> 的效果是 <strong>停用</strong> transaction1，这意味着它在数据库级别上被回滚，但是仍然存在，以便适应事务的一致嵌套结构。</p>
<p>正确的解决方法是确保也回滚外部事务:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">transaction1</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span></pre></div>
</div>
<p>在 Core 中不常用。在 ORM 中，也可以出现类似的问题，这是由 ORM 的“逻辑”事务结构引起的；这种情况下，请遵循以下建议进行操作。</p>
<p>这个错误在FAQ条目   <a class="reference internal" href="faq/sessions.html#faq-session-rollback"><span class="std std-ref">“This Session’s transaction has been rolled back due to a previous exception during flush.” (或类似消息)</span></a>  中有所描述。</p>
<p>在SQLAlchemy 2.0版本中，”subtransaction” 模式已被移除，因此这种编程模式不再可用，从而避免了这个错误信息的出现。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="faq/thirdparty.html" title="previous chapter">第三方集成问题</a>
        Next:
        <a href="changelog/index.html" title="next chapter">变更和迁移</a>

    <div id="docs-copyright">
        &copy; <a href="copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:43:52

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    './',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="_static/clipboard.min.js"></script>
        <script type="text/javascript" src="_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="_static/init.js"></script>


    </body>
</html>


