<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    错误消息
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/default.css" type="text/css" />
                <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
        <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="index.html" />
        <link rel="next" title="变更和迁移" href="changelog/index.html" />
        <link rel="prev" title="第三方集成问题" href="faq/thirdparty.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy 2.0 Documentation">SQLAlchemy 2.0 Documentation</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="intro.html">概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="tutorial/index.html">SQLAlchemy统一教程</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm/index.html">SQLAlchemy ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="core/index.html">SQLAlchemy核心模块</a></span></li>
<li><span class="link-container"><a class="reference external" href="dialects/index.html">方言</a></span></li>
<li><span class="link-container"><a class="reference external" href="faq/index.html">常见问题解答</a></span></li>
<li class="selected"><span class="link-container"><strong>错误消息</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id2">连接和事务</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#size-x-queuepool-z">达到size &lt;x&gt;的QueuePool限制，连接已超时，超时时间 &lt;z&gt;</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-8s2b">在继续之前, 请将无效事务完全回滚。请回滚()</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dbapi">DBAPI错误</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#interfaceerror">InterfaceError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#databaseerror">DatabaseError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#dataerror">DataError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#operationalerror">OperationalError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#integrityerror">IntegrityError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#internalerror">InternalError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#programmingerror">ProgrammingError</a></span></li>
<li><span class="link-container"><a class="reference external" href="#notsupportederror">NotSupportedError</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sql">SQL表达式语言</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#object-will-not-produce-a-cache-key-performance-implications">Object will not produce a cache key, Performance Implications</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id4">缓存会自行禁用</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">缓存引用属性</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#compiler-strsqlcompiler-can-t-render-element-of-type-element-type">Compiler StrSQLCompiler can’t render element of type &lt;element type&gt;</a></span></li>
<li><span class="link-container"><a class="reference external" href="#typeerror-columnproperty-something">TypeError: &lt;操作符&gt;不支持在“ColumnProperty”实例和&lt;something&gt;之间的实例</a></span></li>
<li><span class="link-container"><a class="reference external" href="#x-y">在继续之前，必须为绑定参数 &lt;x&gt; 在参数组 &lt;y&gt; 中提供值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#from-select-from-subquery">预期 FROM 子句，得到 Select。要创建 FROM 子句，请使用 .subquery() 方法</a></span></li>
<li><span class="link-container"><a class="reference external" href="#clauseelement">自动为原始 clauseelement 生成别名</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-xaj2">由于重叠的表而自动生成别名</a></span></li>
<li><span class="link-container"><a class="reference external" href="#xqp-y">关系X将把列Q复制到列P，这与关系相冲突：’Y’</a></span></li>
<li><span class="link-container"><a class="reference external" href="#persistent">无法将对象转换为 “persistent” 状态，因为此标识图不再有效。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#annotated-declarative-table">无法解释 Annotated Declarative Table 形式的注释类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#cls-cls">将 &lt;cls&gt; 转换为数据类时出错，其中一个或多个属性来自于不是数据类的超类 &lt;cls&gt;。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm">对于每个主键，按行 ORM 群集更新需要记录包含主键值</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#io">异步 IO 异常</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#awaitrequired">AwaitRequired</a></span></li>
<li><span class="link-container"><a class="reference external" href="#missinggreenlet">MissingGreenlet</a></span></li>
<li><span class="link-container"><a class="reference external" href="#no-inspection-available">No Inspection Available</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id9">核心异常类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id10">ORM 异常类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id11">历史遗留问题</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy-2-0">在 SQLAlchemy 2.0 中，&lt;某些函数&gt; 将不再 &lt;做某事&gt;</a></span></li>
<li><span class="link-container"><a class="reference external" href="#backref-session">对象正在通过 backref 级联合并到 Session 中</a></span></li>
<li><span class="link-container"><a class="reference external" href="#legacy-select">在 “legacy” 模式下创建的 select() 构造; 关键字参数等。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#legacy-future-true">找到使用的是 legacy 绑定元数据绑定，但由于在此会话中设置了 future=True，因此将忽略该绑定。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#error-2afi">此编译对象未绑定到任何引擎或连接</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="changelog/index.html">变更和迁移</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="faq/thirdparty.html" title="previous chapter">第三方集成问题</a></li>
                <li><b>Next:</b>
                <a href="changelog/index.html" title="next chapter">变更和迁移</a></li>

            <li><b>Up:</b> <a href="index.html">Home</a></li>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#errors">错误消息</a><ul>
<li><a class="reference internal" href="#id2">连接和事务</a><ul>
<li><a class="reference internal" href="#size-x-queuepool-z">达到size &lt;x&gt;的QueuePool限制，连接已超时，超时时间 &lt;z&gt;</a></li>
<li><a class="reference internal" href="#error-8s2b">在继续之前, 请将无效事务完全回滚。请回滚()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dbapi">DBAPI错误</a><ul>
<li><a class="reference internal" href="#interfaceerror">InterfaceError</a></li>
<li><a class="reference internal" href="#databaseerror">DatabaseError</a></li>
<li><a class="reference internal" href="#dataerror">DataError</a></li>
<li><a class="reference internal" href="#operationalerror">OperationalError</a></li>
<li><a class="reference internal" href="#integrityerror">IntegrityError</a></li>
<li><a class="reference internal" href="#internalerror">InternalError</a></li>
<li><a class="reference internal" href="#programmingerror">ProgrammingError</a></li>
<li><a class="reference internal" href="#notsupportederror">NotSupportedError</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sql">SQL表达式语言</a><ul>
<li><a class="reference internal" href="#object-will-not-produce-a-cache-key-performance-implications">Object will not produce a cache key, Performance Implications</a><ul>
<li><a class="reference internal" href="#id4">缓存会自行禁用</a></li>
<li><a class="reference internal" href="#id5">缓存引用属性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compiler-strsqlcompiler-can-t-render-element-of-type-element-type">Compiler StrSQLCompiler can’t render element of type &lt;element type&gt;</a></li>
<li><a class="reference internal" href="#typeerror-columnproperty-something">TypeError: &lt;操作符&gt;不支持在“ColumnProperty”实例和&lt;something&gt;之间的实例</a></li>
<li><a class="reference internal" href="#x-y">在继续之前，必须为绑定参数 &lt;x&gt; 在参数组 &lt;y&gt; 中提供值</a></li>
<li><a class="reference internal" href="#from-select-from-subquery">预期 FROM 子句，得到 Select。要创建 FROM 子句，请使用 .subquery() 方法</a></li>
<li><a class="reference internal" href="#clauseelement">自动为原始 clauseelement 生成别名</a></li>
<li><a class="reference internal" href="#error-xaj2">由于重叠的表而自动生成别名</a></li>
<li><a class="reference internal" href="#xqp-y">关系X将把列Q复制到列P，这与关系相冲突：’Y’</a></li>
<li><a class="reference internal" href="#persistent">无法将对象转换为 “persistent” 状态，因为此标识图不再有效。</a></li>
<li><a class="reference internal" href="#annotated-declarative-table">无法解释 Annotated Declarative Table 形式的注释类型</a></li>
<li><a class="reference internal" href="#cls-cls">将 &lt;cls&gt; 转换为数据类时出错，其中一个或多个属性来自于不是数据类的超类 &lt;cls&gt;。</a></li>
<li><a class="reference internal" href="#orm">对于每个主键，按行 ORM 群集更新需要记录包含主键值</a></li>
</ul>
</li>
<li><a class="reference internal" href="#io">异步 IO 异常</a><ul>
<li><a class="reference internal" href="#awaitrequired">AwaitRequired</a></li>
<li><a class="reference internal" href="#missinggreenlet">MissingGreenlet</a></li>
<li><a class="reference internal" href="#no-inspection-available">No Inspection Available</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">核心异常类</a></li>
<li><a class="reference internal" href="#id10">ORM 异常类</a></li>
<li><a class="reference internal" href="#id11">历史遗留问题</a><ul>
<li><a class="reference internal" href="#sqlalchemy-2-0">在 SQLAlchemy 2.0 中，&lt;某些函数&gt; 将不再 &lt;做某事&gt;</a></li>
<li><a class="reference internal" href="#backref-session">对象正在通过 backref 级联合并到 Session 中</a></li>
<li><a class="reference internal" href="#legacy-select">在 “legacy” 模式下创建的 select() 构造; 关键字参数等。</a></li>
<li><a class="reference internal" href="#legacy-future-true">找到使用的是 legacy 绑定元数据绑定，但由于在此会话中设置了 future=True，因此将忽略该绑定。</a></li>
<li><a class="reference internal" href="#error-2afi">此编译对象未绑定到任何引擎或连接</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar errors" >
        
<section id="errors">
<span id="id1"></span><h1>错误消息<a class="headerlink" href="#errors" title="Permalink to this heading">¶</a></h1>
<p>这个部分列出了常见的SQLAlchemy抛出或发出的错误消息和警告的描述和背景。</p>
<p>SQLAlchemy通常会在SQLAlchemy特定的异常类上下文中引发错误。有关这些类的详细信息，请参见 <span class="xref std std-ref">core_exceptions_toplevel</span> 和 <a class="reference internal" href="orm/exceptions.html"><span class="std std-ref">ORM 异常</span></a>。</p>
<p>SQLAlchemy错误可以大致分为两类，即 <strong>编程时间错误</strong> 和 <strong>运行时错误</strong>。编程时间错误是由于使用错误的参数调用函数或方法或来自无法解析的其他配置导向方法，如映射器配置而引发的。编程时间错误通常是即时的和确定性的。另一方面，运行时错误表示程序在响应发生在任意情况下的某些条件时发生的失败，例如数据库连接被用尽或发生某些与数据相关的问题。运行时错误更可能在正在运行的应用程序的日志中看到，因为程序在遇到这些状态时会响应加载和遇到的数据。</p>
<p>由于运行时错误不容易重现，并且经常发生在程序运行时，以响应某些任意条件，例如数据库连接被耗尽或出现某些数据相关问题，因此它们更难于调试，并且还会影响已经投入生产的程序。</p>
<p>在本节中，目标是尝试提供有关一些常见的运行时错误以及编程时间错误的背景。</p>
<section id="id2">
<h2>连接和事务<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<section id="size-x-queuepool-z">
<span id="error-3o7r"></span><h3>达到size &lt;x&gt;的QueuePool限制，连接已超时，超时时间 &lt;z&gt;<a class="headerlink" href="#size-x-queuepool-z" title="Permalink to this heading">¶</a></h3>
<p>这可能是经验最丰富的常见的运行时错误，因为它直接涉及应用程序的工作负载，对几乎所有SQLAlchemy应用程序都适用的配置限制，这是一种直接应用的负载。</p>
<p>以下几点总结了此错误的含义，从大多数SQLAlchemy用户应已熟悉的最基本的点开始。</p>
<ul>
<li><p><strong>SQLAlchemy引擎对象默认使用连接池</strong> - 这意味着当一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 对象的SQL数据库连接资源被使用，并且释放了这个资源之后，数据库连接本身仍然连到数据库，并且返回到内部队列中，可以重新使用它。即使代码似乎正在与数据库结束对话，在许多情况下，应用程序仍将保留一定数量的数据库连接，这些连接会持续，直到应用程序结束或显示丢弃池。</p></li>
<li><p>由于连接池，当一个应用程序使用SQL数据库连接时，大多数情况下从 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.connect()</span></code> 中返回，或在使用ORM <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 时进行查询，这些操作并不一定在获取连接对象时立即建立新的数据库连接；相反，它会查询连接池以获取连接，它通常会从池中检索一个现有连接以重新使用。如果没有可用的连接，则连接池将创建一个新的数据库连接，但仅当池未超过配置容量时。</p></li>
<li><p>在大多数情况下使用的默认池称为 <a class="reference internal" href="core/pooling.html#sqlalchemy.pool.QueuePool" title="sqlalchemy.pool.QueuePool"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueuePool</span></code></a>。当要求此池提供连接但没有可用连接时，如果正在播放的**总连接数小于配置的值**，它将创建一个新连接。该值等于**池的大小加上max overflow大小**。这意味着如果您已经配置了引擎作为：</p>
<blockquote>
<div><p>engine = create_engine(“mysql+mysqldb://u:p&#64;host/db”, pool_size = 10, max_overflow = 20)</p>
<p>上述 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 将允许在任何时间最多30个连接，不包括从引擎分离或失效的连接。如果到达新连接的请求并且已经有30个连接被其他应用程序的其他部分使用，则连接池将阻塞一段固定的时间，然后超时并引发此错误消息。</p>
<p>为了允许同时使用更多的连接，可以使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.pool_size</span></code> 和 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.max_overflow</span></code> 传递给  <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code> 函数的参数来调整池。等待连接可用的超时时间是使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.pool_timeout</span></code> 参数配置的。</p>
</div></blockquote>
</li>
<li><p>可以通过将 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.max_overflow</span></code> 设置为值“-1”来配置池具有无限制的溢出。使用此设置时，池仍将维护固定数量的连接池，但如果没有可用连接，则不会无条件地阻止请求新连接。</p>
<p>但是，以这种方式运行时，如果应用程序存在使用所有可用连接可用性资源的问题，则最终会达到数据库本身的可用连接限制，从而再次返回错误。更为严重的是，当应用程序耗尽数据库的连接时，通常会使用大量的资源，并且可能会干扰依赖于能够连接到数据库的其他应用程序和数据库状态机制。</p>
<p>鉴于上述原因，连接池可以看作是连接使用的 <strong>安全阀</strong>，为防止恶意应用程序导致整个数据库对所有其他应用程序不可用，从而提供了关键的保护层。当收到此错误消息时，最好使用使用过多连接的问题进行修复和/或适当地配置限制，而不是允许无限制的溢出，因为这并不实际解决潜在的问题。</p>
</li>
</ul>
<p>是什么导致应用程序使用完所有可用连接？</p>
<ul>
<li><p><strong>应用程序正在处理太多并发请求以基于池的配置做工作</strong> - 这是最直接的原因。如果您有一个运行于允许30个并发线程的线程池中的应用程序，并且每个线程使用一个连接，在不允许同时检出至少30个连接的情况下，一旦您的应用程序接收到足够的并发请求，您将获得此错误。解决方案是提高池的限制或降低并发线程的数量。</p></li>
<li><p><strong>应用程序没有将连接返回到池中</strong> - 这是下一个最常见的原因，即应用程序正在使用连接池，但该程序正在未能 <span class="xref std std-term">释放</span> 这些连接，而是将它们保持打开状态。无论ORM会话和/或连接对象何时被垃圾回收，它会导致底层连接资源被释放，但是在及时释放资源方面，无法依赖这种行为。</p>
<p>这种情况可能会发生的一个常见原因是，应用程序使用ORM会话并在完成涉及该会话的工作之后没有调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code>。应该确保ORM会话（如果使用ORM）还是绑定到引擎的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code> 对象（如果使用Core），在完成工作的结束时被明确关闭，通过适当的 <code class="docutils literal notranslate"><span class="pre">.close()</span></code> 方法或使用可用上下文管理器（例如“with:”语句）之一来释放资源。</p>
</li>
<li><p><strong>应用程序正试图运行长时间运行的事务</strong> - 数据库事务是非常昂贵的资源，并且应该**永远不要闲置等待某些事件发生**。如果应用程序正在等待用户按按钮或等待长时间运行作业队列的结果，或者正在持久保持连接到浏览器，则**不要将数据库事务保持打开状态**。由于应用程序需要与数据库交互并与事件交互，因此在该点打开短暂的事务然后关闭它。</p></li>
<li><p><strong>应用程序死锁</strong> -这也是产生此错误的常见原因，而且更难以理解，如果应用程序无法完成对连接的使用，无论是由于应用程序端还是由于数据库端的死锁，应用程序可以使用所有可用连接，这然后导致额外的请求接收到此错误。死锁的原因包括：</p>
<ul class="simple">
<li><p>使用隐式异步系统（如gevent或eventlet）而没有正确的 monkeypatching 所有场景库和驱动程序，或者有错误，在不完全覆盖所有monkeypatched驱动程序方法方面，或者在使用异步系统进行对CPU绑定工作负载的情况下，使用数据库资源的greenlets简单地等待太长时间而无法对其进行处理。对于绝大多数关系型数据库操作，隐式或显式异步编程框架通常是不必要的或不适用的。如果应用程序必须在某些功能区域中使用异步系统，则最好运行数据库导向的业务方法在传统线程中运行，该线程向应用程序的异步部分传递消息。</p></li>
<li><p>数据库死锁，例如行彼此死锁</p></li>
<li><p>线程错误，例如互斥体在互斥死锁中，或在同一线程中调用已锁定的互斥体</p></li>
</ul>
</li>
</ul>
<p>请记住，使用连接池的替代方法是完全关闭池。有关此问题的背景，请参见 <a class="reference internal" href="core/pooling.html#pool-switching"><span class="std std-ref">切换池实现</span></a> 部分。但是，请注意，当此错误消息发生时，它始终是由应用程序本身中的更大问题造成的；池只有在早期阶段揭示了该问题。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/pooling.html"><span class="std std-ref">连接池</span></a></p>
<p><a class="reference internal" href="core/connections.html"><span class="std std-ref">使用Engine和Connection</span></a></p>
</div>
</section>
<section id="error-8s2b">
<span id="id3"></span><h3>在继续之前, 请将无效事务完全回滚。请回滚()<a class="headerlink" href="#error-8s2b" title="Permalink to this heading">¶</a></h3>
<p>此错误情况指的是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code> 已失效，由于检测到数据库断开连接或由于显式调用了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.invalidate()</span></code>，但仍然存在一个事务，该事务由 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.begin()</span></code> 方法明确或由于连接在发出任何SQL语句时自动开始，而处于“未完成”状态。连接无效专为不再使用的一次性使用而设计，并用于避免该语言之前的历史中可能存在的问题，它通常伴随有较多消耗的项目。</p>
</section>
</section>
<section id="dbapi">
<span id="error-dbapi"></span><h2>DBAPI错误<a class="headerlink" href="#dbapi" title="Permalink to this heading">¶</a></h2>
<p>Python数据库API或DBAPI是数据库驱动程序的规范，可在 <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">Pep 249</a> 上找到。此API指定了一组异常类，其能够适应数据库的所有故障模式。</p>
<p>SQLAlchemy不会直接生成这些异常。相反，它们被从数据库驱动程序拦截并由SQLAlchemy提供的异常 <a class="reference internal" href="core/exceptions.html#sqlalchemy.exc.DBAPIError" title="sqlalchemy.exc.DBAPIError"><code class="xref py py-class docutils literal notranslate"><span class="pre">DBAPIError</span></code></a> 进行包装，但是异常消息是 <strong>由驱动程序生成的，而不是SQLAlchemy</strong> 。</p>
<section id="interfaceerror">
<span id="error-rvf5"></span><h3>InterfaceError<a class="headerlink" href="#interfaceerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库本身相关，而非数据库接口的错误引发的异常。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
<p>“InterfaceError”有时由驱动程序在上下文中引发，而数据库连接被放弃，或无法连接到数据库。有关如何处理此问题的提示，请参见 <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>。</p>
</section>
<section id="databaseerror">
<span id="error-4xp6"></span><h3>DatabaseError<a class="headerlink" href="#databaseerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库本身相关而不是与传递的接口或数据相关的错误引发的异常。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
</section>
<section id="dataerror">
<span id="error-9h9h"></span><h3>DataError<a class="headerlink" href="#dataerror" title="Permalink to this heading">¶</a></h3>
<p>与处理的数据存在问题（例如除以零，数字值超出范围等）相关的错误引发的异常。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
</section>
<section id="operationalerror">
<span id="error-e3q8"></span><h3>OperationalError<a class="headerlink" href="#operationalerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库操作相关，而不一定受程序员控制的错误引发的异常，例如。出现意外断开连接，未找到数据源名称，无法处理事务，处理过程中发生内存分配错误等。。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
<p>“OperationalError”是由许多驱动程序（但不是唯一的）在上下文中使用了丢失的数据库连接或无法连接到数据库时使用的错误类别。有关如何处理此问题的提示，请参见 <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>。</p>
</section>
<section id="integrityerror">
<span id="error-gkpj"></span><h3>IntegrityError<a class="headerlink" href="#integrityerror" title="Permalink to this heading">¶</a></h3>
<p>与数据库的关系完整性受到影响，例如外键检查失败时引发的异常。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
</section>
<section id="internalerror">
<span id="error-2j85"></span><h3>InternalError<a class="headerlink" href="#internalerror" title="Permalink to this heading">¶</a></h3>
<p>数据库遇到内部错误时引发的异常，例如，光标不再有效，事务不同步等。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
<p>“InternalError”有时由驱动程序在上下文中引发，而数据库连接被放弃，或无法连接到数据库。有关如何处理此问题的提示，请参见 <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>。</p>
</section>
<section id="programmingerror">
<span id="error-f405"></span><h3>ProgrammingError<a class="headerlink" href="#programmingerror" title="Permalink to this heading">¶</a></h3>
<p>与编程错误相关的异常，例如，未找到表或表已存在，SQL语句中的语法错误，指定的参数数量不正确等。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
<p>“ProgrammingError”有时由驱动程序在上下文中引发，而数据库连接被放弃，或无法连接到数据库。有关如何处理此问题的提示，请参见 <a class="reference internal" href="core/pooling.html#pool-disconnects"><span class="std std-ref">处理断开连接</span></a>。</p>
</section>
<section id="notsupportederror">
<span id="error-tw8g"></span><h3>NotSupportedError<a class="headerlink" href="#notsupportederror" title="Permalink to this heading">¶</a></h3>
<p>在使用不支持的方法或数据库API的情况下引发异常，例如，在不支持事务或关闭事务的连接上请求.rollback()。</p>
<p>此错误是一个 <a class="reference internal" href="#error-dbapi"><span class="std std-ref">DBAPI Error</span></a>，起源于数据库驱动程序（DBAPI），而非SQLAlchemy本身。</p>
</section>
</section>
<section id="sql">
<h2>SQL表达式语言<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h2>
<section id="object-will-not-produce-a-cache-key-performance-implications">
<span id="caching-caveats"></span><span id="error-cprf"></span><h3>Object will not produce a cache key, Performance Implications<a class="headerlink" href="#object-will-not-produce-a-cache-key-performance-implications" title="Permalink to this heading">¶</a></h3>
<p>从版本1.4开始，SQLAlchemy包括一个 <a class="reference internal" href="core/connections.html#sql-caching"><span class="std std-ref">SQL compilation caching facility</span></a> ，可以使Core和ORM SQL结构在缓存其字符化形式时，包括用于从语句中检索结果的其他结构信息，允许在下一次使用完全相等结构的构造时跳过相对昂贵的字符串编译过程。该系统依赖于对所有SQL构造实现的功能，包括对象 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>、<a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 和 <a class="reference internal" href="core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>，以产生一个 <strong>缓存密钥</strong> 以完全表示其状态，因为它影响SQL编译过程。</p>
<p>如果这些警告涉及到诸如 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 之类的广泛使用对象，并且显示影响到发出的大多数SQL结构（使用 <a class="reference internal" href="core/connections.html#sql-caching-logging"><span class="std std-ref">使用日志记录估计缓存性能</span></a> 中描述的估计技术），以至于在应用程序中通常不启用缓存，这会对性能产生负面影响，并且在某些情况下，实际上会与先前的SQLAlchemy版本相比产生 <strong>性能降级</strong>。 <a class="reference internal" href="faq/performance.html#faq-new-caching"><span class="std std-ref">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</span></a> 在附加详细信息中涵盖了此内容。</p>
<section id="id4">
<h4>缓存会自行禁用<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<p>缓存依赖于能够生成准确代表语句的完整结构的缓存密钥，这些密钥必须在 <strong>一致</strong> 的方式上符合该语句的结构。如果某个特定的SQL构造（或类型）没有必要的指令，允许它生成适当的缓存密钥，则无法安全地启用缓存。</p>
<ul class="simple">
<li><p>缓存密钥必须表示 <strong>完整的结构</strong>：如果使用两个独立实例的构造可能导致不同的SQL被呈现，则在使用缓存密钥时缓存第一个实例时，使用未能捕获第一个实例和第二个实例之间不同的差异之间的区别的缓存密钥将导致不正确的缓存SQL 字符串和对第二个实例呈现的缓存的使用。</p></li>
<li><p>缓存密钥必须是 <strong>一致的</strong>：例如，如果构造表示每个时间都会更改的状态，例如文字值，则对于该构造重复使用唯一的SQL，这样每个实例都会产生唯一的SQL， 对于相同的SQL结构，只有在实际上进行再次编译所需的数目可能很快填充语句缓存。</p></li>
</ul>
<p>出于上述两个原因，SQLAlchemy的缓存系统在决定是否缓存与特定后端特定的构造相关的SQL时非常“谨慎”。</p>
</section>
<section id="id5">
<h4>缓存引用属性<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<p>警告是根据以下标准发出的。有关每个标准的进一步详细信息，请参见章节 <a class="reference internal" href="faq/performance.html#faq-new-caching"><span class="std std-ref">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</span></a>。</p>
<ul class="simple">
<li><p>本身的 <code class="xref py py-class docutils literal notranslate"><span class="pre">create_engine</span></code> 的URL的第一部分指定的模块）必须表明它已审查并经过测试以正确支持缓存，这由 <a class="reference internal" href="core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache" title="sqlalchemy.engine.Dialect.supports_statement_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Dialect.supports_statement_cache</span></code></a> 属性设置为True表示。当使用第三方方言时，请咨询该方言的维护者，以便他们可以遵循 <a class="reference internal" href="core/connections.html#engine-thirdparty-caching"><span class="std std-ref">steps to ensure caching may be enabled</span></a> 中的步骤，并发布新版本。</p></li>
<li><p>继承自 <a class="reference internal" href="core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> 或 <a class="reference internal" href="core/custom_types.html#sqlalchemy.types.UserDefinedType" title="sqlalchemy.types.UserDefinedType"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedType</span></code></a> 的第三方或用户定义类型必须包括其定义中的 <a class="reference internal" href="core/type_api.html#sqlalchemy.types.ExternalType.cache_ok" title="sqlalchemy.types.ExternalType.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ExternalType.cache_ok</span></code></a> 属性，包括所有衍生子类，遵循 <a class="reference internal" href="core/type_api.html#sqlalchemy.types.ExternalType.cache_ok" title="sqlalchemy.types.ExternalType.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ExternalType.cache_ok</span></code></a> 的文档字符串所描述的准则。与之前一样，如果这些数据类型是从第三方库导入的，请咨询该库的维护者，以便他们可以提供其库的必要更改并发布新版本。</p></li>
<li><p>继承自 <a class="reference internal" href="core/foundation.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a>、 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>、 <a class="reference internal" href="core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a> 等类的第三方或用户定义的SQL构造，包括简单子类以及设计用于与 <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span> 一起使用的构造，应通常包括 <a class="reference internal" href="core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache" title="sqlalchemy.sql.traversals.HasCacheKey.inherit_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HasCacheKey.inherit_cache</span></code></a> 属性， set to True 或 False，根据构造的设计，在 <a class="reference internal" href="core/compiler.html#compilerext-caching"><span class="std std-ref">Enabling Caching Support for Custom Constructs</span></a> 中描述的准则，应包括具有缓存密钥的原始实例的缓存密钥。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="core/connections.html#sql-caching-logging"><span class="std std-ref">使用日志记录估计缓存性能</span></a> - 背景观察缓存行为和效率</p>
<p><a class="reference internal" href="faq/performance.html#faq-new-caching"><span class="std std-ref">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</span></a> - 在 <a class="reference internal" href="faq/index.html"><span class="std std-ref">常见问题解答</span></a> 部分中</p>
</div>
</section>
</section>
<section id="compiler-strsqlcompiler-can-t-render-element-of-type-element-type">
<span id="error-l7de"></span><h3>Compiler StrSQLCompiler can’t render element of type &lt;element type&gt;<a class="headerlink" href="#compiler-strsqlcompiler-can-t-render-element-of-type-element-type" title="Permalink to this heading">¶</a></h3>
<p>在将 SQL 表达式构造串行化出现元素不在默认的编译中时，通常会出现此错误；在这种情况下，将出现对 <a class="reference internal" href="core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler" title="sqlalchemy.sql.compiler.StrSQLCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrSQLCompiler</span></code></a> 类的错误.在不太常见的情况下，当错误类型的SQL表达式与特定类型的数据库后端一起使用时，也会出现该错误；在这些情况下，将命名其他SQL编译器类，例如 <code class="docutils literal notranslate"><span class="pre">SQLCompiler</span></code> 或 <code class="docutils literal notranslate"><span class="pre">sqlalchemy.dialects.postgresql.PGCompiler</span></code>。以下是更特定于“字符化”用例但描述了一般背景的指导方针。</p>
<p>通常，Core SQL构造或ORM <code class="xref py py-class docutils literal notranslate"><span class="pre">Query`对象可以直接串行化，如使用</span> <span class="pre">``print（）`</span></code> 时：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<div class='show_sql_print'><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">x_1</span>
</div></pre></div>
</div>
<p>从上面的SQL表达式字符串是字符串化，使用的是一个 <a class="reference internal" href="core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler" title="sqlalchemy.sql.compiler.StrSQLCompiler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrSQLCompiler</span></code></a> 编译器类，它是一个特殊的语句编译器，当一个构造没有任何特定于方言的信息就被字符串化时被调用。</p>
<p>但是，有许多构造是特定于某个特定类型的数据库方言的，例如 PostgreSQL
“Insert on conflict” construct: ：</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="kn">import</span> <span class="n">insert</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_table</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insert_stmt</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">my_table</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insert_stmt</span> <span class="o">=</span> <span class="n">insert_stmt</span><span class="o">.</span><span class="n">on_conflict_do_nothing</span><span class="p">(</span><span class="n">index_elements</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">insert_stmt</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span></pre></div>
</div>
<p>…</p>
<p>sqlalchemy.exc.UnsupportedCompilationError:
Compiler &lt;sqlalchemy.sql.compiler.StrSQLCompiler object at 0x7f04fc17e320&gt;
can’t render element of type
&lt;class ‘sqlalchemy.dialects.postgresql.dml.OnConflictDoNothing’&gt;</p>
</div></blockquote>
<p>为了将特定于某个特定的后端的构造串行化，必须使用 <a class="reference internal" href="core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile" title="sqlalchemy.sql.expression.ClauseElement.compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.compile()</span></code></a> 方法，传递 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 或 <a class="reference internal" href="core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> 对象以调用正确的编译器。在以下示例中，我们使用了PostgreSQL方言：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">insert_stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">CONFLICT</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">DO</span><span class="w"> </span><span class="k">NOTHING</span>
</div></pre></div>
</div>
<p>对于ORM <code class="xref py py-class docutils literal notranslate"><span class="pre">statement</span></code> 的方式获得：</p>
<blockquote>
<div><p>statement = query.statement
print(statement.compile(dialect=postgresql.dialect()))</p>
</div></blockquote>
<p>有关有关直接字符串化/编译SQL元素的额外详细信息，请参见FAQ链接。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="faq/sqlexpressions.html#faq-sql-expression-string"><span class="std std-ref">如何将SQL表达式呈现为字符串，可能带有联接的参数？</span></a></p>
</div>
</section>
<section id="typeerror-columnproperty-something">
<h3>TypeError: &lt;操作符&gt;不支持在“ColumnProperty”实例和&lt;something&gt;之间的实例<a class="headerlink" href="#typeerror-columnproperty-something" title="Permalink to this heading">¶</a></h3>
<p>通常情况下，当尝试在SQL表达式上下文中使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code> 或 <a class="reference internal" href="orm/queryguide/columns.html#sqlalchemy.orm.deferred" title="sqlalchemy.orm.deferred"><code class="xref py py-func docutils literal notranslate"><span class="pre">deferred()</span></code></a> 对象时，通常在声明性中出现此错误，例如：</p>
<blockquote>
<div><dl>
<dt>class Bar(Base):</dt><dd><p>__tablename__ = “bar”</p>
<p>id = Column(Integer, primary_key=True)
cprop = deferred(Column(Integer))</p>
<p>__table_args__ = (CheckConstraint(cprop &gt; 5),)</p>
</dd>
</dl>
</div></blockquote>
<p>上面的“cprop”属性在映射之前在行内使用，但是该“cprop”属性不是 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>，它是一个 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.ColumnProperty" title="sqlalchemy.orm.ColumnProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnProperty</span></code></a>，即一个中间对象，因此没有 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象或 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a> 对象的全部功能映射到完成时将映射到“Bar”类。虽然 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.ColumnProperty" title="sqlalchemy.orm.ColumnProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnProperty</span></code></a> 确实有 <code class="docutils literal notranslate"><span class="pre">__clause_element</span> <span class="pre">__()</span></code> 方法，允许它在一些以列为导向的上下文中工作，但是在上面所示的开放式比较上下文中是无法工作的，因为它没有 Python 的 <code class="docutils literal notranslate"><span class="pre">__eq</span> <span class="pre">__（）</span></code> 方法，允许它将与数字“5”的比较解释为SQL表达式而不是正常的Python比较。</p>
<p>解决方案是直接使用属性 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.ColumnProperty.expression" title="sqlalchemy.orm.ColumnProperty.expression"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ColumnProperty.expression</span></code></a> 访问 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  ：</p>
<blockquote>
<div><dl>
<dt>class Bar(Base):</dt><dd><p>__tablename__ = “bar”</p>
<p>id = Column(Integer, primary_key=True)
cprop = deferred(Column(Integer))</p>
<p>__table_args__ = (CheckConstraint(cprop.expression &gt; 5),)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="x-y">
<span id="error-cd3x"></span><h3>在继续之前，必须为绑定参数 &lt;x&gt; 在参数组 &lt;y&gt; 中提供值<a class="headerlink" href="#x-y" title="Permalink to this heading">¶</a></h3>
<p>在执行语句时，如果对 <a class="reference internal" href="core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> 利用隐式或显式并没有提供值，则会出现此错误:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;my_param&quot;</span><span class="p">))</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<p>以上示例中，为“my_param”提供了参数值。因此，正确的方法是：</p>
<blockquote>
<div><p>result = conn.execute(stmt, my_param=12)</p>
</div></blockquote>
<p>当消息采用“在参数组&lt;paramgrp&gt;中的绑定参数&lt;parammsg&gt;需要值”的形式时，消息指的是执行“executemany”格式时。在这种情况下，语句通常是 INSERT、UPDATE 或 DELETE，并且传递了参数列表。在这种格式下，语句可以根据第一个参数集来动态生成，以包括参数列表中的所有参数位置，其中将使用第一组参数来确定这些应该是什么。</p>
<p>例如，下面的语句是基于第一个参数集计算的，要求参数“a”、“b”和“c”-这些名称确定了最终的字符串格式，该字符串格式将用于列表中的每个参数集。由于第二个实体未包含“b”，因此会生成此错误：</p>
<blockquote>
<div><blockquote>
<div><p>m = MetaData()
t = Table(“t”, m, Column(“a”, Integer), Column(“b”, Integer), Column(“c”, Integer))</p>
<dl>
<dt>e.execute(</dt><dd><p>t.insert(),
[</p>
<blockquote>
<div><p>{“a”: 1, “b”: 2, “c”: 3},
{“a”: 2, “c”: 4},
{“a”: 3, “b”: 4, “c”: 5},</p>
</div></blockquote>
<p>],</p>
</dd>
</dl>
<p>).. code-block:</p>
</div></blockquote>
<p>sqlalchemy.exc.StatementError: (sqlalchemy.exc.InvalidRequestError)
参数分组1中的bind参数 ‘b’ 需要值
[SQL: u’INSERT INTO t (a, b, c) VALUES (?, ?, ?)’]
[parameters: [{‘a’: 1, ‘c’: 3, ‘b’: 2}, {‘a’: 2, ‘c’: 4}, {‘a’: 3, ‘c’: 5, ‘b’: 4}]]</p>
</div></blockquote>
<p>由于”b”参数是必需的，因此将其传递为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 可以让 INSERT 继续执行:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span>
    <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="p">],</span>
<span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="tutorial/dbapi_transactions.html#tutorial-sending-parameters"><span class="std std-ref">发送参数</span></a></p>
</div>
</section>
<section id="from-select-from-subquery">
<span id="error-89ve"></span><h3>预期 FROM 子句，得到 Select。要创建 FROM 子句，请使用 .subquery() 方法<a class="headerlink" href="#from-select-from-subquery" title="Permalink to this heading">¶</a></h3>
<p>这是SQLAlchemy 1.4中引入的一项更改，其中由诸如 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 生成的 SELECT 语句，以及包括联合和文本 SELECT 表达式等内容在内的其他内容 不再被认为是 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> 对象，并且不能直接放置在另一个 SELECT 语句的 FROM 子句中，必须首先将其包装在 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 中。这是核心中的一个关键概念变化，详细的解释可以在 <a class="reference internal" href="changelog/migration_14.html#change-4617"><span class="std std-ref">不再将 SELECT 语句隐式视为 FROM 子句</span></a> 中找到。</p>
<p>如下面的示例：</p>
<blockquote>
<div><p>m = MetaData()
t = Table(“t”, m, Column(“a”, Integer), Column(“b”, Integer), Column(“c”, Integer))
stmt = select(t)</p>
</div></blockquote>
<p>在上面的代码中， stmt 表示一个 SELECT 语句。当我们想要直接使用 stmt 在另一个 SELECT 语句的 FROM 子句中时，例如在以下代码中：</p>
<blockquote>
<div><p>new_stmt_1 = select(stmt)</p>
</div></blockquote>
<p>或者，如果我们想要在 FROM 子句中使用它，例如在 JOIN 中：</p>
<blockquote>
<div><p>new_stmt_2 = select(some_table).select_from(some_table.join(stmt))</p>
</div></blockquote>
<p>则会产生上面的错误。在之前的 SQLAlchemy 版本中，在另一个 SELECT 内部使用 SELECT 将生成无名称子查询，用括号括起来。在大多数情况下，这种形式的 SQL 不是很有用，因为诸如 MySQL 和 PostgreSQL 之类的数据库要求 FROM 子句中的子查询具有命名别名，这意味着使用 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias" title="sqlalchemy.sql.expression.SelectBase.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.alias()</span></code></a> 方法或如 1.4 版本中所使用的 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> 方法来生成这一别名。在其他数据库上，使子查询具有名称以消除子查询内对列名称的未来引用带来了明显的优势。</p>
<p>除了上面的实际原因之外，这种变化还有许多其他针对 SQLAlchemy 的原因。因此，以上两条语句的正确形式需要使用 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> ：</p>
<blockquote>
<div><p>subq = stmt.subquery()</p>
<p>new_stmt_1 = select(subq)</p>
<p>new_stmt_2 = select(some_table).select_from(some_table.join(subq))</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="changelog/migration_14.html#change-4617"><span class="std std-ref">不再将 SELECT 语句隐式视为 FROM 子句</span></a></p>
</div>
</section>
<section id="clauseelement">
<span id="error-xaj1"></span><h3>自动为原始 clauseelement 生成别名<a class="headerlink" href="#clauseelement" title="Permalink to this heading">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.26.</span></p>
</div>
<p>此警告绑定到使用 <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> 方法的旧风格或 <span class="xref std std-term">2.0 风格`的 :meth:`_sql.Select.join</span> 方法以及使用连接表继承的映射时解析。问题在于，在两个连接到共享基表的连接继承模型之间进行连接时，如果没有应用到其中一个操作对象的别名，将无法形成适当的 SQL JOIN；SQLAlchemy 在这种情况下对右侧加别名。例如，考虑以下连接继承映射：</p>
<blockquote>
<div><dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id = Column(Integer, primary_key=True)
manager_id = Column(ForeignKey(“manager.id”))
name = Column(String(50))
type = Column(String(50))</p>
<p>reports_to = relationship(“Manager”, foreign_keys=manager_id)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: type,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id = Column(Integer, ForeignKey(“employee.id”), primary_key=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,
“inherit_condition”: id == Employee.id,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>上面的映射包括 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 之间的关系。由于这两个类都使用 “employee” 数据库表，因此从 SQL 的角度来看这是一个 <a class="reference internal" href="orm/self_referential.html#self-referential"><span class="std std-ref">自引用关系</span></a> 。如果我们想要使用连接从 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 模型中查询，并在 SQL 中表示上述操作，不得不如下面的 ORM 这样写：</p>
<blockquote>
<div><p>s = Session()
stmt = select(Employee, Manager).join(Employee.reports_to)</p>
</div></blockquote>
<p>上面的 SQL 语句选择了 “employee” 表作为查询的起点，表示查询对象为 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> ，接着连接到了一个右嵌套连接，其详细描述为 <code class="docutils literal notranslate"><span class="pre">employee</span> <span class="pre">AS</span> <span class="pre">employee_1</span> <span class="pre">JOIN</span> <span class="pre">manager</span> <span class="pre">AS</span> <span class="pre">manager_1</span></code>，这个表明 rawclause 的右侧是一个未命名的别名 access 语法为employee_1。这就是上述SQLAlchemy 的警告消息提示automotatically generated alias。</p>
<p>当 SQLAlchemy 加载 ORM 行时，每个 ORM 行包含一个 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 和一个 <code class="docutils literal notranslate"><span class="pre">Manager</span></code>，ORM 必须调整从 <code class="docutils literal notranslate"><span class="pre">employee_1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">manager_1</span></code> 表别名游标中的行，使它们适配到未用别名的 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 类中。这个过程是内部复杂的，并且不提供所有 API 特性，尤其是在尝试使用比这里所示的更深层的查询时，如 <code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code> 呈现的预加载特性。由于这种设计不可靠且涉及难以预测并且难以遵循的隐式决策，因此会发出警告，此模式可视为遗留特性。编写此查询的更好方法是使用与任何其他自引用关系相同的模式，即使用 <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 构造，对于连接继承和其他以连接为导向的映射，则通常最好添加使用 <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat" title="sqlalchemy.orm.aliased"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">aliased.flat</span></code></a> 参数，以允许通过在连接内的各个表上应用别名来为两个或更多表的关联指定别名，而不是将连接嵌入到新的子查询中：</p>
<blockquote>
<div><p>from sqlalchemy.orm import aliased</p>
<p>a1 = aliased(Address)</p>
<p># of_type() form; recommended
q = (</p>
<blockquote>
<div><p>s.query(User)
.join(User.addresses.of_type(a1))
.filter(a1.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)</p>
</div></blockquote>
<p>)</p>
<p># target, onclause form
q = s.query(User).join(a1, User.addresses).filter(a1.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)</p>
</div></blockquote>
</section>
<section id="error-xaj2">
<span id="id6"></span><h3>由于重叠的表而自动生成别名<a class="headerlink" href="#error-xaj2" title="Permalink to this heading">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.26.</span></p>
</div>
<p>该警告通常在使用 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 方法或遗留的 <a class="reference internal" href="orm/queryguide/query.html#sqlalchemy.orm.Query.join" title="sqlalchemy.orm.Query.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.join()</span></code></a> 方法查询映射时生成，其中涉及加入表的继承。当在两个连接继承模型之间进行joining时，因为存在共同的基表，所以不能形成 SQL JOIN 来连接这两个实体，而不使用实现别名操作；在这种情况下，SQLAlchemy 将别名加右边的对齐。例如，给定如下连接继承映射：</p>
<blockquote>
<div><dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id = Column(Integer, primary_key=True)
manager_id = Column(ForeignKey(“manager.id”))
name = Column(String(50))
type = Column(String(50))</p>
<p>reports_to = relationship(“Manager”, foreign_keys=manager_id)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: type,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id = Column(Integer, ForeignKey(“employee.id”), primary_key=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,
“inherit_condition”: id == Employee.id,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>上述映射包括 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 之间的关系。由于两个类都使用 “employee” 数据库表，因此从 SQL 的角度来看这是一个 <a class="reference internal" href="orm/self_referential.html#self-referential"><span class="std std-ref">自引用关系</span></a> 。如果我们想要使用连接从 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 模型中查询，并在 SQL 中表示上述操作，我们得到的 SQL 将类似于以下 SQL：</p>
<blockquote>
<div><p>SELECT employee.id, employee.manager_id, employee.name,
employee.type, manager_1.id AS id_1, employee_1.id AS id_2,
employee_1.manager_id AS manager_id_1, employee_1.name AS name_1,
employee_1.type AS type_1
FROM employee JOIN
(employee AS employee_1 JOIN manager AS manager_1 ON manager_1.id = employee_1.id)
ON manager_1.id = employee.manager_id</p>
</div></blockquote>
<p>上述 SQL 语句从 “employee” 表开始查询，表示查询对象为 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> ，接着连接到一个右嵌套连接，其详细描述为 <code class="docutils literal notranslate"><span class="pre">employee</span> <span class="pre">AS</span> <span class="pre">employee_1</span> <span class="pre">JOIN</span> <span class="pre">manager</span> <span class="pre">AS</span> <span class="pre">manager_1</span></code>，这个表明 leftclause 的左侧是呈现为无名称子查询的左嵌套 join 语句。这就是上述SQLAlchemy 的警告消息提示automatically generated alias。</p>
<p>当 SQLAlchemy 加载 ORM 行时，每个 ORM 行包含一个 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 和一个 <code class="docutils literal notranslate"><span class="pre">Manager</span></code>，ORM 必须调整 <code class="docutils literal notranslate"><span class="pre">employee_1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">manager_1</span></code> 表别名游标中的行，使它们适配到没有别名的 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 类中。这个过程是内部复杂的，并且不提供所有 API 特性，特别是在尝试使用比此处所示更深度的查询时，仍会发生错误。由于这种设计不可靠且包含不易预测和不易跟踪的隐式决策，因此发出警告，并认为此模式可能是遗留特性。编写此查询的更好方法是使用与任何其他自引用关系相同的模式，即使用 <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 构造，对于连接继承和其他以连接为导向的映射，则通常最好添加使用 <a class="reference internal" href="orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat" title="sqlalchemy.orm.aliased"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">aliased.flat</span></code></a> 参数，以允许通过在连接内的各个表上应用别名来为两个或更多表的关联指定别名，而不是将连接嵌入到新的子查询中：</p>
<blockquote>
<div><p>from sqlalchemy.orm import aliased</p>
<p>a1 = aliased(Address)</p>
<p># of_type() form; recommended
q = (</p>
<blockquote>
<div><p>s.query(User)
.join(User.addresses.of_type(a1))
.filter(a1.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)</p>
</div></blockquote>
<p>)</p>
<p># target, onclause form
q = s.query(User).join(a1, User.addresses).filter(a1.email_address == “<a class="reference external" href="mailto:ed&#37;&#52;&#48;foo&#46;com">ed<span>&#64;</span>foo<span>&#46;</span>com</a>”)</p>
</div></blockquote>
</section>
<section id="xqp-y">
<span id="error-qzyx"></span><h3>关系X将把列Q复制到列P，这与关系相冲突：’Y’<a class="headerlink" href="#xqp-y" title="Permalink to this heading">¶</a></h3>
<p>此警告是指当两个或多个关系将数据写入刷新操作的相同的列时，但 ORM 没有任何手段来协调这些关系时。根据具体情况，解决方法可能是需要两个关系之间相互引用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code>，或者一个或多个，该警告是不可避免的 SQLAlchemy捕获到可能导致数据丢失或不正确的连接关系。</p>
<p>relationships 应该配置为:paramref:<cite>_orm.relationship.viewonly</cite> ，以避免冲突写入，或者有时配置完全是有意的，并且应该将:paramref:<cite>_orm.relationship.overlaps</cite> 配置为静音每个警告。</p>
<p>对于缺少 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code> 的典型示例，给出以下映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述映射将会生成警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: relationship &#39;Child.parent&#39; will copy column parent.id to column child.parent_id,
which conflicts with relationship(s): &#39;Parent.children&#39; (copies parent.id to child.parent_id).</pre></div>
</div>
<p>关系 <code class="docutils literal notranslate"><span class="pre">Child.parent</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 看起来处于冲突状态。解决方案是应用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Parent&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;children&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>对于更加自定义化的关系，如果”overlap” 情况是有意的且无法解决，则:paramref:<cite>_orm.relationship.overlaps</cite> 参数可以指定不应发出警告的关系的名称。这通常发生在与包括自定义 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.primaryjoin</span></code> 条件的某个基础表的两个或多个关系相关的情况下，以限制每种情况下的相关项:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Child&quot;</span><span class="p">,</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(Parent.id == Child.parent_id, Child.flag == 0)&quot;</span><span class="p">,</span>
        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="n">overlaps</span><span class="o">=</span><span class="s2">&quot;c2, parent&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Child&quot;</span><span class="p">,</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(Parent.id == Child.parent_id, Child.flag == 1)&quot;</span><span class="p">,</span>
        <span class="n">overlaps</span><span class="o">=</span><span class="s2">&quot;c1, parent&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;parent.id&quot;</span><span class="p">))</span>

    <span class="n">flag</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述 ORM 将知道 <code class="docutils literal notranslate"><span class="pre">Parent.c1</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Parent.c2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Child.parent</span></code> 之间的重叠是有意的。</p>
</section>
<section id="persistent">
<span id="error-lkrp"></span><h3>无法将对象转换为 “persistent” 状态，因为此标识图不再有效。<a class="headerlink" href="#persistent" title="Permalink to this heading">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.26.</span></p>
</div>
<p>此消息添加是为了处理在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 已关闭或已调用其 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expunge_all()</span></code> 方法的之后，仍然迭代 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 对象而导致的错误。当 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 一次性清除所有对象时，由该 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 使用的内部 <span class="xref std std-term">identity map</span> 将被替换为新的，并且丢弃原始的 identity map。一个未使用且未缓冲的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 对象在内部将保留对该现在已弃用的 identity map 的引用。因此，当消耗 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 时，将产生错误。</p>
<p><a class="reference internal" href="orm/extensions/asyncio.html"><span class="std std-ref">2.0 AsyncIO 扩展</span></a> 的情况通常不会出现此类情况，因为当 <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession" title="sqlalchemy.ext.asyncio.AsyncSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncSession</span></code></a> 返回一个传统的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 时，当执行语句时，结果已预先缓冲。这是为了在无需额外的`` await`` 调用的情况下启用次要的急切装入程序。</p>
<p>要在使用普通的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 的情况下以与 <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> 扩展类似的方式预缓冲结果，可以使用 <code class="docutils literal notranslate"><span class="pre">prebuffer_rows</span></code> 执行选项，如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># context manager creates new Session</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session_obj</span><span class="p">:</span>
    <span class="c1"># result internally pre-fetches all objects</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">),</span> <span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;prebuffer_rows&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">)</span>

<span class="c1"># context manager is closed, so session_obj above is closed, identity</span>
<span class="c1"># map is replaced</span>

<span class="c1"># pre-buffered objects are returned</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># however they are detached from the session, which has been closed</span>
<span class="k">assert</span> <span class="n">inspect</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">detached</span>
<span class="k">assert</span> <span class="n">inspect</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="kc">None</span></pre></div>
</div>
<p>此处，所选的 ORM 对象完全是在 <code class="docutils literal notranslate"><span class="pre">session_obj</span></code> 块内生成的，与 <code class="docutils literal notranslate"><span class="pre">session_obj</span></code> 关联并在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 对象中缓冲。在块外，<code class="docutils literal notranslate"><span class="pre">session_obj</span></code> 已关闭并清除了这些 ORM 对象。迭代 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 对象将产生那些 ORM 对象，但是由于其中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 已将其清除，因此它们将在 :term:<a href="#id7"><span class="problematic" id="id8">`</span></a>分离`(detached) 状态下返回。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>上述对 “预缓冲” vs. “未缓冲” <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 对象的提及是指 ORM 将从 <span class="xref std std-term">DBAPI</span> 中的完整的原始值转换为 ORM 对象的过程。它并不意味着底层的 <code class="docutils literal notranslate"><span class="pre">游标</span></code> 对象本身，该对象表示来自 DBAPI 的预处理结果，是缓冲或未缓冲的，因为这本质上是缓冲的较低层。关于缓冲 <code class="docutils literal notranslate"><span class="pre">游标</span></code> 结果本身的背景，请参阅 <span class="xref std std-ref">engine_stream_results</span> 节。</p>
</div>
</section>
<section id="annotated-declarative-table">
<span id="error-zlpr"></span><h3>无法解释 Annotated Declarative Table 形式的注释类型<a class="headerlink" href="#annotated-declarative-table" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 2.0 引入了一种新的 <a class="reference internal" href="orm/declarative_tables.html#orm-declarative-mapped-column"><span class="std std-ref">Annotated Declarative Table</span></a> 声明系统，该系统在运行时从类定义中的 <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 注释中派生 ORM 映射的属性信息。 此形式的要求是所有 ORM 注释必须使用名为 <a class="reference internal" href="orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 的通用容器来进行正确注释。 使用显式 <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 类型注释的旧版 SQLAlchemy 映射（例如，那些使用 <a class="reference internal" href="orm/extensions/mypy.html"><span class="std std-ref">legacy Mypy 扩展</span></a> 提供类型支持的映射）可能会包括不包括该泛型的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 指令等指令。</p>
<p>要解决此问题，类可以标记为 <code class="docutils literal notranslate"><span class="pre">__allow_unmapped__</span></code> 布尔属性，直到它们可以完全迁移到 2.0 语法。请参见 <span class="xref std std-ref">migration_20_step_six</span> 中的迁移说明的示例。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">migration_20_step_six</span> - 在 <a class="reference internal" href="changelog/migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - 主要迁移指南</span></a> 文档中</p>
</div>
</section>
<section id="cls-cls">
<span id="error-dcmx"></span><h3>将 &lt;cls&gt; 转换为数据类时出错，其中一个或多个属性来自于不是数据类的超类 &lt;cls&gt;。<a class="headerlink" href="#cls-cls" title="Permalink to this heading">¶</a></h3>
<p>此警告在使用 SQLAlchemy ORM Mapped Dataclasses 功能 (<a class="reference internal" href="orm/dataclasses.html#orm-declarative-native-dataclasses"><span class="std std-ref">声明性数据类映射</span></a>) 与任何混合类或抽象基本类一起使用时触发，这些混合类或抽象基本类本身没有声明为数据类。例如以下示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">MappedAsDataclass</span>


<span class="k">class</span> <span class="nc">Mixin</span><span class="p">:</span>
    <span class="n">create_user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">()</span>
    <span class="n">update_user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">,</span> <span class="n">MappedAsDataclass</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="n">Mixin</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;sys_user&quot;</span>

    <span class="n">uid</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span>
        <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default_factory</span><span class="o">=</span><span class="n">uuid4</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">username</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">()</span>
    <span class="n">email</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">()</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>上述示例中，由于 <code class="docutils literal notranslate"><span class="pre">Mixin</span></code> 本身没有扩展 <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedAsDataclass</span></code>，因此将生成以下警告：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SADeprecationWarning: When transforming &lt;class &#39;__main__.User&#39;&gt; to a
dataclass, attribute(s) &quot;create_user&quot;, &quot;update_user&quot; originates from
superclass &lt;class
&#39;__main__.Mixin&#39;&gt;, which is not a dataclass. This usage is deprecated and
will raise an error in SQLAlchemy 2.1. When declaring SQLAlchemy
Declarative Dataclasses, ensure that all mixin classes and other
superclasses which include attributes are also a subclass of
MappedAsDataclass.</pre></div>
</div>
<p>解决方法是将 <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedAsDataclass</span></code> 添加到 <code class="docutils literal notranslate"><span class="pre">Mixin</span></code> 签名中:</p>
<blockquote>
<div><dl class="simple">
<dt>class Mixin(MappedAsDataclass):</dt><dd><p>create_user: Mapped[int] = mapped_column()
update_user: Mapped[Optional[int]] = mapped_column(default=None, init=False)</p>
</dd>
</dl>
</div></blockquote>
<p>Python 的 <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a> 规范不支持在数据类的超类中声明的属性，这些属性本身不是数据类; 根据 Python 数据类的行为，这些字段被忽略，如以下示例:</p>
<blockquote>
<div><p>from dataclasses import dataclass
from dataclasses import field
import inspect
from typing import Optional
from uuid import uuid4</p>
<dl class="simple">
<dt>class Mixin:</dt><dd><p>create_user: int
update_user: Optional[int] = field(default=None)</p>
</dd>
</dl>
<p>&#64;dataclass
class User(Mixin):</p>
<blockquote>
<div><p>uid: str = field(init=False, default_factory=lambda: str(uuid4()))
username: str
password: str
email: str</p>
</div></blockquote>
</div></blockquote>
<p>以上， <code class="docutils literal notranslate"><span class="pre">User</span></code> 类将不包括 <code class="docutils literal notranslate"><span class="pre">create_user</span></code> 在其构造函数中，也不会尝试将 <code class="docutils literal notranslate"><span class="pre">update_user</span></code> 解释为数据类属性。这是因为 <code class="docutils literal notranslate"><span class="pre">Mixin</span></code> 不是一个数据类。</p>
<p>SQLAlchemy 2.0 中的 ORM 数据类功能在正确处理上述情况方面未能正确处理; 相反，非数据类混合和超类上的属性被视为数据类配置的一部分。但是，像 Pyright 和 Mypy 这样的类型检查器将不考虑这些字段作为数据类构造函数的一部分，因为根据 <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>，应该忽略这些字段。由于它们的存在具有歧义，因此 SQLAlchemy 2.1 将需要使数据类层次结构中包括 SQLAlchemy 映射属性的混合类自身也成为数据类。</p>
</section>
<section id="orm">
<span id="error-bupq"></span><h3>对于每个主键，按行 ORM 群集更新需要记录包含主键值<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h3>
<p>如果在给定记录中未提供主键值，则此错误在使用 <span class="xref std std-ref">orm_queryguide_bulk_update</span> 功能是会发生的，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;u_name&quot;</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;patrick&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Patrick Star&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>上述代码中，由于具有参数字典列表和使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 执行启用了 ORM 批量更新主键，因此必须在每个参数字典中包括主键值，即:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Patrick Star&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Eugene H. Krabs&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>通过调用 <code class="docutils literal notranslate"><span class="pre">session.connection()</span></code> 获得当前 <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code> , 然后用它来执行语句:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">update</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;u_name&quot;</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;u_name&quot;</span><span class="p">:</span> <span class="s2">&quot;patrick&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;Patrick Star&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">orm_queryguide_bulk_update</span></p>
<p><span class="xref std std-ref">orm_queryguide_bulk_update_disabling</span></p>
</div>
</section>
</section>
<section id="io">
<h2>异步 IO 异常<a class="headerlink" href="#io" title="Permalink to this heading">¶</a></h2>
<section id="awaitrequired">
<span id="error-xd1r"></span><h3>AwaitRequired<a class="headerlink" href="#awaitrequired" title="Permalink to this heading">¶</a></h3>
<p>要使用异步模式连接数据库，需要使用异步驱动程序。当尝试使用与 <span class="xref std std-term">DBAPI</span> 不兼容的要使用异步版本的 SQLAlchemy 时，通常会引发此错误。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/extensions/asyncio.html"><span class="std std-ref">异步 I/O (asyncio)</span></a></p>
</div>
</section>
<section id="missinggreenlet">
<span id="error-xd2s"></span><h3>MissingGreenlet<a class="headerlink" href="#missinggreenlet" title="Permalink to this heading">¶</a></h3>
<p>当在意料之外的位置启动 IO 尝试时，使用不直接提供 <code class="docutils literal notranslate"><span class="pre">await</span></code> 关键字的调用模式，就会触发此错误。当使用 ORM 时，这通常是由于使用 <span class="xref std std-term">lazy loading</span> 引起的，因为其在 asyncio 下无法直接支持，而是需要进行其他步骤和/或更改加载程序的模式。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads"><span class="std std-ref">在使用 AsyncSession 时避免隐式 I/O</span></a> - 涵盖了大多数 ORM 场景，以及如何减轻这种问题，包括用于延迟加载场景的特定模式。</p>
</div>
</section>
<section id="no-inspection-available">
<span id="error-xd3s"></span><h3>No Inspection Available<a class="headerlink" href="#no-inspection-available" title="Permalink to this heading">¶</a></h3>
<p>在 <code class="xref py py-class docutils literal notranslate"><span class="pre">_asyxncio.AsyncConnection</span></code> 或 <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine" title="sqlalchemy.ext.asyncio.AsyncEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncEngine</span></code></a> 对象上直接使用 <a class="reference internal" href="core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> 函数时，暂未提供可等待的 <a class="reference internal" href="core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a> 对象。因此，应在使用 <a class="reference internal" href="core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> 时以方式引用 <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection" title="sqlalchemy.ext.asyncio.AsyncConnection.sync_connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sync_connection</span></code></a> 属性，以便最初引用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code> 对象；然后使用 <a class="reference internal" href="orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync" title="sqlalchemy.ext.asyncio.AsyncConnection.run_sync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AsyncConnection.run_sync()</span></code></a> 方法以及执行所需操作的自定义函数以使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code>，类似于以 “同步” 调用方式的用法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">async_main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="k">await</span> <span class="n">conn</span><span class="o">.</span><span class="n">run_sync</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">sync_conn</span><span class="p">:</span> <span class="n">inspect</span><span class="p">(</span><span class="n">sync_conn</span><span class="p">)</span><span class="o">.</span><span class="n">get_table_names</span><span class="p">()</span>
        <span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orm/extensions/asyncio.html#asyncio-inspector"><span class="std std-ref">使用 Inspector 检查模式对象</span></a> - 有关在 asyncio 扩展中使用 <a class="reference internal" href="core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> 的其他示例。</p>
</div>
</section>
</section>
<section id="id9">
<h2>核心异常类<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>有关核心异常类，请参见 <span class="xref std std-ref">core_exceptions_toplevel</span>。</p>
</section>
<section id="id10">
<h2>ORM 异常类<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<p>有关 ORM 异常类，请参见 <a class="reference internal" href="orm/exceptions.html"><span class="std std-ref">ORM 异常</span></a>。</p>
</section>
<section id="id11">
<h2>历史遗留问题<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h2>
<p>此部分中的异常不由当前 SQLAlchemy 版本生成，但是在此处提供以配合异常消息超链接。</p>
<section id="sqlalchemy-2-0">
<span id="error-b8d9"></span><h3>在 SQLAlchemy 2.0 中，&lt;某些函数&gt; 将不再 &lt;做某事&gt;<a class="headerlink" href="#sqlalchemy-2-0" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 2.0 对于 Core 和 ORM 组件的许多重要 SQLAlchemy 使用模式进行了重大调整。 2.0 发布的目标是对 SQLAlchemy 自从起初开始以来的一些最基本的假设进行微调，并提供一个新的经过简化的使用模型，其目的是显着更加简约，Consistent between the Core and ORM components, as 兼容性更强。</p>
<p>在退化至 <span class="xref std std-ref">migration_20_ttl</span> 中介绍的 DSL 合规性等问题上，SQLAlchemy 2.0 项目包括一个完整的将来的兼容性系统，该系统集成到 SQLAlchemy 1.4 系列中，以便应用程序可以具有明确的，明确的，并逐渐的向 2.0 兼容迁移应用程序的过程。  <code class="xref py py-class docutils literal notranslate"><span class="pre">RemovedIn20Warning</span></code> 废弃警告是这个系统的基础，可提供有关需要修改的现有代码库中的行为的指导。可以在 <a class="reference internal" href="changelog/migration_14.html#deprecation-20-mode"><span class="std std-ref">SQLAlchemy 2.0 退化模式</span></a> 上查看有关如何启用此警告的概述。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">migration_20_ttl</span> - 从 1.x 系列开始的升级过程概述，以及实现全面 2.0 兼容性的当前目标和进度。</p>
<p><a class="reference internal" href="changelog/migration_14.html#deprecation-20-mode"><span class="std std-ref">SQLAlchemy 2.0 退化模式</span></a> - 有关如何在 SQLAlchemy 1.4 中使用 “2.0 废除模式” 的特定指南。</p>
</div>
</section>
<section id="backref-session">
<span id="error-s9r1"></span><h3>对象正在通过 backref 级联合并到 Session 中<a class="headerlink" href="#backref-session" title="Permalink to this heading">¶</a></h3>
<p>此消息是指 SQLAlchemy 的 “backref cascade” 行为，在版本 2.0 中已删除。 这指的是将一个对象添加到 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 中，作为与它已经存在于该会话中的其他对象关联的结果。由于此行为已被证明比有用更具有混淆性，因此添加了 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade_backrefs</span></code> 和 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">backref.cascade_backrefs</span></code> 参数，可将其设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 以禁用该行为，在 SQLAlchemy 2.0 中，“backref cascade”行为已完全删除。</p>
<p>对于以前的 SQLAlchemy 版本，要在具有 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.backref</span></code> 字符串参数的 backref 上将 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.cascade_backrefs</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，必须首先使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">backref()</span></code> 函数声明 backref，以便可以通过 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">backref.cascade_backrefs</span></code> 参数进行传递。</p>
<p>或者，可以使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 上的 “future” 模式完全关闭“backref cascade”行为，即通过 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.future</span></code> 参数传递 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="changelog/migration_14.html#change-5150"><span class="std std-ref">级联反向引用在2.0中被弃用以移除</span></a> - SQLAlchemy 2.0 中的变更背景。</p>
</div>
</section>
<section id="legacy-select">
<span id="error-c9ae"></span><h3>在 “legacy” 模式下创建的 select() 构造; 关键字参数等。<a class="headerlink" href="#legacy-select" title="Permalink to this heading">¶</a></h3>
<p>截至SQLAlchemy 1.4，已更新 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造，使其支持标准 SQLAlchemy 2.0 中的新调用样式。在 1.4 系列内向后兼容，该构造接受旧式“遗留”样式作为参数，以及新样式。</p>
<p>“新” 样式的特点是列和表达式仅以位置传递到 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造，任何其他修改对象的修饰符都必须使用后续的方法链接传递:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这是正式的样子</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span> <span class="o">==</span> <span class="n">table2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">otherid</span><span class="p">)</span></pre></div>
</div>
<p>相比之下，在 SQLAlchemy 的旧式形式中，在添加类似 <a class="reference internal" href="core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> 等方法之前，语句将是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这是由原始的 SQLAlchemy 版本文档记录的方式</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span><span class="p">],</span> <span class="n">whereclause</span><span class="o">=</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span> <span class="o">==</span> <span class="n">table2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">otherid</span><span class="p">)</span></pre></div>
</div>
<p>甚至可能是将 “whereclause” 作为位置参数传递:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这也是由原始的 SQLAlchemy 版本文档记录的方式</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span><span class="p">],</span> <span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span> <span class="o">==</span> <span class="n">table2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">otherid</span><span class="p">)</span></pre></div>
</div>
<p>多年来，已删除大多数叙述文档中包括任何其他参数（例如 “whereclause”）的指导，导致传递作为列表的列参数，但没有其他参数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这是从 1.0 或左右版本以来的文档中记录的方式</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">myid</span> <span class="o">==</span> <span class="n">table2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">otherid</span><span class="p">)</span></pre></div>
</div>
<p>在 <span class="xref std std-ref">migration_20_5284</span> 文档中描述了此更改的信息，涉及到 DSL 合规性问题。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">migration_20_5284</span></p>
<p><span class="xref std std-ref">migration_20_ttl</span></p>
</div>
</section>
<section id="legacy-future-true">
<span id="error-c9bf"></span><h3>找到使用的是 legacy 绑定元数据绑定，但由于在此会话中设置了 future=True，因此将忽略该绑定。<a class="headerlink" href="#legacy-future-true" title="Permalink to this heading">¶</a></h3>
<p>“已绑定元数据” 的概念仅存在于 SQLAlchemy 1.x 版本中，从 SQLAlchemy 2.0 开始已删除。</p>
<p>该错误指的是 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 对象中的 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData.params.bind" title="sqlalchemy.schema.MetaData"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">MetaData.bind</span></code></a> 参数，该对象允许类似 ORM <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 将特定映射类与 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 关联。 在 SQLAlchemy 2.0 中，<code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 必须直接链接到每个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code>。 也就是说，必须将 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code> 实例化为关联 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code>，而不是使用 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">)</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>
<span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata_obj</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="o">...</span>


<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyClass</span><span class="p">())</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>必须直接将 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 与 <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 关联。 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 对象不应再与任何引擎关联:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">)</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="o">...</span>


<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyClass</span><span class="p">())</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在 SQLAlchemy 1.4 中，可以在使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 时将 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.future</span></code> 标志设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，以启用此 <span class="xref std std-term">2.0 样式</span> 行为。</p>
</section>
<section id="error-2afi">
<span id="id12"></span><h3>此编译对象未绑定到任何引擎或连接<a class="headerlink" href="#error-2afi" title="Permalink to this heading">¶</a></h3>
<p>此错误是指 “已绑定元数据” 的概念，此概念仅存在于 &lt; SQLAlchemy 1.4 版本中。当从未关联到 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 的 Core 表达式对象中直接从 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Executable.execute()</span></code> 方法调用时，将触发该错误:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">metadata_obj</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>

<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>  <span class="c1"># &lt;--- raises</span></pre></div>
</div>
<p>逻辑逻辑期望的是 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> 对象已被 <strong>绑定</strong> 到 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 上，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql+pymysql://user:pass@host/db&quot;</span><span class="p">)</span>
<span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span></pre></div>
</div>
<p>上述，任何源自 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 的语句，该 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 又派生自该 <a class="reference internal" href="core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>，将隐含使用给定 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 以调用语句。</p>
<p>请注意，“已绑定元数据”的概念在 SQLAlchemy 2.0 中已经 <strong>不存在</strong>。正确的方法是通过 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code> 方法的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code> 来调用语句:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<p>在 ORM 中，通过 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 也可以使用类似的设施:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">tutorial_statement_execution`在 :ref:`faq_session_rollback</span> 的常见问题解答中描述了这个问题。</p>
</div>
<p>“子事务”模式在SQLAlchemy 2.0中被移除，因此这种特定的编程模式将不再可用，从而防止了此错误消息的出现。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="faq/thirdparty.html" title="previous chapter">第三方集成问题</a>
        Next:
        <a href="changelog/index.html" title="next chapter">变更和迁移</a>

    <div id="docs-copyright">
        &copy; <a href="copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 10:07:08

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    './',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="_static/clipboard.min.js"></script>
        <script type="text/javascript" src="_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="_static/init.js"></script>


    </body>
</html>


