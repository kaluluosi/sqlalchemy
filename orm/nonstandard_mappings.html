<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    非传统映射
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="ORM映射类配置" href="mapper_config.html" />
        <link rel="next" title="配置版本计数器" href="versioning.html" />
        <link rel="prev" title="映射类继承层次结构" href="inheritance.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span><ul>
<li><span class="link-container"><a class="reference external" href="mapping_styles.html">ORM映射类概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mapping.html">通过声明性方式映射类</a></span></li>
<li><span class="link-container"><a class="reference external" href="dataclasses.html">与dataclasses和attrs集成</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_sql_expr.html">将SQL表达式映射为属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_attributes.html">更改属性行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="composites.html">复合列类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="inheritance.html">映射类继承层次结构</a></span></li>
<li class="selected"><span class="link-container"><strong>非传统映射</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#maptojoin">将类映射到多个表</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-mapping-arbitrary-subqueries">将类映射到任意子查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id6">一个类的多个映射器</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="versioning.html">配置版本计数器</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapping_api.html">类映射API</a></span></li>
<li><span class="link-container"><a class="reference external" href="scalar_mapping.html">映射SQL表达式</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="inheritance.html" title="previous chapter">映射类继承层次结构</a></li>
                <li><b>Next:</b>
                <a href="versioning.html" title="next chapter">配置版本计数器</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="mapper_config.html" title="ORM映射类配置">ORM映射类配置</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">非传统映射</a><ul>
<li><a class="reference internal" href="#maptojoin">将类映射到多个表</a></li>
<li><a class="reference internal" href="#orm-mapping-arbitrary-subqueries">将类映射到任意子查询</a></li>
<li><a class="reference internal" href="#id6">一个类的多个映射器</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-nonstandard_mappings" >
        
<section id="id1">
<h1>非传统映射<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<section id="maptojoin">
<span id="orm-mapping-joins"></span><span id="id2"></span><h2>将类映射到多个表<a class="headerlink" href="#maptojoin" title="Permalink to this heading">¶</a></h2>
<p>Mapper不仅可以针对纯粹的表进行构造，还可以针对任意关系单元（称为“可选择的”）进行构造。例如，   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.join" title="sqlalchemy.sql.expression.join"><code class="xref py py-func docutils literal notranslate"><span class="pre">join()</span></code></a>  函数创建了一个包含多个表的可选择单元（具有自己的复合主键），这些表可以以与   :class:` _schema.Table`  相同的方式进行映射。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在下文中，原文有一个术语“mapper”，我未予翻译，因为有上下文即可理解。下同。</p>
</div>
<p>以下是一个例子：</p>
<blockquote>
<div><p>from sqlalchemy import Table, Column, Integer, String, MetaData, join, ForeignKey
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import column_property</p>
<p>metadata_obj = MetaData()</p>
<p># 定义两个表格对象
user_table = Table(</p>
<blockquote>
<div><p>“user”,
metadata_obj,
Column(“id”, Integer, primary_key=True),
Column(“name”, String),</p>
</div></blockquote>
<p>)</p>
<dl class="simple">
<dt>address_table = Table(</dt><dd><p>“address”,
metadata_obj,
Column(“id”, Integer, primary_key=True),
Column(“user_id”, Integer, ForeignKey(“user.id”)),
Column(“email_address”, String),</p>
</dd>
</dl>
<p>)</p>
<p># 定义它们之间的连接。这
# 是通过 user.id 和 address.user_id
# 两列进行的。
user_address_join = join(user_table, address_table)</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>metadata = metadata_obj</p>
</dd>
</dl>
<p># 将它们映射到类
class AddressUser(Base):</p>
<blockquote>
<div><p>__table__ = user_address_join</p>
<p>id = column_property(user_table.c.id, address_table.c.user_id)
address_id = address_table.c.id</p>
</div></blockquote>
</div></blockquote>
<p>在上面的例子中，连接表达了 <code class="docutils literal notranslate"><span class="pre">user</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表格的列. <code class="docutils literal notranslate"><span class="pre">user.id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 列是通过外键相等，因此在映射中他们被定义为一个属性， <code class="docutils literal notranslate"><span class="pre">AddressUser.id</span></code>，使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code>  来指示一个专门的列映射。根据配置的这一部分，当刷新发生时，映射将会将新的主键值从 ` <cite>user.id`</cite> 复制到 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 列中。</p>
<p>此外，<code class="docutils literal notranslate"><span class="pre">address.id</span></code> 列映射显式地映射到名为 <code class="docutils literal notranslate"><span class="pre">address_id</span></code> 的属性。这是为了**消除歧义**，从 <code class="docutils literal notranslate"><span class="pre">address.id</span></code> 列的映射中区分同名的 <code class="docutils literal notranslate"><span class="pre">AddressUser.id</span></code> 属性，后者被指定为引用与 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 外键结合的 <code class="docutils literal notranslate"><span class="pre">user</span></code> 表格。</p>
<p>上述映射的自然主键是 <code class="docutils literal notranslate"><span class="pre">(user.id,</span> <span class="pre">address.id)</span></code> 的组合，因为这些是合并为一起的 <code class="docutils literal notranslate"><span class="pre">user</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表格的主键列。 <code class="docutils literal notranslate"><span class="pre">AddressUser</span></code> 对象的标识将是根据这两个值中的任意值，从 <code class="docutils literal notranslate"><span class="pre">AddressUser</span></code> 对象中表示为 <code class="docutils literal notranslate"><span class="pre">(AddressUser.id，AddressUser.address_id)</span></code>。</p>
<p>当引用 <code class="docutils literal notranslate"><span class="pre">AddressUser.id</span></code> 列时，大多数 SQL 表达式将只使用映射列列表中的第一列，因为这两列是同义词。然而，对于特殊的用例，例如必须同时引用两个列的 GROUP BY 表达式，同时利用适当的上下文，即适应别名和类似的内容，在访问器  <a class="reference internal" href="internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions" title="sqlalchemy.orm.ColumnProperty.Comparator.expressions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Comparator.expressions</span></code></a>  中使用。</p>
<blockquote>
<div><p>stmt = select(AddressUser).group_by(<a href="#id3"><span class="problematic" id="id4">*</span></a>AddressUser.id.expressions)</p>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.17: </span>添加了  <a class="reference internal" href="internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions" title="sqlalchemy.orm.ColumnProperty.Comparator.expressions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Comparator.expressions</span></code></a>  访问器。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如上例所示，映射到多个表的映射支持持久性，即针对目标表格中的行的 INSERT、UPDATE 和 DELETE 操作。但是，它不支持在同一记录中在一个表上执行 UPDATE 操作并在其他表上执行 INSERT 或 DELETE 操作。也就是说，如果记录 PtoQ 被映射到“p”和“q”两个表格，其中一个基于“p”和“q”的 LEFT OUTER JOIN，如果进行修改“q” 表格中的数据的更新，行在 “q” 中必须存在; 如果主键标识已经存在，则不会发出 INSERT。如果行不存在，则对于大多数支持报告 UPDATE 所影响行数的 DBAPI 驱动程序，ORM 将无法检测到已更新的行并引发错误；否则，数据将被默默忽略。</p>
<p>允许对相关行进行即时“插入”的一个示例配方可能会利用 .MapperEvents.before_update 事件，代码如下：</p>
<blockquote>
<div><p>from sqlalchemy import event</p>
<p>&#64;event.listens_for(PtoQ, “before_update”)
def receive_before_update(mapper, connection, target):</p>
<blockquote>
<div><dl class="simple">
<dt>if target.some_required_attr_on_q is None:</dt><dd><p>connection.execute(q_table.insert(), {“id”: target.id})</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>在上述代码中，首先使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.insert()</span></code>  创建一个 INSERT 构造，并且使用已经给出的   :class:` _engine.Connection`  执行它，这正是用于发出 SQL 用于刷新过程的那个连接。用户提供的逻辑必须检测到“p”到“q”的 LEFT OUTER JOIN 没有“q”一侧的条目。</p>
</div>
</section>
<section id="orm-mapping-arbitrary-subqueries">
<span id="id5"></span><h2>将类映射到任意子查询<a class="headerlink" href="#orm-mapping-arbitrary-subqueries" title="Permalink to this heading">¶</a></h2>
<p>与映射到连接一样，一个普通的   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  对象也可以与 mapper 一起使用。下面的示例片段说明了如何将名为“Customer”的类映射到一个包括对子查询的连接的   :func:` _expression.select`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span>

<span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span>
        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;order_count&quot;</span><span class="p">),</span>
        <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">price</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;highest_order&quot;</span><span class="p">),</span>
        <span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">customer_id</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">customer_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">customer_select</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">customers</span><span class="p">,</span> <span class="n">subq</span><span class="p">)</span>
    <span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">customers</span><span class="p">,</span> <span class="n">subq</span><span class="p">,</span> <span class="n">customers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">customer_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">customer_select</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>以上例子中，<code class="docutils literal notranslate"><span class="pre">customer_select</span></code> 代表一个完整的行，包含 <code class="docutils literal notranslate"><span class="pre">customers</span></code> 表格的所有列和子查询 <code class="docutils literal notranslate"><span class="pre">subq</span></code> 公开的那些列，分别是 <code class="docutils literal notranslate"><span class="pre">order_count</span></code>、<code class="docutils literal notranslate"><span class="pre">highest_order</span></code> 和 <code class="docutils literal notranslate"><span class="pre">customer_id</span></code>。将 <code class="docutils literal notranslate"><span class="pre">Customer</span></code> 类映射到此可选择项，然后创建包含这些属性的类。</p>
<p>当 ORM 持久化“Customer”的新实例时，实际上仅会向 <code class="docutils literal notranslate"><span class="pre">customers</span></code> 表格插入数据。这是因为 <code class="docutils literal notranslate"><span class="pre">ordres</span></code> 表格的主键在映射中没有被表示；ORM 仅会向已映射主键的表格插入数据。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>映射到任意 SELECT 语句的做法，尤其是像上面的那样复杂的 SELECT 语句，是几乎不需要的。这种方法必然导致生成复杂的查询，往往比直接构造查询的查询效率低。这种做法在 SQLalchemy 的早期历史上就存在了，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  构造旨在代表主要的查询界面，但在现代使用中，   :class:` _query.Query`  对象可以用来构造几乎任何 SELECT 语句，包括复杂的复合语句，应优先考虑“映射到可选择”的方法。</p>
</div>
</section>
<section id="id6">
<h2>一个类的多个映射器<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>在现代 SQLalchemy 中，特定类同时只由一个所谓的**主要**映射器进行映射。这个映射器涉及三个主要功能领域：查询、持久化和对映射类的仪表化。主要映射器的理论基础是，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  并非只将其持久地编制到特定的   :class:` _schema.Table`  上，而是也会 <strong>仪表化</strong> 类上的属性，特定地基于表格元数据进行结构化。由于只有一个映射器实际上可以更改类本身，而不仅仅是将其持久化到特定的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  中，因此没有多个映射器能够与类以相同的度量关联。</p>
<p>“非主要”映射器的概念在 SQLalchemy 的早期版本中一直存在，但从版本 1.3 开始，该特性已被弃用。当仅构建与可选择项关联的关系时，这种非主要映射器是有用的。现在可以使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">aliased</span></code>  来实现该用例，关于这个：ref:` relationship_aliased_class`.</p>
<p>关于将一个类完全持久化到不同的表格中的用例， SQLalchemy 的早期版本提供了一种功能，从 Hibernate 改编而来，称为“实体名称”功能。但是，在 SQLalchemy 将映射类本身成为 SQL 表达式构造的来源后，这个用例变得不可行，即，类的属性直接链接到映射表列。该特性已被删除，并替换为一种无歧义仪表化方法的简单配方，即创建单独映射的新子类。现在，这种模式可以作为配方使用，位于 <a class="reference external" href="https://www.sqlalchemy.org/trac/wiki/使用/配方/EntityName">Entity Name</a> 。</p>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="inheritance.html" title="previous chapter">映射类继承层次结构</a>
        Next:
        <a href="versioning.html" title="next chapter">配置版本计数器</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:59:01

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


