<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    非传统映射
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="ORM映射类配置" href="mapper_config.html" />
        <link rel="next" title="配置版本计数器" href="versioning.html" />
        <link rel="prev" title="映射类继承层次结构" href="inheritance.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span><ul>
<li><span class="link-container"><a class="reference external" href="mapping_styles.html">ORM映射类概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mapping.html">使用Declarative映射类</a></span></li>
<li><span class="link-container"><a class="reference external" href="dataclasses.html">与dataclasses和attrs集成</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_sql_expr.html">将 SQL 表达式作为映射属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_attributes.html">更改属性行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="composites.html">组合列类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="inheritance.html">映射类继承层次结构</a></span></li>
<li class="selected"><span class="link-container"><strong>非传统映射</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#maptojoin">将一个类映射到多个表</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-mapping-arbitrary-subqueries">将类映射到任意子查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id10">一个类的多个映射器</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="versioning.html">配置版本计数器</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapping_api.html">类映射API</a></span></li>
<li><span class="link-container"><a class="reference external" href="scalar_mapping.html">SQL表达式映射</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">使用Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部实现</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="inheritance.html" title="previous chapter">映射类继承层次结构</a></li>
                <li><b>Next:</b>
                <a href="versioning.html" title="next chapter">配置版本计数器</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="mapper_config.html" title="ORM映射类配置">ORM映射类配置</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">非传统映射</a><ul>
<li><a class="reference internal" href="#maptojoin">将一个类映射到多个表</a></li>
<li><a class="reference internal" href="#orm-mapping-arbitrary-subqueries">将类映射到任意子查询</a></li>
<li><a class="reference internal" href="#id10">一个类的多个映射器</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-nonstandard_mappings" >
        
<section id="id1">
<h1>非传统映射<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<section id="maptojoin">
<span id="orm-mapping-joins"></span><span id="id2"></span><h2>将一个类映射到多个表<a class="headerlink" href="#maptojoin" title="Permalink to this heading">¶</a></h2>
<p>Mapper可以针对任意关系单元（称为*selectable*）进行构建，而不仅仅是普通的表。例如，:func:<a href="#id3"><span class="problematic" id="id4">`</span></a>_expression.join`函数创建了一个包含多个表的可选单元，其中包括自己的复合主键，可以与:class:<a href="#id5"><span class="problematic" id="id6">`</span></a>_schema.Table`一样映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">join</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">column_property</span>

<span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="c1"># 定义两个 Table 对象</span>
<span class="n">user_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;user&quot;</span><span class="p">,</span>
    <span class="n">metadata_obj</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">address_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;address&quot;</span><span class="p">,</span>
    <span class="n">metadata_obj</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user.id&quot;</span><span class="p">)),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;email_address&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1"># 定义它们之间的连接。它们之间是通过 user.id 和 address.user_id</span>
<span class="c1"># 列进行连接的。</span>
<span class="n">user_address_join</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">user_table</span><span class="p">,</span> <span class="n">address_table</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata_obj</span>


<span class="c1"># 映射到这个连接</span>
<span class="k">class</span> <span class="nc">AddressUser</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">user_address_join</span>

    <span class="c1"># 使用 column_property 指定一个特殊的列映射关系。这个 id 属性来自两张表的 id 列和 address.user_id 列</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">column_property</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>

    <span class="c1"># 将 address.id 列映射到一个名为 address_id 的属性。这是为了明确其映射</span>
    <span class="n">address_id</span> <span class="o">=</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在上面的例子中，连接表达了 “user” 和 “address” 表的列。用户表和地址表的”id”和”user_id”列通过外键进行匹配，因此在映射时它们定义为一个属性，”AddressUser.id”。根据配置的这部分内容，当刷新发生时，映射将从”user.id”复制新的主键值到”address.user_id”列中。</p>
<p>此外， “address.id”列显式映射到名为 “address_id”的属性。这是为了**区分**”address.id”列的映射和同名的”AddressUser.id”属性，后者已指定为引用与”address.user_id”外键相结合的”user”表。</p>
<p>上面映射的自然主键是”(user.id，address.id)”的组合，因为这些是”user”和”address”表一起组合的主键列。一个”AddressUser”对象的标识将基于这两个值，并且从一个”AddressUser”对象表示为”(AddressUser.id，AddressUser.address_id)”。</p>
<p>在引用”AddressUser.id”列时，大多数SQL表达式将只使用映射的列列表中的第一列，因为这两列是同义词。但是，对于一些特殊的用例，例如GROUP BY表达式，在同时引用两个列时必须使用proper context，即适应别名和相似文本，可以使用 <a class="reference internal" href="internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions" title="sqlalchemy.orm.ColumnProperty.Comparator.expressions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Comparator.expressions</span></code></a> 访问器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">AddressUser</span><span class="p">)</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="o">*</span><span class="n">AddressUser</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">expressions</span><span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.17: </span>添加了 <a class="reference internal" href="internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions" title="sqlalchemy.orm.ColumnProperty.Comparator.expressions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Comparator.expressions</span></code></a> 访问器。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如上所示，针对多个表的映射支持持久性，即插入、更新和删除有关目标表中的行。但是，它不支持同时将更新一个表并在同一行上执行INSERT或DELETE的操作。也就是说，如果将一行“PtoQ”映射到“p”和“q”表，其中它基于“p”和“q”的LEFT OUTER JOIN，如果进行一个要在现有的记录中更改“q”表中的数据的UPDATE，行中必须有“q”，否则，对于大多数支持报告UPDATE所影响的行数的DBAPI驱动程序，ORM将无法检测到已更新的行并引发错误；否则，数据会被默默忽略。</p>
<p>一个允许在其他任一工作的”插入”相关行的食谱可以利用.MapperEvents.before_update事件，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>


<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">PtoQ</span><span class="p">,</span> <span class="s2">&quot;before_update&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_update</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">some_required_attr_on_q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q_table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="p">})</span></pre></div>
</div>
<p>在上面的例子中，通过使用 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.insert" title="sqlalchemy.schema.Table.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.insert()</span></code></a> 创建一个INSERT构造，然后使用给定的:class:<a href="#id7"><span class="problematic" id="id8">`</span></a>_engine.Connection`执行它，改变了“q_table”表中的行，在 emit 的过程中使用了相同的 SQL，从而将行 INSERT 到 “q_table” 表中。用户提供的逻辑必须检测从“p”到“q”左外连接是否没有一个条目关于“q”侧。</p>
</div>
</section>
<section id="orm-mapping-arbitrary-subqueries">
<span id="id9"></span><h2>将类映射到任意子查询<a class="headerlink" href="#orm-mapping-arbitrary-subqueries" title="Permalink to this heading">¶</a></h2>
<p>与映射连接类似，也可以使用简单的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 对象作为映射器。下面的例子片段说明了如何将名为 “Customer” 的类映射到一个包括对子查询的连接的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span>

<span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span>
        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;order_count&quot;</span><span class="p">),</span>
        <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">price</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;highest_order&quot;</span><span class="p">),</span>
        <span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">customer_id</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">orders</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">customer_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">customer_select</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">customers</span><span class="p">,</span> <span class="n">subq</span><span class="p">)</span>
    <span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">customers</span><span class="p">,</span> <span class="n">subq</span><span class="p">,</span> <span class="n">customers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">customer_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">customer_select</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在上面的例子中，”customer_select”所表示的完整行将是”customers” 表的所有列，以及 “subq” 子查询公开的那些列，即 “order_count”， “highest_order”和 “customer_id”。将”Customer”类映射到此可选择会创建一个包含这些属性的类。</p>
<p>当ORM持久化新的“Customer”实例时，实际上只有“customers”表会收到INSERT。这是因为“orders”表的主键没有在映射中表示；ORM仅会为它已映射主键的表发出INSERT。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>针对任意SELECT语句进行映射的做法，尤其是像上面那样的复杂语句，几乎不需要；它必然会产生复杂的查询，往往比直接查询构造的效率低得多。这种做法在某种程度上是基于SQLAlchemy非常早期的历史，其中 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code> 结构被认为是主要的查询接口；在现代使用中， <a class="reference internal" href="queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 对象可以用于构建任何 SELECT 语句，包括复杂的组合，并且应该优先使用“map-to-selectable”方法。</p>
</div>
</section>
<section id="id10">
<h2>一个类的多个映射器<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<p>在现代SQLAlchemy中，一个特定的类同时只被一个所谓的**primary**映射器映射。这个映射器涉及三个主要功能区域：查询、持久性和对映射类进行仪器化。主映射器的原理与事实相符，即 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code> 修改类本身，不仅将其持久化到特定的:class:<cite>_schema.Table</cite>，而且还在类上调用 <span class="xref std std-term">instrumenting</span> 属性，这些属性根据表元数据特定地结构化。由于只有一个映射器可以实际仪器化类，因此不可能让多个映射器与等量地与其关联。</p>
<p>“非主” 映射器的概念已经存在于许多版本的SQLAlchemy中，但是从版本1.3开始，这个特性已经被弃用。唯一需要这样一个非主映射器的情况是针对可替代选择性地构建关系到一个类的情况。这种用例现在适用于 <code class="xref py py-class docutils literal notranslate"><span class="pre">aliased</span></code> 构造，并在 <a class="reference internal" href="join_conditions.html#relationship-aliased-class"><span class="std std-ref">关于关系的别名类</span></a> 中描述。</p>
<p>关于通过在不同情况下完全持久化到不同表的类的用例，早期版本的SQLAlchemy提供了一种改编自Hibernate的功能，称为“entity name”特性。但是，在映射的类本身成为SQL表达式构造的源之后，即类自身的属性直接链接到映射的表列，这种用法在SQLAlchemy中变得不可行。该特性被删除，并替换为一种简单的面向方案的方法，用于在没有任何仪器化的歧义的情况下实现此任务 - 创建新的子类，每个子类单独映射。现在，这种模式作为一个食谱可用于`Entity Name&lt;<a class="reference external" href="https://www.sqlalchemy.org/trac/wiki/UsageRecipes/EntityName">https://www.sqlalchemy.org/trac/wiki/UsageRecipes/EntityName</a>&gt;`_。</p>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="inheritance.html" title="previous chapter">映射类继承层次结构</a>
        Next:
        <a href="versioning.html" title="next chapter">配置版本计数器</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:47:30

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


