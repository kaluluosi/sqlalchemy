<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    附加的持久化技术
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="用 Session" href="session.html" />
        <link rel="next" title="上下文/线程本地会话" href="contextual.html" />
        <link rel="prev" title="事务和连接管理" href="session_transaction.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span><ul>
<li><span class="link-container"><a class="reference external" href="session_basics.html">会话基础知识</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_state_management.html">状态管理</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_transaction.html">事务和连接管理</a></span></li>
<li class="selected"><span class="link-container"><strong>附加的持久化技术</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sql-flush">将SQL插入/更新表达式嵌入到Flush中</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sessionssql">在Sessions中使用SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#null">在具有默认值的列上强制执行NULL</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-server-defaults">提取服务器生成的默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#insertupdateon-conflict-upsert-orm">使用INSERT、UPDATE和ON CONFLICT（即upsert）返回ORM对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session">分区策略（例如 Session 上的多个数据库后端）</a></span></li>
<li><span class="link-container"><a class="reference external" href="#bulk-operations">批量操作</a></span></li>
<li><span class="link-container"><a class="reference external" href="contextual.html">上下文/线程本地会话</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_events.html">使用事件追踪查询、对象和会话更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_api.html">会话API</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="session_transaction.html" title="previous chapter">事务和连接管理</a></li>
                <li><b>Next:</b>
                <a href="contextual.html" title="next chapter">上下文/线程本地会话</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="session.html" title="用 Session">用 Session</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">附加的持久化技术</a></li>
<li><a class="reference internal" href="#sql-flush">将SQL插入/更新表达式嵌入到Flush中</a></li>
<li><a class="reference internal" href="#sessionssql">在Sessions中使用SQL表达式</a></li>
<li><a class="reference internal" href="#null">在具有默认值的列上强制执行NULL</a></li>
<li><a class="reference internal" href="#orm-server-defaults">提取服务器生成的默认值</a><ul>
<li><a class="reference internal" href="#returning">情况2：表包含与RETURNING不兼容的触发器生成的值</a></li>
<li><a class="reference internal" href="#id21">情况3：非主键，不支持或不需要RETURNING或等效</a></li>
<li><a class="reference internal" href="#orm-server-default-fetching-example">示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#insertupdateon-conflict-upsert-orm">使用INSERT、UPDATE和ON CONFLICT（即upsert）返回ORM对象</a><ul>
<li><a class="reference internal" href="#returningpostgresql-on-conflictupserted-orm">使用带有RETURNING的PostgreSQL ON CONFLICT返回upserted ORM对象</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session">分区策略（例如 Session 上的多个数据库后端）</a><ul>
<li><a class="reference internal" href="#id35">简单的垂直分区</a></li>
<li><a class="reference internal" href="#id38">为多元引擎会话协调事务</a></li>
<li><a class="reference internal" href="#session-custom-partitioning">自定义垂直分区</a></li>
<li><a class="reference internal" href="#id40">水平分区</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bulk-operations">批量操作</a></li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-persistence_techniques" >
        
<section id="id1">
<h1>附加的持久化技术<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
</section>
<section id="sql-flush">
<span id="flush-embedded-sql-expressions"></span><h1>将SQL插入/更新表达式嵌入到Flush中<a class="headerlink" href="#sql-flush" title="Permalink to this heading">¶</a></h1>
<p>此功能允许将数据库列的值设置为SQL表达式而不是文字值。它特别适用于原子更新、调用存储过程等。你只需要将表达式分配给属性即可:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;some_table&quot;</span>

    <span class="c1"># ...</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>


<span class="n">someobject</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># 将&quot;value&quot;属性设置为SQL表达式加1</span>
<span class="n">someobject</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># 发布 &quot;UPDATE some_table SET value=value+1&quot;</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>此方法适用于INSERT和UPDATE语句。在Flush/commit操作之后，“someobject”上的“value”属性过期，因此在下次访问时，新生成的值将从数据库中加载。</p>
<p>该功能还具有条件支持，以与主键列一起使用。对于具有RETURNING支持的后端(包括Oracle、SQL Server、MariaDB 10.5、SQLite 3.35)，SQL表达式还可以分配到主键列中。这样，即可以计算SQL表达式，也可以成功检索单个对象的主键中修改主键值的任何服务器端触发器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
    <span class="n">pk</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bar</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>


<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sql</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="n">sql</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Foo</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在PostgreSQL上，上述 :class:<a href="#id2"><span class="problematic" id="id3">`</span></a>.Session`会发出以下INSERT:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="n">foopk</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span>
<span class="p">((</span><span class="k">SELECT</span><span class="w"> </span><span class="k">coalesce</span><span class="p">(</span><span class="k">max</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">foopk</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">max_1</span><span class="p">)</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">coalesce_2</span><span class="p">)</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">coalesce_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">foopk</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3: </span>SQL表达式现在可以在ORM中的Flush期间传递到主键列；如果数据库支持RETURNING，或者正在使用pysqlite，则ORM将能够检索服务器生成的值作为主键属性的值。</p>
</div>
</section>
<section id="sessionssql">
<span id="session-sql-expressions"></span><h1>在Sessions中使用SQL表达式<a class="headerlink" href="#sessionssql" title="Permalink to this heading">¶</a></h1>
<dl>
<dt>SQL表达式和字符串可以通过  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ~.Session.execute` 方法完成，该方法以与 :class:<a href="#id4"><span class="problematic" id="id5">`</span></a>~sqlalchemy.engine.Engine`或</dt><dd><p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> ~sqlalchemy.engine.CursorResult`:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>

<span class="c1"># 执行一个字符串语句</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select * from table where id=:id&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">})</span>

<span class="c1"># 执行SQL表达式构造</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">mytable</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">))</span></pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ~sqlalchemy.engine.Connection`可通过  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.connection()</span></code>  方法获得:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">()</span></pre></div>
</div>
</dd>
<dt>上述示例处理绑定到单个  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 。如果要使用绑定到多个引擎或未绑定任何引擎的 :class:<a href="#id6"><span class="problematic" id="id7">`</span></a>_orm.Session`执行语句(即依赖于绑定的元数据)，</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  和  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.connection()</span></code>  接受一个绑定参数字典，其中可能包括“mapper”参数，</p>
</dd>
</dl>
<p>这表示映射的类或 :class:<a href="#id8"><span class="problematic" id="id9">`</span></a>_orm.Mapper`实例，用于定位所需引擎的正确上下文:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>

<span class="c1"># 在执行时需要指定映射器或类</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">text</span><span class="p">(</span><span class="s2">&quot;select * from table where id=:id&quot;</span><span class="p">),</span>
    <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span>
    <span class="n">bind_arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;mapper&quot;</span><span class="p">:</span> <span class="n">MyMappedClass</span><span class="p">},</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">mytable</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">),</span> <span class="n">bind_arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;mapper&quot;</span><span class="p">:</span> <span class="n">MyMappedClass</span><span class="p">}</span>
<span class="p">)</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">(</span><span class="n">MyMappedClass</span><span class="p">)</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.4: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code> <cite>mapper``和``clause``参数现在作为字典的一部分通过发送给  :paramref:`_orm.Session.execute.bind_arguments</cite>  参数而传递。
先前的参数仍然被接受，但是该用法已被弃用。</p>
</div>
</section>
<section id="null">
<span id="session-forcing-null"></span><h1>在具有默认值的列上强制执行NULL<a class="headerlink" href="#null" title="Permalink to this heading">¶</a></h1>
<p>ORM将任何未在对象上显式设置的属性都视为”default”情况；属性将从INSERT语句中省略:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyObject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_table&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># INSERT with the &#39;data&#39; column omitted; the database</span>
<span class="c1"># itself will persist this as the NULL value</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>从INSERT中省略列意味着该列将设置为NULL值，除非该列设置了默认值，在这种情况下，将保留默认值。从一个纯SQL的角度、从客户端和服务器端的默认行为以及使用客户端和服务器端默认的SQLAlchemy的插入行为都是如此：</p>
<blockquote>
<div><dl class="simple">
<dt>class MyObject(Base):</dt><dd><p>__tablename__ = “my_table”
id = mapped_column(Integer, primary_key=True)
data = mapped_column(String(50), nullable=True, server_default=”default”)</p>
</dd>
</dl>
<p>obj = MyObject(id=1)
session.add(obj)
session.commit()  # INSERT with the ‘data’ column omitted; the database
# itself will persist this as the value ‘default’</p>
</div></blockquote>
<p>但是，在ORM中，即使在对象上将Python值``None``显式分配给属性，这也被视为与未分配该值相同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyObject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_table&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">server_default</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>


<span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># INSERT with the &#39;data&#39; column explicitly set to None;</span>
<span class="c1"># the ORM still omits it from the statement and the</span>
<span class="c1"># database will still persist this as the value &#39;default&#39;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述操作将在``data``列中保留服务器的默认值``”default”<code class="docutils literal notranslate"><span class="pre">，而不是SQL</span> <span class="pre">NULL，即使传递了``None</span></code>；这是ORM的长期行为，许多应用程序将其视为假设。</p>
<p>那么，如果我们希望实际将NULL放入此列中，即使该列具有默认值，该怎么办？有两种方法。一种是在单个实例级别上使用  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.null" title="sqlalchemy.sql.expression.null"><code class="xref py py-obj docutils literal notranslate"><span class="pre">null</span></code></a>   SQL构造分配属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">null</span>

  <span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">null</span><span class="p">())</span>
  <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
  <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># INSERT with the &#39;data&#39; column explicitly set as null();</span>
  <span class="c1"># ORM直接使用它，绕过所有客户端和服务器</span>
  <span class="c1"># 默认值，数据库将将其持久化为NULL值</span>

<span class="p">:</span><span class="n">obj</span><span class="p">:</span><span class="err">`</span><span class="n">_expression</span><span class="o">.</span><span class="n">null</span><span class="err">`</span>   <span class="n">SQL构造总是转换为目标INSERT语句中直接存在的SQL</span> <span class="n">NULL值</span><span class="err">。</span></pre></div>
</div>
<p>如果我们希望能够使用Python值``None``，并且这也被持久化为NULL，尽管存在列默认值，我们可以使用Core级修饰符  <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none" title="sqlalchemy.types.TypeEngine.evaluates_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.evaluates_none()</span></code></a>  进行ORM配置。该修饰符指示ORM要将“None”值与任何其他值相同地对待并将其传递，而不是将其视为缺少的“missing”值:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyObject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_table&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span>
        <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">evaluates_none</span><span class="p">(),</span>  <span class="c1"># 表明None应始终被传递</span>
        <span class="n">nullable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">server_default</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># INSERT with the &#39;data&#39; column explicitly set to None;</span>
<span class="c1"># ORM直接使用它，绕过所有客户端和服务器</span>
<span class="c1"># 默认值，数据库将将其持久化为NULL值</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<aside class="topic">
<p class="topic-title">根据None评估</p>
<blockquote>
<div><p><a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none" title="sqlalchemy.types.TypeEngine.evaluates_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.evaluates_none()</span></code></a>  修饰符主要用于表明Python值“None”是有意义的类型，主要示例是可以将JSON类型持久化为JSON <a href="#id10"><span class="problematic" id="id11">``</span></a>null``而不是SQL NULL。</p>
</div></blockquote>
<p>我们稍微重新解释它的作用，以便ORM能够在存在它时在类型中传递“None”，即使未分配特殊类型级行为。</p>
</aside>
</section>
<section id="orm-server-defaults">
<span id="id12"></span><h1>提取服务器生成的默认值<a class="headerlink" href="#orm-server-defaults" title="Permalink to this heading">¶</a></h1>
<p>如   <span class="xref std std-ref">server_defaults</span>  和   <span class="xref std std-ref">triggered_columns</span>  中介绍的那样，Core支持数据库列，其中数据库本身在INSERT和在不太常见的情况下在UPDATE语句中生成一个值。ORM特征支持对这些列进行的查看，
以便在Flush时检索这些新生成的值。需要在具有服务器生成值的主键列的情况下进行此操作，因为ORM需要知道对象的主键一旦持久化就可以使用。</p>
<p>在绝大多数情况下，具有自动由数据库生成的主键列都是简单的整数列，这些列通过称为所谓的“自动增量”列的数据库实现，或者从与该列关联的序列中实现。SQLAlchemy Core中的每个数据库方言都支持检索这些主键值的方法，这通常是Python DBAPI原生支持的，通常情况下自动处理这个过程。 更多文档详见  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.autoincrement</span></code></a>  。</p>
<p>对于不是主键列或不是简单自动增量整数列的服务器生成列，ORM要求将这些列标记为适当的``server_default``指令，以允许ORM检索此值。但是，并非所有方法都在所有后端上得到支持，因此必须小心地使用适当的方法。需要回答的两个问题是，1.此列是否是主键列，2.数据库是否支持RETURNING或等效内容，如”OUTPUT inserted” ; 这些是在调用INSERT或UPDATE语句的同时返回服务器生成值的SQL短语。RETURNING目前由PostgreSQL、Oracle、MariaDB 10.5、SQLite 3.35和SQL Server支持。</p>
<p>情况1：非主键，支持RETURNING或等效内容</p>
<p>在此情况下，列应使用  <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.FetchedValue" title="sqlalchemy.schema.FetchedValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">FetchedValue</span></code></a>  或显式使用  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.server_default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_default</span></code></a>   标记。在Flush语句执行INSERT操作时，假设  <a href="#id13"><span class="problematic" id="id14">:param:`_orm.Mapper.eager_defaults`</span></a>  参数设置为 <a href="#id15"><span class="problematic" id="id16">``</span></a>True``或者对于支持 RETURNING
以及   <a class="reference internal" href="../core/connections.html#engine-insertmanyvalues"><span class="std std-ref">insertmanyvalues</span></a>  包括在内的方言，ORM将自动将这些列添加到RETURNING子句中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_table&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># 服务器端SQL日期函数生成新的时间戳</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(),</span> <span class="n">server_default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>

    <span class="c1"># 在INSERT期间，数据库中的某些其他服务器端函数或触发器名称不在此处，会将一个值分配给该列</span>
    <span class="n">special_identifier</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">server_default</span><span class="o">=</span><span class="n">FetchedValue</span><span class="p">())</span>

    <span class="c1"># 设置eager_defaults为True。这通常是可选的，因为如果</span>
    <span class="c1"># 后端支持RETURNING + insertmanyvalues，则INSERT会自动处理提示</span>
    <span class="c1"># 发生</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eager_defaults&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面，在客户端上未指定“timestamp”或“special_identifier”的值的INSERT语句将包括在RETURNING子句中的“timestamp”和“特殊标识符”，因此它们将立即可用。在PostgreSQL数据库上，上述表的INSERT如下所示：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="k">timestamp</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">special_identifier</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0.0rc1: </span><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.eager_defaults</span></code>  现在的值默认为一个新的设置”auto”，如果后端数据库既支持 RETURNING 又支持   <a class="reference internal" href="../core/connections.html#engine-insertmanyvalues"><span class="std std-ref">insertmanyvalues</span></a> ，将自动使用 RETURNING 来获取插入的默认值。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.eager_defaults</span></code>  的``”auto”<cite>值仅适用于INSERT语句。即使是可用的，UPDATE语句也不会使用RETURNING ，除非将  :paramref:`_orm.Mapper.eager_defaults</cite>  设置为``True``。这是因为不存在等效的 “insertmanyvalues” 功能，因此UPDATE RETURNING将需要为每个要UPDATE的行单独发出UPDATE语句。</p>
</div>
<section id="returning">
<h2>情况2：表包含与RETURNING不兼容的触发器生成的值<a class="headerlink" href="#returning" title="Permalink to this heading">¶</a></h2>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a>”auto”<a href="#id19"><span class="problematic" id="id20">``</span></a>设置的  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.eager_defaults</span></code>   意味着后端支持RETURNING时，常规情况下会使用RETURNING来获取新生成的默认值。然而，服务器生成值存在以下限制，例如使用触发器时RETURNING不能使用：</p>
<ul class="simple">
<li><p>SQL Server不允许在INSERT语句中使用RETURNING检索触发器生成的值；语句将失败。</p></li>
<li><p>SQLite在将返回的值与触发器结合使用时存在限制，因此返回的子句将无法使用插入的值。</p></li>
<li><p>其他后端可能存在限制，无法与触发器或其他类型的服务器生成值一起使用RETURNING。</p></li>
</ul>
<p>为了禁用这些值的RETURNING使用，这些值包含了但不仅限于服务器生成的默认值，以确保ORM能够检索到它们,  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.implicit_returning" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.implicit_returning</span></code></a> .Table`的值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。此类Declarative映射如下所示：</p>
<blockquote>
<div><dl>
<dt>class MyModel(Base):</dt><dd><p>__tablename__ = “my_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
data: Mapped[str] = mapped_column(String(50))</p>
<p>#假设一个触发器在INSERT期间将一个值分配给该列
special_identifier = mapped_column(String(50), server_default=FetchedValue())</p>
<p>#禁用表的所有RETURNING用法
__table_args__ = {“implicit_returning”: False}</p>
</dd>
</dl>
</div></blockquote>
<p>在使用pyodbc驱动程序的SQL Server上，以上表的INSERT将不使用RETURNING，并使用SQL Server的``scope_identity()``函数检索新生成的主键值：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">);</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">scope_identity</span><span class="p">()</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/mssql.html#mssql-insert-behavior"><span class="std std-ref">INSERT behavior</span></a>  - SQL Server方言获取新增生成的主键值的背景</p>
</div>
</section>
<section id="id21">
<h2>情况3：非主键，不支持或不需要RETURNING或等效<a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h2>
<p>此情况与上面的情况1相同，但通常不希望使用  <a href="#id22"><span class="problematic" id="id23">:param:`_orm.Mapper.eager_defaults`</span></a>  ，因为在没有RETURNING支持的情况下，它的当前实现是发出一个SELECT-per-row，这不是高效的。因此，在映射以下情况时略去参数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_table&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">(),</span> <span class="n">server_default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>

    <span class="c1"># 假设数据库中的某些其他服务器端函数或触发器名称不在此处，将一个值分配给该列的INSERT</span>
    <span class="n">special_identifier</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">server_default</span><span class="o">=</span><span class="n">FetchedValue</span><span class="p">())</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在使用不包括RETURNING或“insertmanyvalues”支持的后端讯息时，上面的记录在执行Flush后加入中的“timestamp”和“special_identifier”列将保持为空，且在在Flush后首次访问它们时将通过第二个SELECT语句中的“过时”标记它们，例如它们在FLUSH之后。如果显式提供  <a href="#id24"><span class="problematic" id="id25">:param:`_orm.Mapper.eager_defaults`</span></a>   值 “True”，并且后端数据库不支持 RETURNING 或等效内容，
ORM将立即在 INSERT 语句之后发出一个SELECT语句，以获取新生成的值; ORM目前无法在没有RETURNING的情况下批量选择许多新插入的行。这通常是不希望的，因为它会在Flush过程中增加了额外的SELECT语句，可能不需要。在使用上面的映射与MySQL(而不是MariaDB)进行Flush时，会导致文本如下的SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">()</span>

<span class="c1">-- 当 eager_defaults **被**使用，但不支持 RETURNING</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="k">timestamp</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">my_table_timestamp</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">special_identifier</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">my_table_special_identifier</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">%</span><span class="n">s</span></pre></div>
</div>
<p>在没有RETURNING的情况下，为了从服务器获取默认值，还要注意客户端生成的SQL表达式的问题。有关这些表达式的详细信息，可参考  <a class="reference internal" href="../core/defaults.html#defaults-client-invoked-sql"><span class="std std-ref">由客户端调用的SQL表达式</span></a> 。这些SQL表达式目前在ORM中受到与真实服务器端默认值相同的限制；即使这些表达式不是DDL服务器端默认值并且由SQLAlchemy本身活跃渲染，它们也不会在  <a href="#id26"><span class="problematic" id="id27">:param:`_orm.Mapper.eager_defaults`</span></a>  设置为 <a href="#id28"><span class="problematic" id="id29">``</span></a>”auto”<a href="#id30"><span class="problematic" id="id31">``</span></a>或``True``且没有与该列关联的  <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.FetchedValue" title="sqlalchemy.schema.FetchedValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">FetchedValue</span></code></a>  上使用 :class:<a href="#id32"><span class="problematic" id="id33">`</span></a>.FetchedValue`指令来强制使用查看, 请参见下面的示例。</p>
</section>
<section id="orm-server-default-fetching-example">
<span id="id34"></span><h2>示例<a class="headerlink" href="#orm-server-default-fetching-example" title="Permalink to this heading">¶</a></h2>
<p>以下是一个包含举例的示例，展示了两列被指定为数据库在INSERT期间自动生成，另一列需要触发器</p>
<p>__mapper_args__ = {“eager_defaults”: True}</p>
<p>如果映射类类似于上述模式，ORM为INSERT和UPDATE生成的SQL将在RETURNING子句中包含“created”和“updated”：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">(</span><span class="n">created</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="n">now</span><span class="p">())</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">created</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">updated</span>

<span class="k">UPDATE</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">updated</span><span class="o">=</span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">my_table_id</span><span class="p">)</span><span class="n">s</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">updated</span></pre></div>
</div>
</section>
</section>
<section id="insertupdateon-conflict-upsert-orm">
<span id="orm-dml-returning-objects"></span><h1>使用INSERT、UPDATE和ON CONFLICT（即upsert）返回ORM对象<a class="headerlink" href="#insertupdateon-conflict-upsert-orm" title="Permalink to this heading">¶</a></h1>
<p>SQLAlchemy 2.0增强了触发几种ORM-enabled INSERT、UPDATE和upsert语句的能力。参见文档  <a class="reference internal" href="queryguide/dml.html"><span class="doc">ORM-启用的INSERT、UPDATE和DELETE语句</span></a>  进行文档化。有关upsert，请参见   <a class="reference internal" href="queryguide/dml.html#orm-queryguide-upsert"><span class="std std-ref">ORM “upsert” 语句 （UPSERT语句）</span></a> 。</p>
<section id="returningpostgresql-on-conflictupserted-orm">
<h2>使用带有RETURNING的PostgreSQL ON CONFLICT返回upserted ORM对象<a class="headerlink" href="#returningpostgresql-on-conflictupserted-orm" title="Permalink to this heading">¶</a></h2>
<p>本节移到了   <a class="reference internal" href="queryguide/dml.html#orm-queryguide-upsert"><span class="std std-ref">ORM “upsert” 语句 （UPSERT语句）</span></a> 。</p>
</section>
</section>
<section id="session">
<span id="session-partitioning"></span><h1>分区策略（例如 Session 上的多个数据库后端）<a class="headerlink" href="#session" title="Permalink to this heading">¶</a></h1>
<section id="id35">
<h2>简单的垂直分区<a class="headerlink" href="#id35" title="Permalink to this heading">¶</a></h2>
<p>垂直分区使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.binds</span></code>  参数通过将不同的类、类层次结构或映射表配置在多个数据库中来划分它们。此参数接收一个字典，其中包含任意组合的ORM映射类、映射层次结构中的任意类（例如声明基类或mixin）、  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象和   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  对象作为键，然后通常引用   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  或较少用   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  对象作为目标。每当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  需要代表特定类型的映射类发出SQL以查找相应的数据库连接时，都会使用该字典。例如：</p>
<blockquote>
<div><p>engine1 = create_engine(“postgresql+psycopg2://db1”)
engine2 = create_engine(“postgresql+psycopg2://db2”)</p>
<p>Session = sessionmaker()</p>
<p># 将 User 操作绑定到 engine1，将 Account 操作绑定到 engine2。
Session.configure(binds={User: engine1, Account: engine2})</p>
<p>session = Session()</p>
</div></blockquote>
<p>以上，针对任一类进行的 SQL 操作都将使用链接到该类的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 。此功能在读取和写入操作方面是综合性的。对映射到“engine1”（通过查看请求项列表中的第一个实体来确定）的实体进行的   <a class="reference internal" href="queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  将使用“engine1”来运行查询。在每个类的基础上进行 flush 操作时，会单独使用 <strong>两个</strong> 引擎作为它刷新类型为“User”和“Account”的对象。</p>
<p>在较常见的情况下，通常有基础类或 mixin 类，可用于区分注定要发送到不同数据库连接的操作。  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.binds</span></code>   参数可以接受任意任意 Python 类作为键，如果发现它在特定映射类的 <a href="#id36"><span class="problematic" id="id37">``</span></a>__mro__``（Python 方法解析顺序）中，则将其用作键。假设两个声明基类表示两个不同的数据库连接：</p>
<blockquote>
<div><p>from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Session</p>
<dl class="simple">
<dt>class BaseA(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class BaseB(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class User(BaseA):</dt><dd><p>…</p>
</dd>
<dt>class Address(BaseA):</dt><dd><p>…</p>
</dd>
<dt>class GameInfo(BaseB):</dt><dd><p>…</p>
</dd>
<dt>class GameStats(BaseB):</dt><dd><p>…</p>
</dd>
</dl>
<p>Session = sessionmaker()</p>
<p># 所有 User/Address 操作都将在 engine1 上执行，所有 Game 操作都将在 engine2 上执行。
Session.configure(binds={BaseA: engine1, BaseB: engine2})</p>
</div></blockquote>
<p>以上，从 <code class="docutils literal notranslate"><span class="pre">BaseA</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BaseB</span></code> 派生的类将根据其来源父类（如果有的话）被路由到两个引擎之一。如果一个类从多个“绑定”超类派生，则将选择该目标类层次结构中最高的超类代表应使用的引擎。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.binds</span></code></p>
</div>
</section>
<section id="id38">
<h2>为多元引擎会话协调事务<a class="headerlink" href="#id38" title="Permalink to this heading">¶</a></h2>
<p>使用多个绑定引擎的一个警告是，在一个提交操作在一个后端成功提交之后，依然有可能在另一个后端中失败（译者注：即无法保证 ACID 特性中的 C 与 I）。这是一个不一致性问题，在关系型数据库中通过“两段事务”来解决，它向提交序列中添加了一个附加的“准备”步骤，以使多个数据库在实际完成事务之前就达成协议。</p>
<p>由于 DBAPI 的支持有限，SQLAlchemy 在跨多个后端使用两段事务方面的支持有限。通常，它已知可以在 PostgreSQL 后端上很好地使用，在 MySQL 后端上使用较小。但是，  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  完全能够利用后端支持时的两阶段事务特性，方法是将  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.use_twophase</span></code>  标志设置为   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  或   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中。请参见   <a class="reference internal" href="session_transaction.html#session-twophase"><span class="std std-ref">启用双阶段提交（two-phase commit）机制</span></a>  进行示例。</p>
</section>
<section id="session-custom-partitioning">
<span id="id39"></span><h2>自定义垂直分区<a class="headerlink" href="#session-custom-partitioning" title="Permalink to this heading">¶</a></h2>
<p>通过覆盖  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get_bind()</span></code>  方法可以构建更全面的基于规则的类级分区。以下我们将说明一种定制的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，它提供以下规则：</p>
<ol class="arabic">
<li><p>Flush 操作以及批量“update”和“delete”操作均在名为“leader”的引擎上接收。</p></li>
<li><p>所有子类为“MyOtherClass”的对象操作均发生在“other”引擎上。</p></li>
<li><p>所有其他类的读操作在“follower1”或“follower2”数据库的随机选择上执行。例如：</p>
<blockquote>
<div><p>engines = {
“leader”: create_engine(“sqlite:///leader.db”),
“other”: create_engine(“sqlite:///other.db”),
“follower1”: create_engine(“sqlite:///follower1.db”),
“follower2”: create_engine(“sqlite:///follower2.db”),
}</p>
<p>from sqlalchemy.sql import Update, Delete
from sqlalchemy.orm import Session, sessionmaker
import random</p>
<dl class="simple">
<dt>class RoutingSession(Session):</dt><dd><dl class="simple">
<dt>def get_bind(self, mapper=None, clause=None):</dt><dd><dl class="simple">
<dt>if mapper and issubclass(<a href="#id42"><span class="problematic" id="id43">mapper.class_</span></a>, MyOtherClass):</dt><dd><p>return engines[“other”]</p>
</dd>
<dt>elif self._flushing or isinstance(clause, (Update, Delete)):</dt><dd><p>return engines[“leader”]</p>
</dd>
<dt>else:</dt><dd><p>return engines[random.choice([“follower1”, “follower2”])]</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
<p>上面的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  类使用 <code class="docutils literal notranslate"><span class="pre">class_</span></code> 参数插入到   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  中：</p>
<blockquote>
<div><p>Session = sessionmaker(class_=RoutingSession)</p>
</div></blockquote>
<p>该方法与多个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象结合使用，类似于使用声明性 <code class="docutils literal notranslate"><span class="pre">__abstract__</span></code> 关键字的方法，如   <a class="reference internal" href="declarative_config.html#declarative-abstract"><span class="std std-ref">__abstract__</span></a>  中所述。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>上面的示例说明了如何基于重写  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get_bind()</span></code>  方法来将特定的 SQL 语句路由到所谓的“leader”或“follower”数据库上，根据语句是否期望写入数据来判断。但是，这似乎不是实际操作的最佳选择，因为它在读取和写入操作之间产生协调不一致。在实践中，最好根据正在进行的整体操作/事务构建   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，作为“读取”或“写入”会话，以进行一致性处理。这样，将写入数据的操作也会在统一的事务范围内发出它们的读取查询。请参见   <a class="reference internal" href="session_transaction.html#session-transaction-isolation-enginewide"><span class="std std-ref">为Sessionmaker / Engine Wide设置隔离</span></a>  中的示例，以获取使用自动提交连接设置一个 “只读” 操作的   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  和另一个会包含 :keyword: <cite>DML</cite> / COMMIT 操作的 “写入” 操作的配方。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/">SQLAlchemy 中的 Django 风格的数据库路由器</a>  - 博客文章介绍了  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get_bind()</span></code>  更全面的示例</p>
</div>
</section>
<section id="id40">
<h2>水平分区<a class="headerlink" href="#id40" title="Permalink to this heading">¶</a></h2>
<p>水平分区将单个表（或一组表）的行跨多个数据库进行分区。SQLAlchemy   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  包含这个概念的支持，但要想充分使用，需要使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  和   <a class="reference internal" href="queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  的子类。这些子类的基本版本可在   <span class="xref std std-ref">horizontal_sharding_toplevel</span>  中找到。使用示例请参见：  <a class="reference internal" href="examples.html#examples-sharding"><span class="std std-ref">水平分片</span></a> 。</p>
</section>
</section>
<section id="bulk-operations">
<span id="id41"></span><h1>批量操作<a class="headerlink" href="#bulk-operations" title="Permalink to this heading">¶</a></h1>
<div class="admonition legacy">
<p class="admonition-title">Legacy Feature</p>
<p>SQLAlchemy 2.0 把 “批量插入”和“批量更新”能力集成到 2.0 风格的  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  方法中，直接使用   <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>  和   <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Update" title="sqlalchemy.sql.expression.Update"><code class="xref py py-class docutils literal notranslate"><span class="pre">Update</span></code></a>  构造体。请参见文档  <a class="reference internal" href="queryguide/dml.html"><span class="doc">ORM-启用的INSERT、UPDATE和DELETE语句</span></a>  进行文档化，包括   <a class="reference internal" href="queryguide/dml.html#orm-queryguide-legacy-bulk-insert"><span class="std std-ref">Legacy Session 批量INSERT方法</span></a> ，其中说明了从旧方法迁移到新方法的步骤。</p>
</div>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="session_transaction.html" title="previous chapter">事务和连接管理</a>
        Next:
        <a href="contextual.html" title="next chapter">上下文/线程本地会话</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:44:00

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


