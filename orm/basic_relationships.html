<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    基本关系模式
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="关系配置" href="relationships.html" />
        <link rel="next" title="邻接列表关系" href="self_referential.html" />
        <link rel="prev" title="关系配置" href="relationships.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span><ul>
<li class="selected"><span class="link-container"><strong>基本关系模式</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id2">声明式与命令式形式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationship-patterns-o2m">一对多</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#relationship-patterns-o2m-collection">在一对多中使用集合、列表或其他集合类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">为一对多配置删除行为</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#relationship-patterns-m2o">多对一</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#relationship-patterns-nullable-m2o">可为空的多对一</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#relationships-one-to-one">一对一</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationships-many-to-many">多对多</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#many-to-many-table">从 Many to Many Table 中删除行</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#association-pattern">关联对象</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#association-pattern-w-m2m">将关联对象与多对多访问模式结合使用</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-relationship-eval">推迟计算关系参数</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id13">在声明之后将关系添加到映射类</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#secondary">使用延迟评估形式的多对多关系的“secondary”参数</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="self_referential.html">邻接列表关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="join_conditions.html">配置关系联接</a></span></li>
<li><span class="link-container"><a class="reference external" href="large_collections.html">操作大型集合</a></span></li>
<li><span class="link-container"><a class="reference external" href="collection_api.html">集合自定义和API详细信息</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationship_persistence.html">特殊关系的持久化模式</a></span></li>
<li><span class="link-container"><a class="reference external" href="backref.html">使用传统的“backref”关系参数</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationship_api.html">关系API</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="relationships.html" title="previous chapter">关系配置</a></li>
                <li><b>Next:</b>
                <a href="self_referential.html" title="next chapter">邻接列表关系</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="relationships.html" title="关系配置">关系配置</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#relationship-patterns">基本关系模式</a><ul>
<li><a class="reference internal" href="#id2">声明式与命令式形式</a></li>
<li><a class="reference internal" href="#relationship-patterns-o2m">一对多</a><ul>
<li><a class="reference internal" href="#relationship-patterns-o2m-collection">在一对多中使用集合、列表或其他集合类型</a></li>
<li><a class="reference internal" href="#id5">为一对多配置删除行为</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relationship-patterns-m2o">多对一</a><ul>
<li><a class="reference internal" href="#relationship-patterns-nullable-m2o">可为空的多对一</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relationships-one-to-one">一对一</a></li>
<li><a class="reference internal" href="#relationships-many-to-many">多对多</a><ul>
<li><a class="reference internal" href="#many-to-many-table">从 Many to Many Table 中删除行</a></li>
</ul>
</li>
<li><a class="reference internal" href="#association-pattern">关联对象</a><ul>
<li><a class="reference internal" href="#association-pattern-w-m2m">将关联对象与多对多访问模式结合使用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm-declarative-relationship-eval">推迟计算关系参数</a><ul>
<li><a class="reference internal" href="#id13">在声明之后将关系添加到映射类</a></li>
</ul>
</li>
<li><a class="reference internal" href="#secondary">使用延迟评估形式的多对多关系的“secondary”参数</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-basic_relationships" >
        
<section id="relationship-patterns">
<span id="id1"></span><h1>基本关系模式<a class="headerlink" href="#relationship-patterns" title="Permalink to this heading">¶</a></h1>
<p>这里简要介绍了基本的关系模式，并使用基于   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注解类型的   :ref:` Declarative &lt;orm_explicit_declarative_base&gt;`  样式映射来说明。</p>
<p>以下是每个部分的配置：</p>
<p>    from __future__ import annotations
    from typing import List</p>
<p>    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<section id="id2">
<h2>声明式与命令式形式<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>随着 SQLAlchemy 的不断发展，不同的 ORM 配置样式不断涌现。对于本节和其他使用注释的示例，应使用所需的类或字符串类名称作为传递给   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  的第一个参数。下面的示例说明了本文档中使用的表格的完全声明性示例，该示例使用了  :pep:` 484`  注释，并从   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注释派生目标类和集合类型，这是 SQLAlchemy 声明性映射的最新形式。</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Child”]] = relationship(back_populates=”parent”)</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        parent_id: Mapped[int] = mapped_column(ForeignKey(“parent_table.id”))
        parent: Mapped[“Parent”] = relationship(back_populates=”children”)</p>
<p>相比之下，使用没有注释的 Declarative 映射是映射的“经典”形式，其中   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  需要直接传递所有参数，如下面的示例所示：</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id = mapped_column(Integer, primary_key=True)
        children = relationship(“Child”, back_populates=”parent”)</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id = mapped_column(Integer, primary_key=True)
        parent_id = mapped_column(ForeignKey(“parent_table.id”))
        parent = relationship(“Parent”, back_populates=”children”)</p>
<p>最后，使用   <a class="reference internal" href="mapping_styles.html#orm-imperative-mapping"><span class="std std-ref">Imperative Mapping</span></a> ，即 SQLAlchemy 在实现 Declarative 之前的映射形式（尽管仍然是一部分用户首选的映射形式），上述配置如下所示：</p>
<p>    registry.map_imperatively(
        Parent,
        parent_table,
        properties={“children”: relationship(“Child”, back_populates=”parent”)},
    )</p>
<p>    registry.map_imperatively(
        Child,
        child_table,
        properties={“parent”: relationship(“Parent”, back_populates=”children”)},
    )</p>
<p>此外，未注释映射的默认集合样式是 <code class="docutils literal notranslate"><span class="pre">list</span></code>。要在没有注释的映射中使用 <code class="docutils literal notranslate"><span class="pre">set</span></code> 或其他集合，可以使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code>  参数指定。</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id = mapped_column(Integer, primary_key=True)
        children = relationship(“Child”, collection_class=set, …)</p>
<p>有关   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  的集合配置的详细信息请参见   :ref:` custom_collections` 。</p>
<p>在需要时注意注释和未注释/命令式样式之间的其他差异。</p>
</section>
<section id="relationship-patterns-o2m">
<span id="id3"></span><h2>一对多<a class="headerlink" href="#relationship-patterns-o2m" title="Permalink to this heading">¶</a></h2>
<p>一对多关系在子表上放置外键引用父表。在父项上指定   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  时，将其指定为引用由子项表示的项目集合:</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Child”]] = relationship()</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        parent_id: Mapped[int] = mapped_column(ForeignKey(“parent_table.id”))</p>
<p>为了在一对多中建立双向关系，其中“reverse”侧是多对一，可以指定一个额外的   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> ，并使用  :paramref:` _orm.relationship.back_populates`  参数将两个联系起来，对于每个   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> ，都是使用用于该另一个的  :paramref:` _orm.relationship.back_populates`  作为值属性名称。</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Child”]] = relationship(back_populates=”parent”)</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        parent_id: Mapped[int] = mapped_column(ForeignKey(“parent_table.id”))
        parent: Mapped[“Parent”] = relationship(back_populates=”children”)</p>
<p>“Child”将获得一个多对一语义的 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 属性。</p>
<section id="relationship-patterns-o2m-collection">
<span id="id4"></span><h3>在一对多中使用集合、列表或其他集合类型<a class="headerlink" href="#relationship-patterns-o2m-collection" title="Permalink to this heading">¶</a></h3>
<p>对于注释的 Declarative 映射，使用   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  中使用的集合类型派生   :func:` _orm.relationship`  的类型。可以使用``Mapped[Set[“Child”]]`` 来使用 <code class="docutils literal notranslate"><span class="pre">set</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">list</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 集合的集合类型。</p>
<p>当使用不包括注释的形式，包括命令式映射时，可以使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code>  参数传递要用作集合的 Python 类。</p>
<p>      <a class="reference internal" href="collection_api.html#custom-collections"><span class="std std-ref">定制集合访问</span></a>  - 包含了关于集合配置的进一步细节，包括一些将   :func:` _orm.relationship`  映射到字典的技巧。</p>
</section>
<section id="id5">
<h3>为一对多配置删除行为<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>通常情况下，当删除所属的“父项”时，所有 “Child” 对象都应被删除。为了配置此行为，将使用在   <a class="reference internal" href="cascades.html#cascade-delete"><span class="std std-ref">delete</span></a>  中描述的“删除”级联选项。还有一个额外的选项，即当将“Child”对象与其父对象断开连接时，可以删除“Child”对象本身。此行为在   :ref:` cascade_delete_orphan`  中描述。</p>
<p>      <a class="reference internal" href="cascades.html#cascade-delete"><span class="std std-ref">delete</span></a></p>
<p>      <a class="reference internal" href="cascades.html#passive-deletes"><span class="std std-ref">在 ORM 关系中使用 FOREIGN KEY ON DELETE 级联</span></a></p>
<p>      <a class="reference internal" href="cascades.html#cascade-delete-orphan"><span class="std std-ref">delete-orphan</span></a></p>
</section>
</section>
<section id="relationship-patterns-m2o">
<span id="id6"></span><h2>多对一<a class="headerlink" href="#relationship-patterns-m2o" title="Permalink to this heading">¶</a></h2>
<p>多对一在父表中放置一个外键引用子表。在父项上声明   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> ，其中将创建一个新的标量保持属性:</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        child_id: Mapped[int] = mapped_column(ForeignKey(“child_table.id”))
        child: Mapped[“Child”] = relationship()</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)</p>
<p>上面的示例显示了一个假定非空行为的多对一关系；下一节，  <a class="reference internal" href="#relationship-patterns-nullable-m2o"><span class="std std-ref">可为空的多对一</span></a>  展示了可为空版本。</p>
<p>通过添加第二个   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  并使用  :paramref:` _orm.relationship.back_populates`  参数在两个方向上连接两个   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> ，即可实现双向行为。即对于每个   :func:` _orm.relationship`  都使用另一个的  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code>  作为属性名的值。</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        child_id: Mapped[int] = mapped_column(ForeignKey(“child_table.id”))
        child: Mapped[“Child”] = relationship(back_populates=”parents”)</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        parents: Mapped[List[“Parent”]] = relationship(back_populates=”child”)</p>
<section id="relationship-patterns-nullable-m2o">
<span id="id7"></span><h3>可为空的多对一<a class="headerlink" href="#relationship-patterns-nullable-m2o" title="Permalink to this heading">¶</a></h3>
<p>在上面的示例中，<code class="docutils literal notranslate"><span class="pre">Parent.child</span></code> 关系未指定是否允许 <code class="docutils literal notranslate"><span class="pre">None</span></code>；这是因为 <code class="docutils literal notranslate"><span class="pre">Parent.child_id</span></code> 列本身不可为空，因为它被标记为 <code class="docutils literal notranslate"><span class="pre">Mapped[int]</span></code>。如果我们想让 <code class="docutils literal notranslate"><span class="pre">Parent.child</span></code> 成为可为空的多对一，可以将 <code class="docutils literal notranslate"><span class="pre">Parent.child_id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Parent.child</span></code> 都设置为 <code class="docutils literal notranslate"><span class="pre">Optional[]</span></code>，这种情况下的配置如下所示:</p>
<p>    from typing import Optional</p>
<p>    class Parent(Base):
        __tablename__ = “parent_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        child_id: Mapped[Optional[int]] = mapped_column(ForeignKey(“child_table.id”))
        child: Mapped[Optional[“Child”]] = relationship(back_populates=”parents”)</p>
<p>    class Child(Base):
        __tablename__ = “child_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        parents: Mapped[List[“Parent”]] = relationship(back_populates=”child”)</p>
<p>在上面的示例中，<code class="docutils literal notranslate"><span class="pre">Parent.child_id</span></code> 的列将被创建为允许 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 值的 DDL。使用显示类型声明的   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  时，指定 ` <cite>child_id: Mapped[Optional[int]]`</cite> 等效于将  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.nullable" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.nullable</span></code></a>  设置为 ` <cite>True`</cite> on the   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> ，而` <cite>child_id: Mapped[int]`</cite> 等效于将其设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。有关此本文的详细信息，请参见   <a class="reference internal" href="declarative_tables.html#orm-declarative-mapped-column-nullability"><span class="std std-ref">mapped_column() 从 Mapped 注释中派生类型和可空性</span></a> 。</p>
<p>  如果使用 Python 3.10 或更高版本，则使用  <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0604/"><strong>PEP 604</strong></a>  语法使用` <cite>| None`</cite> 指示可选类型更为方便，结合  <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>  延迟注释评估使得不需要使用字符串引用类型，如下所示:</p>
<p>     from __future__ import annotations</p>
<p>     class Parent(Base):
         __tablename__ = “parent_table”</p>
<p>         id: Mapped[int] = mapped_column(primary_key=True)
         child_id: Mapped[int | None] = mapped_column(ForeignKey(“child_table.id”))
         child: Mapped[Child | None] = relationship(back_populates=”parents”)</p>
<p>     class Child(Base):
         __tablename__ = “child_table”</p>
<p>         id: Mapped[int] = mapped_column(primary_key=True)
         parents: Mapped[List[Parent]] = relationship(back_populates=”child”)</p>
</section>
</section>
<section id="relationships-one-to-one">
<span id="id8"></span><h2>一对一<a class="headerlink" href="#relationships-one-to-one" title="Permalink to this heading">¶</a></h2>
<p>一对一本质上是一对多   <a class="reference internal" href="#relationship-patterns-o2m"><span class="std std-ref">一对多</span></a>  关系从外键的角度来看，但表明在任何时候只有一个行引用特定的父行。</p>
<p>当使用注释映射和  <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注释，这将暗示 ORM 不应在任何一侧上使用集合。下面的示例说明了一种新的类 ` <cite>Association`</cite>，它映射到名为``association`` 的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> ；这个表现在现在包括了一个名叫` <cite>extra_data`</cite> 的额外的列，它是一个字符串值，存储在每个``Parent`` 和 <code class="docutils literal notranslate"><span class="pre">Child</span></code> 之间的关联中。通过将表映射到显式类，来自 <code class="docutils literal notranslate"><span class="pre">Parent`</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Child</span></code> 的 rudimental 访问将明确地使用 <code class="docutils literal notranslate"><span class="pre">Association</span></code> 方式:</p>
<p>    from typing import Optional</p>
<p>    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<p>    class Association(Base):
        __tablename__ = “association_table”
        left_id: Mapped[int] = mapped_column(ForeignKey(“left_table.id”), primary_key=True)
        right_id: Mapped[int] = mapped_column(
            ForeignKey(“right_table.id”), primary_key=True
        )
        extra_data: Mapped[Optional[str]]
        child: Mapped[“Child”] = relationship()</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”
        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Association”]] = relationship()</p>
<p>    class Child(Base):
        __tablename__ = “right_table”
        id: Mapped[int] = mapped_column(primary_key=True)</p>
<p>为了示例双向版本，我们本文中添加了两个   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> ，并使用  :paramref:` _orm.relationship.back_populates`  将其与现有定义链接:</p>
<p>    from typing import Optional</p>
<p>    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<p>    class Association(Base):
        __tablename__ = “association_table”
        left_id: Mapped[int] = mapped_column(ForeignKey(“left_table.id”), primary_key=True)
        right_id: Mapped[int] = mapped_column(
            ForeignKey(“right_table.id”), primary_key=True
        )
        extra_data: Mapped[Optional[str]]
        child: Mapped[“Child”] = relationship(back_populates=”parents”)
        parent: Mapped[“Parent”] = relationship(back_populates=”children”)</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”
        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Association”]] = relationship(back_populates=”parent”)</p>
<p>    class Child(Base):
        __tablename__ = “right_table”
        id: Mapped[int] = mapped_column(primary_key=True)
        parents: Mapped[List[“Association”]] = relationship(back_populates=”child”)</p>
<p>在其直接形式中使用关联对象模式需要在向父项追加子项之前将子项与关联实例相关联；类似地，从父项到子项的访问通过关联对象。</p>
<p>     # 创建父项，通过关联附加子项a = Association()
    a.extra_data = “some data”
    a.child = Child()
    p.children.append(a)</p>
<p>    #通过关联项迭代子项对象，包括关联特性
    for assoc in p.children：
        print(assoc.extra_data)
        print(assoc.child)
为了使直接访问 <code class="docutils literal notranslate"><span class="pre">Association</span></code> 对象是可选的，SQLAlchemy 提供了   <span class="xref std std-ref">associationproxy_toplevel</span>  扩展。此扩展允许配置属性，这些属性将使用单个访问器访问两个“跳跃”，一个跳跃到关联对象，另一个跳跃到目标属性。</p>
</section>
<section id="relationships-many-to-many">
<span id="id9"></span><h2>多对多<a class="headerlink" href="#relationships-many-to-many" title="Permalink to this heading">¶</a></h2>
<p>多对多在两个类之间添加一个关联表。协会表通常是一个核心   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象或其他的 Core Selectable，例如   :class:` _sql.Join`  对象，并通过  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code>  参数指示，通常，   :class:` _schema.Table`  使用与声明基类关联的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象，以便   :class:` _schema.ForeignKey`  指令可以定位要链接的远程表：</p>
<p>    from __future__ import annotations</p>
<p>    from sqlalchemy import Column
    from sqlalchemy import Table
    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<p>    # note for a Core table, we use the sqlalchemy.Column construct,
    # not sqlalchemy.orm.mapped_column
    association_table = Table(
        “association_table”,
        Base.metadata,
        Column(“left_id”, ForeignKey(“left_table.id”)),
        Column(“right_id”, ForeignKey(“right_table.id”)),
    )</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[Child]] = relationship(secondary=association_table)</p>
<p>    class Child(Base):
        __tablename__ = “right_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)</p>
<p>为了建立双向关系，两个   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  都包含集合。使用  :paramref:` _orm.relationship.back_populates`  ，并为每个微博具体指定一个公共关联表。</p>
<p>    from __future__ import annotations</p>
<p>    from sqlalchemy import Column
    from sqlalchemy import Table
    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<p>    association_table = Table(
        “association_table”,
        Base.metadata,
        Column(“left_id”, ForeignKey(“left_table.id”), primary_key=True),
        Column(“right_id”, ForeignKey(“right_table.id”), primary_key=True),
    )</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[Child]] = relationship(
            secondary=association_table, back_populates=”parents”
        )</p>
<p>    class Child(Base):
        __tablename__ = “right_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        parents: Mapped[List[Parent]] = relationship(
            secondary=association_table, back_populates=”children”
        )</p>
<p>在 Many to Many 关系的配置中，集合的配置与   <a class="reference internal" href="#relationship-patterns-o2m"><span class="std std-ref">一对多</span></a>  完全相同，如在   :ref:` relationship_patterns_o2m_collection`  中所述。对于使用   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  的注释映射，可以通过在   :class:` _orm.Mapped`  通用类中使用的集合类型指示集合，例如 <code class="docutils literal notranslate"><span class="pre">set</span></code>，来指示集合。:</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”</p>
<p>        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[Set[“Child”]] = relationship(secondary=association_table)</p>
<p>使用不包括注释的形式，包括命令式映射时，与 one-to-many 相同，可以使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code>  参数传递用作集合的 Python 类。</p>
<p>      <a class="reference internal" href="collection_api.html#custom-collections"><span class="std std-ref">定制集合访问</span></a>  - 包含了关于集合配置的进一步细节，包括一些将   :func:` _orm.relationship`  映射到字典的技巧。</p>
<section id="many-to-many-table">
<span id="relationships-many-to-many-deletion"></span><h3>从 Many to Many Table 中删除行<a class="headerlink" href="#many-to-many-table" title="Permalink to this heading">¶</a></h3>
<p>对于  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code>  参数用于   :func:` _orm.relationship`  所特有的行为，是   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  自动受到 INSERT 和 DELETE 语句的影响，因为将对象添加或删除到集合中。无需手动从该表中删除。删除集合中的记录将导致在 flush 时删除行：</p>
<p>    # 行将自动从“secondary”表中删除
    myparent.children.remove(somechild)</p>
<p>一个经常出现的问题是在直接传递给  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code>  的` <cite>Child`</cite> 对象时，如何删除“secondary”表中的行：</p>
<p>    session.delete(somechild)</p>
<p>这里有几种可能性：</p>
<ul class="simple">
<li><p>如果从 <code class="docutils literal notranslate"><span class="pre">Parent</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Child</span></code> 存在   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> ，但不存在将特定` <cite>Child`</cite> 链接到每个 <code class="docutils literal notranslate"><span class="pre">Parent</span></code> 的反向关系，则 SQLAlchemy 将不会注意到在删除此特定``Child`` 对象时，它需要维护将其与``Parent <code class="docutils literal notranslate"><span class="pre">相关联的“secondary”表。不会删除“secondary”表。*</span> <span class="pre">如果存在将特定</span> <span class="pre">``Child</span></code> 链接到每个``Parent`` 的关系，假设它称为``Child.parents``，SQLAlchemy 默认情况下会加载 <code class="docutils literal notranslate"><span class="pre">Child.parents</span></code> 集合以定位所有 <code class="docutils literal notranslate"><span class="pre">Parent</span></code> 对象，并从链接此关系的“secondary”表中删除每行。请注意，此关系不需要是双向的；SQLAlchemy 仅在严格查看与要删除的``Child`` 对象相关联的每个   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  上。* 在此处使用更高效的方法是使用 ON DELETE CASCADE 指令与数据库使用的外键。假设数据库支持此功能，则可以让数据库本身在引用“child”被删除时自动删除“secondary”表中的行。使用  :paramref:` _orm.relationship.passive_deletes`  在这种情况下指示 SQLAlchemy 放弃主动加载``Child.parents`` 集合。有关此功能的详细信息，请参见   <a class="reference internal" href="cascades.html#passive-deletes"><span class="std std-ref">在 ORM 关系中使用 FOREIGN KEY ON DELETE 级联</span></a> 。</p></li>
</ul>
<p>请注意，这些行为仅与   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  的  :paramref:` _orm.relationship.secondary`  选项相关。如果处理显式映射并且不存在于相关   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  的  :paramref:` _orm.relationship.secondary`  选项中的协会表，可以使用级联规则代替以自动删除与相关实体相关的实体 - 请参阅   <a class="reference internal" href="cascades.html#unitofwork-cascades"><span class="std std-ref">级联操作</span></a>  了解有关此功能的详细信息。</p>
<p>      <a class="reference internal" href="cascades.html#cascade-delete-many-to-many"><span class="std std-ref">在多对多关系中使用 delete 级联</span></a></p>
<p>      <a class="reference internal" href="cascades.html#passive-deletes-many-to-many"><span class="std std-ref">关于基于 foreign key 的 ON DELETE 和多对多关系</span></a></p>
</section>
</section>
<section id="association-pattern">
<span id="id10"></span><h2>关联对象<a class="headerlink" href="#association-pattern" title="Permalink to this heading">¶</a></h2>
<p>关联对象模式是从多对多变体中提取出来的：当关联表包含除父表和子（或左和右）表之外的其他列时，最理想的情况是将这些列映射到自己的 ORM 映射类。映射的类会映射到在使用多对多模式时通常会指出的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  上。在关联对象模式中，不使用  :paramref:` _orm.relationship.secondary`  参数；相反，将一个类直接映射到联合表。然后使用两个单独的   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  建立第一个由一个到多个的父项的链接到映射关联类，接着映射关联类到子项的多对一关系，以形成从父项到关联，再到子项的单向关联对象关系。对于双向关系，需要四个   :func:` _orm.relationship`  将关联映射类与父项和子项在两个方向上链接起来。</p>
<p>下面的示例说明了一个新类``Association``，它映射到名为 <code class="docutils literal notranslate"><span class="pre">association</span></code> 的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> ；现在，这个表包括一个名为` <cite>extra_data`</cite> 的附加列，它是一个字符串值，与``Parent`` 和``Child`` 之间的每个关联一起存储。将表映射到显式类，也可以从``Parent`` 到``Child`` 的访问，明确使用``Association``：：</p>
<p>    from typing import Optional</p>
<p>    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<p>    class Association(Base):
        __tablename__ = “association_table”
        left_id: Mapped[int] = mapped_column(ForeignKey(“left_table.id”), primary_key=True)
        right_id: Mapped[int] = mapped_column(
            ForeignKey(“right_table.id”), primary_key=True
        )
        extra_data: Mapped[Optional[str]]
        child: Mapped[“Child”] = relationship()</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”
        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Association”]] = relationship()</p>
<p>    class Child(Base):
        __tablename__ = “right_table”
        id: Mapped[int] = mapped_column(primary_key=True)</p>
<p>为了说明双向版本，我们需要使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code> ，并使用现有的定义将 Grouped_Association_Class 链接到它们当中的每个父项和子项。:</p>
<p>    from typing import Optional</p>
<p>    from sqlalchemy import ForeignKey
    from sqlalchemy import Integer
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import relationship</p>
<p>    class Base(DeclarativeBase):
        pass</p>
<p>    class Association(Base):
        __tablename__ = “association_table”
        left_id: Mapped[int] = mapped_column(ForeignKey(“left_table.id”), primary_key=True)
        right_id: Mapped[int] = mapped_column(
            ForeignKey(“right_table.id”), primary_key=True
        )
        extra_data: Mapped[Optional[str]]
        child: Mapped[“Child”] = relationship(back_populates=”parents”)
        parent: Mapped[“Parent”] = relationship(back_populates=”children”)</p>
<p>    class Parent(Base):
        __tablename__ = “left_table”
        id: Mapped[int] = mapped_column(primary_key=True)
        children: Mapped[List[“Association”]] = relationship(back_populates=”parent”)</p>
<p>    class Child(Base):
        __tablename__ = “right_table”
        id: Mapped[int] = mapped_column(primary_key=True)
        parents: Mapped[List[“Association”]] = relationship(back_populates=”child”)</p>
<p>在关联模式下的工作，要求必须在附加到父项之前将子项与关联实例相关联，反之亦然；类似地，从父项到子项的访问将通过关联对象。</p>
<p>    #创建操作,通过关联附加子项。
    p = Parent()
    a = Association(extra_data=”some data”)
    a.child = Child()
    p.children.append(a)</p>
<p>    # 通过关联项迭代子项对象,包括关联属性
    for assoc in p.children:
        print(assoc.extra_data)
        print(assoc.child)</p>
<p>要增强关联对象模式，以使直接访问 <code class="docutils literal notranslate"><span class="pre">Association</span></code> 对象是可选的，SQLAlchemy 提供了   <span class="xref std std-ref">associationproxy_toplevel</span>  扩展。此扩展允许配置属性，这些属性将使用单个访问器访问两个“跳跃”，一个跳跃到关联对象，另一个跳跃到目标属性。.. seealso:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="p">:</span><span class="n">ref</span><span class="p">:</span><span class="err">`</span><span class="n">associationproxy_toplevel</span><span class="err">`</span>  <span class="o">-</span> <span class="n">允许一种直接的</span><span class="err">“</span><span class="n">多对多</span><span class="err">”</span><span class="n">样式</span>
<span class="n">的访问方式</span><span class="err">，</span><span class="n">通过父对象和子对象关联实现三类关联对象映射</span><span class="err">。</span></pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>避免将关联对象模式与   <a class="reference internal" href="#relationships-many-to-many"><span class="std std-ref">many-to-many</span></a>  模式直接混合使用，
因为这会导致数据读取和写入不一致（除非采取特殊措施）；</p>
<blockquote>
<div><p><span class="xref std std-ref">association proxy</span>  通常用于提供更简洁的访问。</p>
</div></blockquote>
<p>关于此组合带来的注意事项的更详细背景，请参见下一节   <a class="reference internal" href="#association-pattern-w-m2m"><span class="std std-ref">将关联对象与多对多访问模式结合使用</span></a> 。</p>
</div>
<section id="association-pattern-w-m2m">
<span id="id11"></span><h3>将关联对象与多对多访问模式结合使用<a class="headerlink" href="#association-pattern-w-m2m" title="Permalink to this heading">¶</a></h3>
<p>如前一节所述，关联对象模式不会自动集成到多对多模式上。
由此产生的结果是，读操作可能会返回冲突的数据，写操作也可能会尝试刷新冲突的更改，
导致完整性错误或意外的插入或删除操作。</p>
<p>为了说明这一点，下面的示例通过 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Child.parents</span></code> 之间的双向多对多关系
以及 <code class="docutils literal notranslate"><span class="pre">Parent.child_associations</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Association.child</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Child.parent_associations</span></code>
之间的关联对象关系来配置模型映射：</p>
<blockquote>
<div><p>from typing import Optional</p>
<p>from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import relationship</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Association(Base):</dt><dd><p>__tablename__ = “association_table”</p>
<p>left_id: Mapped[int] = mapped_column(ForeignKey(“left_table.id”), primary_key=True)
right_id: Mapped[int] = mapped_column(</p>
<blockquote>
<div><p>ForeignKey(“right_table.id”), primary_key=True</p>
</div></blockquote>
<p>)
extra_data: Mapped[Optional[str]]</p>
<p># Association -&gt; Child 之间的关联关系
child: Mapped[“Child”] = relationship(back_populates=”parent_associations”)</p>
<p># Association -&gt; Parent 之间的关联关系
parent: Mapped[“Parent”] = relationship(back_populates=”child_associations”)</p>
</dd>
<dt>class Parent(Base):</dt><dd><p>__tablename__ = “left_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)</p>
<p># 到Child 的多对多关系，绕过了 <cite>Association</cite> 类
children: Mapped[List[“Child”]] = relationship(</p>
<blockquote>
<div><p>secondary=”association_table”, back_populates=”parents”</p>
</div></blockquote>
<p>)</p>
<p># Parent -&gt; Association -&gt; Child 之间的关联关系
child_associations: Mapped[List[“Association”]] = relationship(</p>
<blockquote>
<div><p>back_populates=”parent”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class Child(Base):</dt><dd><p>__tablename__ = “right_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)</p>
<p># 到Parent 的多对多关系，绕过了 <cite>Association</cite> 类
parents: Mapped[List[“Parent”]] = relationship(</p>
<blockquote>
<div><p>secondary=”association_table”, back_populates=”children”</p>
</div></blockquote>
<p>)</p>
<p># Child -&gt; Association -&gt; Parent 之间的关联关系
parent_associations: Mapped[List[“Association”]] = relationship(</p>
<blockquote>
<div><p>back_populates=”child”</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>在使用此 ORM 模型进行更改操作时，对 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 进行的更改不会与 Python 中对 <code class="docutils literal notranslate"><span class="pre">Parent.child_associations</span></code>
或 <code class="docutils literal notranslate"><span class="pre">Child.parent_associations</span></code> 进行的更改进行协调；
虽然所有这些关系将继续正常运行，但是对一个的更改将不会出现在另一个中，
直到   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  过期，这通常在  :meth:` .Session.commit`  后自动发生。</p>
<p>此外，如果进行冲突的更改，例如同时添加一个新的 <code class="docutils literal notranslate"><span class="pre">Association</span></code> 对象，
同时将相同的关联 <code class="docutils literal notranslate"><span class="pre">Child</span></code> 添加到 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 中，那么当工作单元的刷新过程进行时，
例如以下示例，将会导致完整性错误：</p>
<blockquote>
<div><p>p1 = Parent()
c1 = Child()
p1.children.append(c1)</p>
<p># 冗余，将在 Association 上引发重复的 INSERT
p1.child_associations.append(Association(child=c1))</p>
</div></blockquote>
<p>直接将 <code class="docutils literal notranslate"><span class="pre">Child</span></code> 添加到 <code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 还意味着在 <code class="docutils literal notranslate"><span class="pre">association</span></code> 表中创建行，而不指示
<code class="docutils literal notranslate"><span class="pre">association.extra_data</span></code> 列的任何值，其将接收其值为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的值。</p>
<p>如果知道自己在做什么，就可以使用上述映射；在以下情况下，
可能有充分理由使用多对多关系，即在使用“关联对象”模式不频繁的情况下，
在单个多对多关系中加载关系更容易，这也可以优化使用 SQL 语句中的“secondary”表稍微好一些，
而不是使用两个到显式关联类的单独关系。即使在经过谨慎组织以避免过时读取的代码访问多对多集合的情况下，
使用关联对象关系也可能是可行的，甚至可以在极端情况下直接使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expire()</span></code>
来导致集合在当前事务中被刷新。上述模式的一个受欢迎的替代方案是使用直接的多对多
<code class="docutils literal notranslate"><span class="pre">Parent.children</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Child.parents</span></code> 关系的扩展，该扩展将透明地代理
通过“Association”类，同时从 ORM 的角度保持一切一致。此扩展称为   <span class="xref std std-ref">Association Proxy</span> 。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><span class="xref std std-ref">associationproxy_toplevel</span>  - 允许一种直接的“多对多”样式</p>
</div></blockquote>
<p>的访问方式，通过父对象和子对象关联实现三类关联对象映射。</p>
</div>
</section>
</section>
<section id="orm-declarative-relationship-eval">
<span id="id12"></span><h2>推迟计算关系参数<a class="headerlink" href="#orm-declarative-relationship-eval" title="Permalink to this heading">¶</a></h2>
<p>前面几节中的大多数示例说明了映射如何使用字符串名称引用其目标类，
而不是实际的类本身，例如在使用 ：class:<cite>_orm.Mapped</cite> 时，将生成一个前向引用，
它仅在运行时作为字符串存在：</p>
<blockquote>
<div><dl>
<dt>class Parent(Base):</dt><dd><p># …</p>
<p>children: Mapped[List[“Child”]] = relationship(back_populates=”parent”)</p>
</dd>
<dt>class Child(Base):</dt><dd><p># …</p>
<p>parent: Mapped[“Parent”] = relationship(back_populates=”children”)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>同样，当使用非注释形式时，如非注释性 Declarative 或 Imperative 映射，</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  结构也支持字符串名称直接传递给主类参数：</p>
<blockquote>
<div><dl class="simple">
<dt>registry.map_imperatively(</dt><dd><p>Parent,
parent_table,
properties={“children”: relationship(“Child”, back_populates=”parent”)},</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
<p>对于除了主要参数之外的其他参数，如果它们依赖于尚未定义的类上的列，
则也可以指定字符串，这些字符串可能作为 Python 函数或更常见的是字符串进行调用。
对于这些参数中除主要参数外的大多数参数，除主要参数外的字符串输入
与   <code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code>  函数一起用于 <strong>以 Python 表达式的形式进行评估</strong>，
因为它们意图接收完整的 SQL 表达式。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>由于 Python 的 <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 函数用于解释传递给   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  的
对字符串的评估，因此这些参数 <strong>不应从事接收不可信用户输入的重用</strong>；
<code class="docutils literal notranslate"><span class="pre">eval()</span></code> 对不受信任的用户输入 <strong>不安全</strong>。</p>
</div>
<p>可以在此评估中使用的完整命名空间包括为此声明基本映射的所有类，
以及 <code class="docutils literal notranslate"><span class="pre">sqlalchemy</span></code> 包的内容，包括表达式函数，例如   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.desc" title="sqlalchemy.sql.expression.desc"><code class="xref py py-func docutils literal notranslate"><span class="pre">desc()</span></code></a>  和  :attr:` _functions.func` ：</p>
<blockquote>
<div><dl>
<dt>class Parent(Base):</dt><dd><p># …</p>
<dl class="simple">
<dt>children: Mapped[List[“Child”]] = relationship(</dt><dd><p>order_by=”desc(Child.email_address)”,
primaryjoin=”Parent.id == Child.parent_id”,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>在存在多个模块中具有相同名称的类的情况下，字符串类名称也可以在其中任何一个字符串表达式内
指定为模块限定路径：</p>
<blockquote>
<div><dl>
<dt>class Parent(Base):</dt><dd><p># …</p>
<dl class="simple">
<dt>children: Mapped[List[“myapp.mymodel.Child”]] = relationship(</dt><dd><p>order_by=”desc(myapp.mymodel.Child.email_address)”,
primaryjoin=”myapp.mymodel.Parent.id == myapp.mymodel.Child.parent_id”,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，可以通过直接将类位置字符串传递到  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.argument</span></code>
中来通过名称消除二义性。下面展示了对 <code class="docutils literal notranslate"><span class="pre">Child</span></code> 的类型仅为导入的示例，与
将运行时指示符与查找正确名称的目标类相结合。</p>
<blockquote>
<div><p>import typing</p>
<dl>
<dt>if typing.TYPE_CHECKING:</dt><dd><p>from myapp.mymodel import Child</p>
</dd>
<dt>class Parent(Base):</dt><dd><p># …</p>
<dl class="simple">
<dt>children: Mapped[List[“Child”]] = relationship(</dt><dd><p>“myapp.mymodel.Child”,
order_by=”desc(myapp.mymodel.Child.email_address)”,
primaryjoin=”myapp.mymodel.Parent.id == myapp.mymodel.Child.parent_id”,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>限定路径可以是任何消除名称之间歧义的部分路径。例如，为了消除
<code class="docutils literal notranslate"><span class="pre">myapp.model1.Child</span></code> 和 <code class="docutils literal notranslate"><span class="pre">myapp.model2.Child</span></code> 之间的二义性，
我们可以指定 <code class="docutils literal notranslate"><span class="pre">model1.Child</span></code> 或 <code class="docutils literal notranslate"><span class="pre">model2.Child</span></code>：</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>class Parent(Base):</dt><dd><p># …</p>
<dl class="simple">
<dt>children: Mapped[List[“Child”]] = relationship(</dt><dd><p>“model1.Child”,
order_by=”desc(mymodel1.Child.email_address)”,
primaryjoin=”Parent.id == model1.Child.parent_id”,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  结构也接受 Python 函数或 lambda 表达式作为这些参数的输入。</p>
</div></blockquote>
<p>Python 函数的方法可能如下所示：</p>
<blockquote>
<div><p>import typing</p>
<p>from sqlalchemy import desc</p>
<dl>
<dt>if typing.TYPE_CHECKING:</dt><dd><p>from myapplication import Child</p>
</dd>
<dt>def _resolve_child_model():</dt><dd><p>from myapplication import Child</p>
<p>return Child</p>
</dd>
<dt>class Parent(Base):</dt><dd><p># …</p>
<dl class="simple">
<dt>children: Mapped[List[“Child”]] = relationship(</dt><dd><p>_resolve_child_model,
order_by=lambda: desc(_resolve_child_model().email_address),
primaryjoin=lambda: Parent.id == _resolve_child_model().parent_id,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>可以将 Python 函数或 lambda 表达式作为这些参数的输入的完整列表是：</p>
<ul class="simple">
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.order_by</span></code></p></li>
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.primaryjoin</span></code></p></li>
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondaryjoin</span></code></p></li>
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code></p></li>
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.remote_side</span></code></p></li>
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.foreign_keys</span></code></p></li>
<li><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship._user_defined_foreign_keys</span></code></p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>正如前面所述，属性中将这些参数传递给   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>
<strong>使用 eval() 函数将其作为 Python 代码表达式进行评估。不要将未经检查的输入传递给这些参数。</strong></p>
</div>
<section id="id13">
<h3>在声明之后将关系添加到映射类<a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h3>
<p>需要注意的是，在与   <span class="xref std std-ref">orm_declarative_table_adding_columns</span>  中描述的方式类似，
可以在任何时候将   <a class="reference internal" href="internals.html#sqlalchemy.orm.MapperProperty" title="sqlalchemy.orm.MapperProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapperProperty</span></code></a>  结构添加到声明式基础映射中，
但是：class:<cite>_orm.Mapped</cite> 注释类型在这种情况下不支持；因此，必须直接在   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>
构造中将相关类指定为类本身、类名称的字符串或返回指向目标类的引用的可调用函数。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>与 ORM 映射列一样，如果映射了类且要将映射化的列分配给已映射的类，
则只有在使用“声明性基础”类时将可以正常工作，
表示用户定义的   <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code>  子类或由   :func:` _orm.declarative_base`
或  <code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.generate_base()</span></code>  返回的动态生成的类。
此“基础”类包括 Python 元类，该元类实现了一个特殊的 <code class="docutils literal notranslate"><span class="pre">__setattr__()</span></code> 方法，
该方法截取了这些操作。</p>
<p>如果使用像  <code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.mapped()</span></code>  或类似的声明性映射或命令式函数
（例如  <code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.map_imperatively()</span></code> ）中的装饰器映射映射了类，
则无法对映射的类进行运行时属性分配。</p>
</div>
</section>
</section>
<section id="secondary">
<span id="orm-declarative-relationship-secondary-eval"></span><h2>使用延迟评估形式的多对多关系的“secondary”参数<a class="headerlink" href="#secondary" title="Permalink to this heading">¶</a></h2>
<p>多对多关系使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code>  参数，
该参数通常指向一个通常非映射的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象或其他 Core 可选择对象。
支持使用 lambda 可调用或字符串名称进行延迟评估，
其中字符串解析通过使用 Python 表达式将标识符名称链接到同名   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象来完成，
这些对象存在于当前经向某个   <code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code>  映射的   :class:` _schema.MetaData`  集合中。</p>
<dl class="simple">
<dt>例如，在   <a class="reference internal" href="#relationships-many-to-many"><span class="std std-ref">多对多</span></a>  中给出的示例中，如果我们假设 ` <cite>association_table`</cite></dt><dd><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象定义在映射类本身之后的一点处，我们可以使用 lambda 写入   :func:` _orm.relationship` ，</p>
</dd>
</dl>
<p>例如：</p>
<blockquote>
<div><dl>
<dt>class Parent(Base):</dt><dd><p>__tablename__ = “left_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
children: Mapped[List[“Child”]] = relationship(</p>
<blockquote>
<div><p>“Child”, secondary=lambda: association_table</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>或者，以名称定位相同的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象，然后将名称作为参数使用。
从 Python 的角度讲，这是一个字符串表达式，在此表达式的 Python 环境中，标识符名称链接到
当前   <code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code>  指向的   :class:` _schema.MetaData`  集合中的表的名称：</p>
<blockquote>
<div><dl>
<dt>class Parent(Base):</dt><dd><p>__tablename__ = “left_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
children: Mapped[List[“Child”]] = relationship(secondary=”association_table”)</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<dl class="simple">
<dt>当作为字符串传递时，</dt><dd><p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code>  参数使用 Python 的 ` <cite>eval()`</cite> 函数进行解析，</p>
</dd>
</dl>
<p>即使该字符串通常是表的名称。
<strong>不要将不可信用户输入传递给此字符串</strong>。</p>
</div>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="relationships.html" title="previous chapter">关系配置</a>
        Next:
        <a href="self_referential.html" title="next chapter">邻接列表关系</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:58:53

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


