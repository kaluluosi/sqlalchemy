<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    映射类继承层次结构
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="ORM映射类配置" href="mapper_config.html" />
        <link rel="next" title="非传统映射" href="nonstandard_mappings.html" />
        <link rel="prev" title="复合列类型" href="composites.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span><ul>
<li><span class="link-container"><a class="reference external" href="mapping_styles.html">ORM映射类概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mapping.html">通过声明性方式映射类</a></span></li>
<li><span class="link-container"><a class="reference external" href="dataclasses.html">与dataclasses和attrs集成</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_sql_expr.html">将SQL表达式映射为属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_attributes.html">更改属性行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="composites.html">复合列类型</a></span></li>
<li class="selected"><span class="link-container"><strong>映射类继承层次结构</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#joined-inheritance">联结表继承</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id4">联结继承中的关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">联结继承映射的加载</a></span></li>
<li><span class="link-container"><a class="reference external" href="#concrete-polymorphic">具体多态加载配置</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="nonstandard_mappings.html">非传统映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="versioning.html">配置版本计数器</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapping_api.html">类映射API</a></span></li>
<li><span class="link-container"><a class="reference external" href="scalar_mapping.html">映射SQL表达式</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="composites.html" title="previous chapter">复合列类型</a></li>
                <li><b>Next:</b>
                <a href="nonstandard_mappings.html" title="next chapter">非传统映射</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="mapper_config.html" title="ORM映射类配置">ORM映射类配置</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">映射类继承层次结构</a><ul>
<li><a class="reference internal" href="#joined-inheritance">联结表继承</a><ul>
<li><a class="reference internal" href="#id4">联结继承中的关系</a></li>
<li><a class="reference internal" href="#id5">联结继承映射的加载</a></li>
<li><a class="reference internal" href="#concrete-polymorphic">具体多态加载配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-inheritance" >
        
<section id="id1">
<span id="id2"></span><h1>映射类继承层次结构<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>SQLAlchemy支持三种继承形式：单表继承，多表继承和联结表继承。其中，单表继承表示几种类型的类由单个表表示；多表继承表示每种类型的类都由独立的表表示，联结表继承则通过依赖表从中断开类层次结构，每个类都由自己的表表示，只包括本地类特定的属性。</p>
<p>最常见的继承形式是单表继承和联结表继承，而多表继承则提出了更多的配置挑战。</p>
<p>在映射器配置继承关系时，SQLAlchemy可以多态地加载元素，这意味着单个查询可返回多种类型的对象。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="queryguide/inheritance.html#loading-joined-inheritance"><span class="std std-ref">继承映射中编写SELECT语句</span></a> ——在   :ref:` queryguide_toplevel`  中查看</p>
<p><a class="reference internal" href="examples.html#examples-inheritance"><span class="std std-ref">继承映射示例</span></a> ——完整的联结，单个和具体的继承示例</p>
</div>
<section id="joined-inheritance">
<span id="id3"></span><h2>联结表继承<a class="headerlink" href="#joined-inheritance" title="Permalink to this heading">¶</a></h2>
<p>在联结表继承中，沿着类的层次结构，每个类都由一个不同的表表示。查询类中的一个特定子类将呈现为沿着其继承路径中的所有表进行SQL JOIN。如果查询的类是基类，则查询基表，同时有选项包括其他表，或者允许特定于子表的属性稍后加载。</p>
<p>在所有情况下，要为给定行实例化的最终类是由基类上定义的鉴别器列或SQL表达式确定的，其将产生与特定子类相关联的标量值。</p>
<p>联结继承层次结构中的基类配置有用于多态鉴别器列的附加参数，以及可选的基类本身的多态标识符：</p>
<blockquote>
<div><p>from sqlalchemy import ForeignKey
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return f”{self.__class__.__name__}({self.name!r})”</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，鉴别器是 <code class="docutils literal notranslate"><span class="pre">type</span></code> 列，可使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_on</span></code>  参数配置。此参数接受以列为导向的表达式，可以使用映射属性的值作为字符串名称，也可以使用如   :class:` _schema.Column`  或   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造的列表达式对象。</p>
<p>鉴别器列将存储一个值，该值表示行内表示的对象类型。列可以是任何数据类型，但字符串和整数是最常见的。为特定行应用于此列的实际数据值是使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>  参数指定的，默认值如下。</p>
<p>虽然多态鉴别器表达式并不是必需的，但如果需要多态加载，则必需。建立基表上的列是实现此功能的最简单方法，但非常复杂的继承映射可能会使用SQL表达式，例如CASE表达式，作为多态鉴别器。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>目前，“整个继承层次结构”通常意味着基类最底层的列配置有 <strong>只有一个鉴别器列或SQL表达式</strong> ，不支持“级联”多态鉴别器表达式。</p>
</div>
<p>接下来，我们定义 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 分别作为 <code class="docutils literal notranslate"><span class="pre">Employee</span></code> 的子类。每个子类包含代表其表示的子类唯一属性的列。每个表也必须包含主键列（或多列），以及对父表的外键：</p>
<blockquote>
<div><dl>
<dt>class Engineer(Employee):</dt><dd><p>__tablename__ = “engineer”
id: Mapped[int] = mapped_column(ForeignKey(“employee.id”), primary_key=True)
engineer_name: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id: Mapped[int] = mapped_column(ForeignKey(“employee.id”), primary_key=True)
manager_name: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，每个映射都在其映射器参数中指定  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>  参数。该值填充由  :paramref:` _orm.Mapper.polymorphic_on`  参数建立的列。  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>  参数应在整个层次结构中唯一，并且每个映射类应该只有一个“identity”；如上所述，不支持一些子类引入第二个标识的“级联”身份。</p>
<p>ORM使用由  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>  设置的值，以确定在多态方式下加载行时行所属的类。在上面的示例中，表示 ` <cite>Employee`</cite> 的每一行都将在其“type”列中包含值 <code class="docutils literal notranslate"><span class="pre">'employee'</span></code>，同样的，每个 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 将得到值 <code class="docutils literal notranslate"><span class="pre">'engineer'</span></code>，每个 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 将得到值 <code class="docutils literal notranslate"><span class="pre">'manager'</span></code>。不论继承映射是否像联结表继承一样使用不同的单独的表来表示子类，或者所有子类像单表继承一样使用相同的表，都期望将此值保留并在查询时向ORM提供。  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>  参数也适用于具体表继承，但实际上并没有持久化；请参见   :ref:` concrete_inheritance`  部分获取详细信息。</p>
<p>在多态设置中，最常见的情况是将外键约束建立在与主键本身相同的列或列上，但这不是必需的；也可以使用与主键不同的列来指示父项。从基表到子表构造 JOIN 的方式也是可以直接自定义的，只是这很少使用。</p>
<aside class="topic">
<p class="topic-title">联结继承主键</p>
<p>联结表继承配置的一个自然结果是，任何映射对象的标识都可以完全从基表中的行中确定。这具有明显的优点，因此SQLAlchemy始终将联结继承类的主键列视为仅基表的主键列。换句话说， <code class="docutils literal notranslate"><span class="pre">engineer</span></code> 表和 <code class="docutils literal notranslate"><span class="pre">manager</span></code> 表的 <code class="docutils literal notranslate"><span class="pre">id</span></code> 列不用于定位 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 对象-只考虑 <code class="docutils literal notranslate"><span class="pre">employee.id</span></code> 中的值。当然， <code class="docutils literal notranslate"><span class="pre">engineer.id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">manager.id</span></code> 仍然对模式的正确操作至关重要，因为一旦在语句中确定了父行，它们将用于定位连接行。</p>
</aside>
<p>联结继承映射完成后，针对“Employee”进行的查询将返回“Employee”、“Engineer”和“Manager”对象的组合。在这种情况下，新保存的“Engineer”、“Manager”和“Employee”对象将自动使用正确的“鉴别器”值填充“employee.type”列，即“’engineer’”、“’manager’”或“’employee’”。</p>
<section id="id4">
<h3>联结继承中的关系<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p>与联结表继承一样，联结继承完全支持关系。涉及联结继承类的关系应将目标类定向到对应于外键约束的类；下面是相应的代码，因为 <code class="docutils literal notranslate"><span class="pre">employee</span></code> 表在单向具有外键约束指向 <code class="docutils literal notranslate"><span class="pre">company</span></code> 表：</p>
<blockquote>
<div><p>from __future__ import annotations</p>
<p>from sqlalchemy.orm import relationship</p>
<dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
employees: Mapped[List[Employee]] = relationship(back_populates=”company”)</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]
company_id: Mapped[int] = mapped_column(ForeignKey(“company.id”))
company: Mapped[Company] = relationship(back_populates=”employees”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>…</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
<p>如果外键约束在与子类相对应的表上，关系应定向到该子类。在下面的示例中，从 <code class="docutils literal notranslate"><span class="pre">manager</span></code> 到 <code class="docutils literal notranslate"><span class="pre">company</span></code> 有一个外键约束，因此关系应定向到 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Company</span></code> 类之间：</p>
<blockquote>
<div><dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
managers: Mapped[List[Manager]] = relationship(back_populates=”company”)</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id: Mapped[int] = mapped_column(ForeignKey(“employee.id”), primary_key=True)
manager_name: Mapped[str]</p>
<p>company_id: Mapped[int] = mapped_column(ForeignKey(“company.id”))
company: Mapped[Company] = relationship(back_populates=”managers”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
<p>上述代码中，“Manager”类将具有 “Manager.company” 属性；“Company”则将具有一个始终针对 “employee” 和 “manager” 表一起加载的 “Company.managers” 属性。</p>
</section>
<section id="id5">
<h3>联结继承映射的加载<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>有关继承加载技术（包括在映射器配置时间以及查询时间配置要查询的表格）的背景信息，请参见   <a class="reference internal" href="queryguide/inheritance.html"><span class="std std-ref">继承映射中编写SELECT语句</span></a> 。只返回该类的实例，并启用具有多态性类的多态加载，映射器内部配置特殊的SELECT，通常通过所有表的UNION生成。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>具体表继承的复杂程度远远高于连接或单表继承，特别是涉及使用涉及关系、急切加载和多态加载时，其功能极为有限。当用于多态时，它会生成UNION的非常大的查询，这些查询将不如简单连接执行。如果需要关系加载和多态加载的灵活性，则强烈建议尽可能使用连接或单表继承。如果不需要多态加载，则可以使用纯非继承映射，如果每个类都完全引用其自己的表。</p>
</div>
<p>相对于连接和单表继承，具体继承在“多态”加载中的应用不那么顺畅。因此，当不需要多态加载时，具体继承更为合适。在涉及具体继承类的关系时，建立关系也更加困难。</p>
<p>要将一个类添加为使用具体继承，请在“__mapper_args__”中添加  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.concrete</span></code>  参数。这表明对于声明式和映射，都不应将超类表视为映射的一部分：</p>
<p>示例代码：</p>
<blockquote>
<div><dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
manager_data = mapped_column(String(50))</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>__tablename__ = “engineer”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
engineer_info = mapped_column(String(50))</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>应据此注意两个关键点：</p>
<ul class="simple">
<li><p>我们必须**在每个子类中明确定义所有列**，即使那些名称相同。例如，这里的“Employee.name”并**不会**被复制到由“Manager”或“Engineer”映射的表中。</p></li>
<li><p>虽然“Engineer”和“Manager”类在继承关系中被映射，但他们仍然**不具有多态加载**。也就是说，如果我们查询“Employee”对象，则“manager”和“engineer”表根本不会被查询。</p></li>
</ul>
</section>
<section id="concrete-polymorphic">
<span id="id6"></span><h3>具体多态加载配置<a class="headerlink" href="#concrete-polymorphic" title="Permalink to this heading">¶</a></h3>
<p>使用具体继承进行多态加载需要配置针对每个应该具有多态加载的基类的专用SELECT。该SELECT需要能够单独访问所有映射的表，通常是使用SQLAlchemy助手 <code class="xref py py-func docutils literal notranslate"><span class="pre">polymorphic_union()</span></code> 构造的UNION语句。</p>
<p>如在  <a class="reference internal" href="queryguide/inheritance.html"><span class="std std-ref">继承映射中编写SELECT语句</span></a>  参数默认配置为从特殊可选择载入。当前公共API要求必须在首次构建  :paramref:` _orm.Mapper`  时设置此参数。</p>
<p>然而，在使用声明性时，映射器和映射到的  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> .ConcreteBase` 和 <a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase" title="sqlalchemy.ext.declarative.AbstractConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractConcreteBase</span></code></a> 辅助类，它们在幕后处理此问题。</p>
<p>使用  <a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase" title="sqlalchemy.ext.declarative.ConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteBase</span></code></a> ，我们可以以与其他形式的继承映射几乎相同的方式设置我们的具体映射：</p>
<blockquote>
<div><p>from sqlalchemy.ext.declarative import ConcreteBase
from sqlalchemy.orm import DeclarativeBase</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Employee(ConcreteBase, Base):</dt><dd><p>__tablename__ = “employee”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
manager_data = mapped_column(String(40))</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,
“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>__tablename__ = “engineer”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
engineer_info = mapped_column(String(40))</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,
“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>上面，Declarative在“initialization”操作的映射器中设置了“Employee”类的多态可选择载入；此类映射器对于解决其他相关映射器的依赖关系是可执行配置步骤。  <a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase" title="sqlalchemy.ext.declarative.ConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteBase</span></code></a> .polymorphic_union` 函数为所有具体映射表创建了一个UNION，在创建好所有其他类之后配置该语句并将其应用于已存在的基类映射器。</p>
<p>在选择时，多态联合生成如下查询：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Employee</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="k">type</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">engineer_info</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">SELECT</span>
<span class="w">        </span><span class="n">employee</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span>
<span class="w">        </span><span class="n">employee</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;employee&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">employee</span>
<span class="w">    </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="w">    </span><span class="k">SELECT</span>
<span class="w">        </span><span class="n">manager</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span>
<span class="w">        </span><span class="n">manager</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">        </span><span class="n">manager</span><span class="p">.</span><span class="n">manager_data</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;manager&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">manager</span>
<span class="w">    </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="w">    </span><span class="k">SELECT</span>
<span class="w">        </span><span class="n">engineer</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span>
<span class="w">        </span><span class="n">engineer</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">        </span><span class="n">engineer</span><span class="p">.</span><span class="n">engineer_info</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;engineer&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">engineer</span>
<span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pjoin</span>
</div></pre></div>
</div>
<p>上面的UNION查询需要为每个子表制造“NULL”列，以适应那些不是特定子类成员的列。</p>
<dl class="simple">
<dt>相关链接：</dt><dd><p><a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase" title="sqlalchemy.ext.declarative.ConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteBase</span></code></a></p>
</dd>
</dl>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="composites.html" title="previous chapter">复合列类型</a>
        Next:
        <a href="nonstandard_mappings.html" title="next chapter">非传统映射</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:58:59

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


