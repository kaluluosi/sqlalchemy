<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    映射类继承层次结构
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="ORM映射类配置" href="mapper_config.html" />
        <link rel="next" title="非传统映射" href="nonstandard_mappings.html" />
        <link rel="prev" title="组合列类型" href="composites.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span><ul>
<li><span class="link-container"><a class="reference external" href="mapping_styles.html">ORM映射类概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mapping.html">使用Declarative映射类</a></span></li>
<li><span class="link-container"><a class="reference external" href="dataclasses.html">与dataclasses和attrs集成</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_sql_expr.html">将 SQL 表达式作为映射属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_attributes.html">更改属性行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="composites.html">组合列类型</a></span></li>
<li class="selected"><span class="link-container"><strong>映射类继承层次结构</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#joined-inheritance">联接表继承</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id25">联接继承关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id30">载入联接继承映射</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id31">单表继承</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#use-existing-column">使用 use_existing_column 解决列冲突</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id54">单表继承关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="#polymorphic-abstract">使用``polymorphic_abstract``建立更深层次的层级</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id67">载入单表继承映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="#concrete-polymorphic">具体多态加载配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="#abstract-concrete-base">具体抽象类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id90">与具体继承的关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id93">具体继承的加载</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="nonstandard_mappings.html">非传统映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="versioning.html">配置版本计数器</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapping_api.html">类映射API</a></span></li>
<li><span class="link-container"><a class="reference external" href="scalar_mapping.html">SQL表达式映射</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">使用Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部实现</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="composites.html" title="previous chapter">组合列类型</a></li>
                <li><b>Next:</b>
                <a href="nonstandard_mappings.html" title="next chapter">非传统映射</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="mapper_config.html" title="ORM映射类配置">ORM映射类配置</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">映射类继承层次结构</a><ul>
<li><a class="reference internal" href="#joined-inheritance">联接表继承</a><ul>
<li><a class="reference internal" href="#id25">联接继承关系</a></li>
<li><a class="reference internal" href="#id30">载入联接继承映射</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id31">单表继承</a><ul>
<li><a class="reference internal" href="#use-existing-column">使用 use_existing_column 解决列冲突</a></li>
<li><a class="reference internal" href="#id54">单表继承关系</a></li>
<li><a class="reference internal" href="#polymorphic-abstract">使用``polymorphic_abstract``建立更深层次的层级</a></li>
<li><a class="reference internal" href="#id67">载入单表继承映射</a></li>
<li><a class="reference internal" href="#concrete-polymorphic">具体多态加载配置</a></li>
<li><a class="reference internal" href="#abstract-concrete-base">具体抽象类</a></li>
<li><a class="reference internal" href="#id90">与具体继承的关系</a></li>
<li><a class="reference internal" href="#id93">具体继承的加载</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-inheritance" >
        
<section id="id1">
<h1>映射类继承层次结构<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>SQLAlchemy支持三种继承形式：单表继承，其中一个表代表多种类形；具体的表继承，其中每种类型的类都由独立的表代表；以及联接表继承，其中类层次结构分布在相关表之间，每个类由自己的表代表，该表仅包含该类本地的那些属性。</p>
<p>单继承和联合继承是最常见的继承形式，而具体的继承则提供了更多的配置挑战。</p>
<p>当映射器在继承关系中配置时，SQLAlchemy有能力以多态的方式加载元素，意味着单个查询可以返回多种类型的对象。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="queryguide/inheritance.html#loading-joined-inheritance"><span class="std std-ref">编写继承映射的SELECT语句</span></a> - 描述 <span class="xref std std-ref">queryguide_toplevel</span> 中的联接表</p>
<p><a class="reference internal" href="examples.html#examples-inheritance"><span class="std std-ref">继承映射示例</span></a> - 完整的联接、单体和具体继承示例</p>
</div>
<section id="joined-inheritance">
<span id="id2"></span><h2>联接表继承<a class="headerlink" href="#joined-inheritance" title="Permalink to this heading">¶</a></h2>
<p>在联接表继承中，沿着类的层次结构的每个类都由一个不同的表代表。查询特定子类时将呈现为沿其继承路径中的所有表连接的SQL JOIN。如果查询的类是基类，则将查询基表，同时包括包括在内的其他表的选项，或者允许稍后加载特定于子表的属性。</p>
<p>在所有情况下，对于给定行要实例化的最终类由基类上定义的多态鉴别器列或SQL表达式确定，该列将产生与特定子类相关联的标量值。</p>
<p>联接继承层次结构中的基类使用附加参数进行配置，以指示多态鉴别器列，以及可选的基类自身的多态标识符：</p>
<dl>
<dt><a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></dt><dd><p>from sqlalchemy import ForeignKey
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return f”{self.__class__.__name__}({self.name!r})”</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a></p>
<p>在上面的示例中，鉴别器是“类型”列，该列使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_on</span></code> 参数进行配置。该参数接受面向列的表达式，可以指定为映射的属性的字符串名称，也可以指定为列表达式对象，例如 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 或 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 构造。</p>
<p>鉴别器列将存储一个值，该值表示行内表示的对象的类型。该列可以是任何数据类型，但字符串和整数是最常见的。为数据库中特定行应用于此列的实际数据值是使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code> 参数指定的，如下面所述。</p>
<p>虽然多态鉴别器表达式不严格必需，但如果想要多态加载，则需要此参数。在基表上建立一个列是实现此目的的最简单方法，然而，非常复杂的继承映射可以使用SQL表达式，例如CASE表达式，作为多态鉴别器。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>目前，整个继承层次结构仅可为一个鉴别器列或SQL表达式进行配置，通常为继承层次结构中的基类。尚不支持“级联”多态鉴别器表达式。</p>
</div>
<p>接下来，我们定义 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Manager</span></code> 的子类。每个子类都包含代表它所代表的子类的唯一属性的列。每个表还必须包含主键列（或多个主键列），以及对父表的外键引用：</p>
<dl>
<dt><a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a></dt><dd><dl>
<dt>class Engineer(Employee):</dt><dd><p>__tablename__ = “engineer”
id: Mapped[int] = mapped_column(ForeignKey(“employee.id”), primary_key=True)
engineer_name: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id: Mapped[int] = mapped_column(ForeignKey(“employee.id”), primary_key=True)
manager_name: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id15"><span class="problematic" id="id16">``</span></a><a href="#id17"><span class="problematic" id="id18">`</span></a></p>
<p>在上面的示例中，每个映射都在其映射器参数中指定 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code> 参数。此值填充由 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_on</span></code> 参数在基础映射上指定的列。 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code> 参数应在整个继承层次结构中为每个映射类唯一，并且每个映射类应只有一个“身份”; 如上所述，“级联”标识，在其中一些子类引入第二个标识的情况下，不受支持。</p>
<p>ORM使用由 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code> 设置的值，以确定负责加载面向这些行的类。在上面的示例中，每个表示“Employee”的行都在其“type”列中具有值“employee”；类似地，每个“Engineer”将获得值“engineer”，每个“Manager”将获得值“manager”。无论继承映射是否像联接表继承中那样使用不同的联接表子类一样，在查询时都期望保存此值并为ORM在查询时可用。<code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code> 参数也适用于具体表继承，但实际上没有保存；有关详细信息，请参见下面的 <span class="xref std std-ref">concrete_inheritance</span> 部分。</p>
<p>在多态设置中，常见的做法是外键约束在与主键本身相同的列或列上，但这不是必需的；某个不同于主键本身的列也可以使“父表”引用某个列。构建从基表到子类的JOIN方式也是可以直接自定义的，但是这很少是必要的。</p>
<aside class="topic">
<p class="topic-title">联接继承主键</p>
<p>联接表继承配置的一个自然效应是任何映射对象的标识都可以完全从基本表中的行中确定。这具有明显的优点，因此SQLAlchemy始终将联接继承类的主键列视为仅属于基本表。换句话说，<a href="#id19"><span class="problematic" id="id20">``</span></a>engineer``和``manager``表的``id``列不用于查找``Engineer``或``Manager``对象–只考虑``employee.id``中的值。当然，<a href="#id21"><span class="problematic" id="id22">``</span></a>engineer.id``和``manager.id``对于整个模式的适当操作仍然非常重要，因为一旦确定了父行，它们将用于定位联接行。</p>
</aside>
<p>联接继承映射已经完成，请对``Employee``进行查询将返回``Employee``、<code class="docutils literal notranslate"><span class="pre">Engineer``和``Manager``对象的组合。在此情况下，新保存的``Engineer</span></code>、<code class="docutils literal notranslate"><span class="pre">Manager``和``Employee``对象将自动使用正确的&quot;鉴别器&quot;值填充``employee.type``列，即分别是</span></code>”engineer”<code class="docutils literal notranslate"><span class="pre">、</span></code>”manager”<code class="docutils literal notranslate"><span class="pre">和</span></code>”employee”<a href="#id23"><span class="problematic" id="id24">``</span></a>。</p>
<section id="id25">
<h3>联接继承关系<a class="headerlink" href="#id25" title="Permalink to this heading">¶</a></h3>
<p>联接表继承的关系完全得到支持。涉及联接继承类的关系应该针对在层次结构中对应于外键约束的类；下面，因为``employee``表有一个返回``company``表的外键约束，
关系是在``Company``和``Employee``之间建立的：</p>
<blockquote>
<div><p>from __future__ import annotations</p>
<p>from sqlalchemy.orm import relationship</p>
<dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
employees: Mapped[List[Employee]] = relationship(back_populates=”company”)</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]
company_id: Mapped[int] = mapped_column(ForeignKey(“company.id”))
company: Mapped[Company] = relationship(back_populates=”employees”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>…</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
<p>如果外键约束在对应于子类的表上，则关系应该指向该子类。在下面的示例中，从经理到公司的外键约束，因此关系应该在``Manager``和``Company``之间建立：</p>
<blockquote>
<div><dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
managers: Mapped[List[Manager]] = relationship(back_populates=”company”)</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id: Mapped[int] = mapped_column(ForeignKey(“employee.id”), primary_key=True)
manager_name: Mapped[str]</p>
<p>company_id: Mapped[int] = mapped_column(ForeignKey(“company.id”))
company: Mapped[Company] = relationship(back_populates=”managers”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
<p>上面，<a href="#id26"><span class="problematic" id="id27">``</span></a>Manager``类将具有``Manager.company``属性；<a href="#id28"><span class="problematic" id="id29">``</span></a>Company``将具有始终针对``employee``和``manager``表一起加载的``Company.managers``属性。</p>
</section>
<section id="id30">
<h3>载入联接继承映射<a class="headerlink" href="#id30" title="Permalink to this heading">¶</a></h3>
<p>有关继承加载技术的背景信息，请参见 <a class="reference internal" href="queryguide/inheritance.html"><span class="std std-ref">编写继承映射的SELECT语句</span></a> 部分，其中包括两次配置以及查询和多层抽象的映射的信息。单表和联接表继承的大部分加载技术都是相同的，因此提供了很高的抽象度，使得可以轻松地在这两种映射类型之间切换，以及在单个层次结构中混合使用它们（只需省略``__tablename__``就可以使子类单一继承）。有关继承加载技术的文档，请参见 <span class="xref std std-ref">loading_single_inheritance</span> 部分和 <a class="reference internal" href="queryguide/inheritance.html"><span class="std std-ref">编写继承映射的SELECT语句</span></a> 部分。</p>
</section>
</section>
<section id="id31">
<h2>单表继承<a class="headerlink" href="#id31" title="Permalink to this heading">¶</a></h2>
<p>单表继承将来自所有子类的所有属性都表示在单个表中。具有唯一属性的特定子类将在表中的列中保持它们，如果行引用其他类型的对象，则这些列默认为NULL。</p>
<p>查询特定层次结构中的类将呈现为针对基本表的SELECT，其中包括一个WHERE子句，该子句将行限制为鉴别器列或表达式中存在特定值或值。</p>
<p>通过一个示例理解如何更好地理解``Single Table Inheritance``的用法：</p>
<dl>
<dt><a href="#id32"><span class="problematic" id="id33">``</span></a><a href="#id34"><span class="problematic" id="id35">`</span></a></dt><dd><dl>
<dt>class Employee(Base):</dt><dd><p>id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_on”: “type”,
“polymorphic_identity”: “employee”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>manager_data: Mapped[str] = mapped_column(nullable=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>engineer_info: Mapped[str] = mapped_column(nullable=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a></p>
<p>上面的配置中，唯一不同的是没有表名。我们已经声明了所有的列，这使得ORM可以查询到每个具体类的实例。需要注意的是，在单表继承配置中，鉴别器列必须在基表中。</p>
<p>单表继承具有简单性优势，而不需要像联接表继承那样涉及多个表以加载对象。</p>
<section id="use-existing-column">
<span id="orm-inheritance-column-conflicts"></span><h3>使用 use_existing_column 解决列冲突<a class="headerlink" href="#use-existing-column" title="Permalink to this heading">¶</a></h3>
<p>下面的示例中，<code class="docutils literal notranslate"><span class="pre">manager_name``和``engineer_info``列被“提升”到应用于``Employee.__table__</span></code>，由于它们声明在没有唯一表的子类上。但是，当两个子类想要指定同一个列时，会出现棘手的情况，如下所示：</p>
<dl>
<dt><a href="#id40"><span class="problematic" id="id41">``</span></a><a href="#id42"><span class="problematic" id="id43">`</span></a></dt><dd><p>from datetime import datetime</p>
<dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
<p>start_date: Mapped[datetime] = mapped_column(nullable=True)</p>
</dd>
<dt>class Manager(Employee):</dt><dd><dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
<p>start_date: Mapped[datetime] = mapped_column(nullable=True)</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id44"><span class="problematic" id="id45">``</span></a><a href="#id46"><span class="problematic" id="id47">`</span></a></p>
<p>在上面的示例中，<a href="#id48"><span class="problematic" id="id49">``</span></a>Engineer``和``Manager``中声明的``start_date``列都将导致错误：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.ArgumentError: Column &#39;start_date&#39; on class Manager conflicts
with existing column &#39;employee.start_date&#39;.  If using Declarative,
consider using the use_existing_column parameter of mapped_column() to
resolve conflicts.</pre></div>
</div>
<p>上述情况对Declarative映射系统而言是不确定的，它可能通过使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.use_existing_column</span></code> 参数来使用所映射的父类上的列（如果已经存在）来解决此问题，否则将映射一个新的列</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<blockquote>
<div><p>from sqlalchemy import DateTime</p>
<dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_on”: “type”,
“polymorphic_identity”: “employee”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>start_date: Mapped[datetime] = mapped_column(</dt><dd><p>nullable=True, use_existing_column=True</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>class Manager(Employee):</dt><dd><dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>start_date: Mapped[datetime] = mapped_column(</dt><dd><p>nullable=True, use_existing_column=True</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a></p>
<p>以上，当映射``Manager``时，<code class="docutils literal notranslate"><span class="pre">start_date``列在``Employee``类上已经出现，因为已经是``Engineer``映射提供的</span> <span class="pre">By</span> <span class="pre">``_.Orm.Mapped_Column</span></code>。 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.use_existing_column</span></code> 参数表示 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 应首先在子类中查找所请求的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>，如果存在，则使用已经映射的列，否则 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 将像往常一样映射该列，将其添加为由``Employee``超类引用的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 中的列之一。</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0.0b4: </span>- Added <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.use_existing_column</span></code>,
which provides a 2.0-compatible means of mapping a column on an inheriting
subclass conditionally.  The previous approach which combines
<code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code> with a lookup on the parent <code class="docutils literal notranslate"><span class="pre">.__table__</span></code>
continues to function as well, but lacks <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> typing support.</p>
</div>
<p>可以使用混合类相似的概念（请参见 <span class="xref std std-ref">orm_mixins_toplevel</span>）从可重用的混合类定义特定列和/或其他映射属性的一系列从中继承的子类：</p>
<blockquote>
<div><dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_on”: type,
“polymorphic_identity”: “employee”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class HasStartDate:</dt><dd><dl class="simple">
<dt>start_date: Mapped[datetime] = mapped_column(</dt><dd><p>nullable=True, use_existing_column=True</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>class Engineer(HasStartDate, Employee):</dt><dd><dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(HasStartDate, Employee):</dt><dd><dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id54">
<h3>单表继承关系<a class="headerlink" href="#id54" title="Permalink to this heading">¶</a></h3>
<p>单表继承的关系与联接继承完全得到支持。配置方式与联接继承相同；外键属性应该位于也对应于外键约束的类。下面，因为``employee``表有一个外键约束返回到``company``表，因此关系是在``Company``和``Employee``之间建立的：</p>
<blockquote>
<div><dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
employees: Mapped[List[Employee]] = relationship(back_populates=”company”)</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]
company_id: Mapped[int] = mapped_column(ForeignKey(“company.id”))
company: Mapped[Company] = relationship(back_populates=”employees”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>manager_data: Mapped[str] = mapped_column(nullable=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>engineer_info: Mapped[str] = mapped_column(nullable=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>此外，我们还可以创建涉及特定子类的关系。在查询时，SELECT 语句将包括 WHERE 子句，以限制类选择为特定子类或子类：</p>
<blockquote>
<div><dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
managers: Mapped[List[Manager]] = relationship(back_populates=”company”)</p>
</dd>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>manager_name: Mapped[str] = mapped_column(nullable=True)</p>
<p>company_id: Mapped[int] = mapped_column(ForeignKey(“company.id”))
company: Mapped[Company] = relationship(back_populates=”managers”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>engineer_info: Mapped[str] = mapped_column(nullable=True)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>以上，<a href="#id55"><span class="problematic" id="id56">``</span></a>Manager``类将具有``Manager.company``属性；<a href="#id57"><span class="problematic" id="id58">``</span></a>Company``将具有始终针对带有额外 WHERE 子句的 “employee” 和 “manager” 表一起加载的``Company.managers``属性。</p>
</section>
<section id="polymorphic-abstract">
<h3>使用``polymorphic_abstract``建立更深层次的层级<a class="headerlink" href="#polymorphic-abstract" title="Permalink to this heading">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0.</span></p>
</div>
<p>在构建任何继承层次结构时，映射的类可以包括设置为``True``的 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_abstract</span></code> 参数，这表示应在映射该类的同时，不希望直接实例化该类，并且不会包含 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>。然后，子类可以被声明为该映射类的子类，并且它们本身可以包括:paramref:<cite>_orm.Mapper.polymorphic_identity</cite>，从而可以正常使用。这允许以一个通用的基类来引用一系列子类，该基类在基线层次结构中被视为“抽象”，无论是在查询中还是在 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 声明中。此用法不同于使用 Declarative 中的 <a class="reference internal" href="declarative_config.html#declarative-abstract"><span class="std std-ref">__abstract__</span></a> 属性，Declarative 会完全映射目标类，并且因此无法单独使用映射类。 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_abstract</span></code> 可以应用于继承层次结构中的任何一级类，包括一次在多个级别上批量应用。</p>
<p>例如，假设要将“Manager”和“Principal”都归类为“Executive”超类，并且“Engineer”和“Sysadmin”都归类为“Technologist”超类。<code class="docutils literal notranslate"><span class="pre">Technologist</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Executive</span></code> 都不会被直接实例化，因此它们没有 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.polymorphic_identity</span></code>。可以如下配置：</p>
<dl>
<dt><a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a></dt><dd><dl>
<dt>class Employee(Base):</dt><dd><p>__tablename__ = “employee”
id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]
type: Mapped[str]</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“polymorphic_on”: “type”,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Executive(Employee):</dt><dd><p>“””An executive of the company”””</p>
<p>executive_background: Mapped[str] = mapped_column(nullable=True)</p>
<p>__mapper_args__ = {“polymorphic_abstract”: True}</p>
</dd>
<dt>class Technologist(Employee):</dt><dd><p>“””An employee who works with technology”””</p>
<p>competencies: Mapped[str] = mapped_column(nullable=True)</p>
<p>__mapper_args__ = {“polymorphic_abstract”: True}</p>
</dd>
<dt>class Manager(Executive):</dt><dd><p>“””a manager”””</p>
<p>__mapper_args__ = {“polymorphic_identity”: “manager”}</p>
</dd>
<dt>class Principal(Executive):</dt><dd><p>“””a principal of the company”””</p>
<p>__mapper_args__ = {“polymorphic_identity”: “principal”}</p>
</dd>
<dt>class Engineer(Technologist):</dt><dd><p>“””an engineer”””</p>
<p>__mapper_args__ = {“polymorphic_identity”: “engineer”}</p>
</dd>
<dt>class SysAdmin(Technologist):</dt><dd><p>“””a systems administrator”””</p>
<p>__mapper_args__ = {“polymorphic_identity”: “engineer”}</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a><a href="#id65"><span class="problematic" id="id66">`</span></a></p>
<p>在上面的示例中，“Technologist”和“Executive”是普通映射类，并且还指出要添加到超类上的新列``executive_background`` 和 <code class="docutils literal notranslate"><span class="pre">competencies</span></code>。但是，它们都缺少：paramref:<cite>_orm.Mapper.polymorphic_identity</cite> 的设置，因为不希望直接实例化 Technologist 或 Executive；我们希望始终有一个 <code class="docutils literal notranslate"><span class="pre">Manager</span></code>、 <code class="docutils literal notranslate"><span class="pre">Principal</span></code>、 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 或 <code class="docutils literal notranslate"><span class="pre">SysAdmin</span></code>。但是，我们仍然可以查询活动人数并且可以将它们作为 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 的目标。下面的示例演示了``Employe``e 对象的 SELECT 语句：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Technologist</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">employee</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">employee</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">employee</span><span class="p">.</span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">employee</span><span class="p">.</span><span class="n">competencies</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employee</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">employee</span><span class="p">.</span><span class="k">type</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;sysadmin&#39;</span><span class="p">)</span>
</div></pre></div>
</div>
<p>在上面的示例中，<code class="docutils literal notranslate"><span class="pre">Technologist</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Executive</span></code> 抽象映射类是通过声明的 <code class="docutils literal notranslate"><span class="pre">Manager</span></code>、 <code class="docutils literal notranslate"><span class="pre">Principal</span></code>、 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">SysAdmin</span></code> 这些子类来调用的。即使我们可以通过查询使用“<code class="docutils literal notranslate"><span class="pre">Technologist</span></code>”和“<code class="docutils literal notranslate"><span class="pre">Principal</span></code>”角色，也可以对 <code class="xref py py-func docutils literal notranslate"><span class="pre">principals`()</span></code>”和``Company.technologists``）进行更改。</p>
</section>
<section id="id67">
<h3>载入单表继承映射<a class="headerlink" href="#id67" title="Permalink to this heading">¶</a></h3>
<p>单表继承的载入技术与联接表继承的载入技术大部分相同，并且在两者之间提供了高度的抽象化，使得它们易于切换以及在单个继承层次结构中进行混合。有关继承加载技术的文档，请参见 <span class="xref std std-ref">loading_single_inheritance</span> 部分和 <a class="reference internal" href="queryguide/inheritance.html"><span class="std std-ref">编写继承映射的SELECT语句</span></a> 部分。仅返回该类的实例。通过在映射器中配置一个特殊的SELECT语句才能启用具体类的多态加载，通常这个SELECT语句是由所有表的UNION生成的。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>具体表继承比连接或单表继承**更加复杂**，功能方面**更加受限**，特别是与关系、急加载和多态加载一起使用时。如果需要灵活性进行关系加载和多态加载，建议使用连接或单表继承，如果有可能。如果不需要多态加载，则可以使用普通的非继承映射，如果每个类都完全引用自己的表。</p>
</div>
<p>虽然连接和单表继承熟练于”多态”加载，但在具体继承中，这是一个更尴尬的问题。因此，具体继承更适合不需要**多态加载**的场合。建立涉及具体继承类的关系也更加麻烦。</p>
<p>要将一个类作为使用具体继承，请在”__mapper_args__”中添加:paramref:<a href="#id68"><span class="problematic" id="id69">`</span></a>_orm.Mapper.concrete`参数。这表明，在Declarative以及映射中，超类表不应被视为映射的一部分:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;manager&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>必须注意两个关键点：</p>
<ul class="simple">
<li><p>我们必须**明确定义**每个子类上的所有列，即使这些列名称相同。例如，在此处，像”Employee.name”一样的列并**不会**自动复制到”Manager”或”Engineer”表中。</p></li>
<li><p>虽然”Engineer”和”Manager”类在继承关系中被映射，但它们仍然**不包括多态加载**。这意味着，如果我们查询”Employee”对象，则”manager”和”engineer”表根本不会被查询。</p></li>
</ul>
</section>
<section id="concrete-polymorphic">
<span id="id70"></span><h3>具体多态加载配置<a class="headerlink" href="#concrete-polymorphic" title="Permalink to this heading">¶</a></h3>
<p>使用具体继承进行多态加载需要针对每个应该具有多态加载的基类配置一个特殊的SELECT。这个SELECT需要能够访问所有的映射表，并且通常是由SQLAlchemy辅助函数:func:<a href="#id71"><span class="problematic" id="id72">`</span></a>.polymorphic_union`生成的一个UNION语句。</p>
<p>正如在:ref:<a href="#id73"><span class="problematic" id="id74">`</span></a>inheritance_loading_toplevel`所讨论的那样，任何类型的映射器继承配置都可以配置成从默认的特殊可选择性载入，并使用:paramref:<a href="#id75"><span class="problematic" id="id76">`</span></a>_orm.Mapper.with_polymorphic`参数。当前的公共API要求在首次构造映射器时设置此参数。</p>
<p>然而，在Declarative中，映射器和被映射的:class:<a href="#id77"><span class="problematic" id="id78">`</span></a>_schema.Table`同时创建，即在定义映射类的时候就完成了。这意味着:paramref:<a href="#id79"><span class="problematic" id="id80">`</span></a>_orm.Mapper.with_polymorphic`参数尚未提供，因为对应于子类的:class:<a href="#id81"><span class="problematic" id="id82">`</span></a>_schema.Table`对象尚未被定义。</p>
<p>有几种策略可用于解决此循环，但是Declarative提供了辅助类:class:<cite>.ConcreteBase`和:class:</cite>.AbstractConcreteBase`，可以在幕后处理此问题。</p>
<p>使用:class:<cite>.ConcreteBase</cite>，我们可以以几乎相同的方式设置具体映射，以设置其他形式的继承映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">ConcreteBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">ConcreteBase</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;employee&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;manager&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;manager&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;engineer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面，在映射器”initialization”时间，Declarative设置了``Employee``类的多态可选操作；这是对于那些要解决其他依赖映射器的映射器的后期配置步骤。助手:class:<cite>.ConcreteBase`使用:func:</cite>.polymorphic_union`函数在所有其他类设置好后创建了具体映射的表的一个UNION，然后在已存在的基类映射器上设置了这个语句。</p>
<p>在选择时，多态联合会生成如下查询：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Employee</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="k">type</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">    </span><span class="n">pjoin</span><span class="p">.</span><span class="n">engineer_info</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">SELECT</span>
<span class="w">        </span><span class="n">employee</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span>
<span class="w">        </span><span class="n">employee</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;employee&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">employee</span>
<span class="w">    </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="w">    </span><span class="k">SELECT</span>
<span class="w">        </span><span class="n">manager</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span>
<span class="w">        </span><span class="n">manager</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">        </span><span class="n">manager</span><span class="p">.</span><span class="n">manager_data</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;manager&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">manager</span>
<span class="w">    </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="w">    </span><span class="k">SELECT</span>
<span class="w">        </span><span class="n">engineer</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span>
<span class="w">        </span><span class="n">engineer</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span>
<span class="w">        </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span>
<span class="w">        </span><span class="n">engineer</span><span class="p">.</span><span class="n">engineer_info</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">        </span><span class="s1">&#39;engineer&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">engineer</span>
<span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pjoin</span>
</div></pre></div>
</div>
<p>上面的UNION查询需要为每个子表制造”NULL”列，以适应不是该特定子类成员的列。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase" title="sqlalchemy.ext.declarative.ConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteBase</span></code></a></p>
</div>
</section>
<section id="abstract-concrete-base">
<span id="id83"></span><h3>具体抽象类<a class="headerlink" href="#abstract-concrete-base" title="Permalink to this heading">¶</a></h3>
<p>具体继承的映射通常将超类和子类都映射到单独的表中，而不映射基类。换句话说，基类是”抽象”的。</p>
<p>当希望将两个不同的子类映射到各自的表中，并留下基类没有映射的时候，这可以非常容易地实现。当使用Declarative时，只需使用”__abstract__”指示符声明基类即可:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__abstract__</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;manager&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面，我们实际上没有使用SQLAlchemy的继承映射设施；我们可以正常地加载和持久化”Manager”和”Engineer”实例。然而，当我们需要**查询多态**时，也就是说，我们想发出”select(Employee)”并得到一个”Manager”和”Engineer”实例集合，那就意味着我们重新进入了具体继承的领域，我们必须构建一个特殊的映射器来针对”Employee”实现这一点。</p>
<p>为了将我们的具体继承示例修改为表示一个”抽象”基类，它具备多态加载功能，我们只有一个”engineer”表和一个”manager”表，而没有”employee”表，然而，映射器”Employee”将直接映射到”多态联合”，而不是将其本地指定为:paramref:<a href="#id84"><span class="problematic" id="id85">`</span></a>_orm.Mapper.with_polymorphic`参数。</p>
<p>为了帮助处理这个问题，Declarative提供了一个变量:class:<cite>.AbstractConcreteBase</cite>，它会自动执行此操作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">AbstractConcreteBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">AbstractConcreteBase</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">strict_attrs</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;manager&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;manager&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;engineer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="n">Base</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述映射使用:meth:<a href="#id86"><span class="problematic" id="id87">`</span></a>_orm.registry.configure`方法，触发了实际映射”Employee”类，因为在配置步骤之前，该类没有映射，因为它将从未定义的任何子表中查询出来。使用上述映射，只有”Manager”和”Engineer”实例可以被持久化；针对”Employee”类的查询将始终产生”Manager”和”Engineer”对象。使用上述映射，可以使用”Employee”类及其直接声明的任何属性，例如”Employee.name”构建查询：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;n1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">pjoin</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">pjoin</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">pjoin</span><span class="p">.</span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="n">pjoin</span><span class="p">.</span><span class="n">manager_data</span><span class="p">,</span><span class="w"> </span><span class="n">pjoin</span><span class="p">.</span><span class="n">engineer_info</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="k">SELECT</span><span class="w"> </span><span class="n">engineer</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">engineer</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">engineer</span><span class="p">.</span><span class="n">engineer_info</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">  </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;engineer&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">engineer</span>
<span class="w">  </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="w">  </span><span class="k">SELECT</span><span class="w"> </span><span class="n">manager</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">manager</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="k">NULL</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">engineer_info</span><span class="p">,</span>
<span class="w">  </span><span class="n">manager</span><span class="p">.</span><span class="n">manager_data</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">manager_data</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;manager&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">type</span>
<span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">manager</span>
<span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pjoin</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">pjoin</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span>
</div></pre></div>
</div>
<p><code class="xref py py-paramref docutils literal notranslate"><span class="pre">manager_data&quot;和&quot;Engineer.engineer_info&quot;之类的其他属性仅存在于相应的子类。当未设置:paramref:</span></code>.AbstractConcreteBase.strict_attrs`时，那么在整个层次结构中，包括”Manager.manager_data”和”Engineer.engineer_info”在内的所有子类属性都会映射到基”Employee”类。这是一种遗留的使用模式，可能更便于查询，但是其效果是整个层次结构中的所有子类共享完整的属性集；在上述例子中，不使用:paramref:<a href="#id88"><span class="problematic" id="id89">`</span></a>.AbstractConcreteBase.strict_attrs`将导致生成非有用的”Engineer.manager_name”和”Manager.engineer_info”属性。</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>添加:paramref:<cite>.AbstractConcreteBase.strict_attrs`参数到:class:</cite>.AbstractConcreteBase`，它会生成更简洁的映射；默认值为False，以便允许早期1.x版本的遗留映射继续按其原样工作。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase" title="sqlalchemy.ext.declarative.AbstractConcreteBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractConcreteBase</span></code></a></p>
</div>
</section>
<section id="id90">
<h3>与具体继承的关系<a class="headerlink" href="#id90" title="Permalink to this heading">¶</a></h3>
<p>在具体继承方案中，映射关系很具有挑战性，因为不同的类没有共享的表。如果关系只涉及特定的类，例如在我们之前的示例中的”Company”和”Manager”之间的关系，这些就只是两个相关的表。</p>
<p>但是，如果”Company”想要与”Employee”建立一对多关系，则表明该集合可以包括”Engineer”和”Manager”对象，就意味着”Employee”必须具有多态加载能力，并且每个要关联的表都必须具有一个回到”company”表的外键。以下是这种情况的一个示例配置:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">ConcreteBase</span>


<span class="k">class</span> <span class="nc">Company</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;company&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">ConcreteBase</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">company_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;company.id&quot;</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;employee&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;manager&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
    <span class="n">company_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;company.id&quot;</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;manager&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;engineer&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
    <span class="n">company_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;company.id&quot;</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;engineer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;concrete&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>关于具体继承的下一个复杂度涉及当我们希望”Employee”、”Manager”和”Engineer”中的一个或所有对象也指回”Company”时。为了这种情况，SQLAlchemy在那些链接到”Employee”并且链接到”Company”的关系上有一个特殊的行为，当在实例级别上执行时，它**不起作用**。相反，必须向每个类应用不同的:func:<cite>_orm.relationship</cite>。为了实现三个关系的相反行为，它们都作为”Company.employee”的相反行为被使用:paramref:<a href="#id91"><span class="problematic" id="id92">`</span></a>_orm.relationship.back_populates`参数来引用：</p>
<blockquote>
<div><p>from sqlalchemy.ext.declarative import ConcreteBase</p>
<dl>
<dt>class Company(Base):</dt><dd><p>__tablename__ = “company”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
employees = relationship(“Employee”, back_populates=”company”)</p>
</dd>
<dt>class Employee(ConcreteBase, Base):</dt><dd><p>__tablename__ = “employee”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
company_id = mapped_column(ForeignKey(“company.id”))
company = relationship(“Company”, back_populates=”employees”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “employee”,
“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Manager(Employee):</dt><dd><p>__tablename__ = “manager”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
manager_data = mapped_column(String(40))
company_id = mapped_column(ForeignKey(“company.id”))
company = relationship(“Company”, back_populates=”employees”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “manager”,
“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class Engineer(Employee):</dt><dd><p>__tablename__ = “engineer”
id = mapped_column(Integer, primary_key=True)
name = mapped_column(String(50))
engineer_info = mapped_column(String(40))
company_id = mapped_column(ForeignKey(“company.id”))
company = relationship(“Company”, back_populates=”employees”)</p>
<dl class="simple">
<dt>__mapper_args__ = {</dt><dd><p>“polymorphic_identity”: “engineer”,
“concrete”: True,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>上面的限制与当前实现有关，包括具体继承的类不共享父类的任何属性，因此需要设置不同的关系。</p>
</section>
<section id="id93">
<h3>具体继承的加载<a class="headerlink" href="#id93" title="Permalink to this heading">¶</a></h3>
<p>使用具体继承的加载选项是有限的；通常情况下，如果映射的多态加载使用了Declarative具体的mixin之一，则无法在查询时修改其样式，在当前SQLAlchemy版本中不支持：func:<a href="#id94"><span class="problematic" id="id95">`</span></a>_orm.with_polymorphic`函数来覆盖使用的加载样式，因为当前还存在一些限制。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="composites.html" title="previous chapter">组合列类型</a>
        Next:
        <a href="nonstandard_mappings.html" title="next chapter">非传统映射</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:31:15

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


