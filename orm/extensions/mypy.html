<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    Mypy / Pep-484的ORM映射支持
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
        <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../../index.html" />
        <link rel="up" title="ORM扩展" href="index.html" />
        <link rel="next" title="变异跟踪" href="mutable.html" />
        <link rel="prev" title="声明式扩展" href="declarative/index.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="../quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="../mapper_config.html">ORM映射类配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="../relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="../queryguide/index.html">ORM查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="../session.html">使用Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="../extending.html">事件和内部实现</a></span></li>
<li><span class="link-container"><a class="reference external" href="index.html">ORM扩展</a></span><ul>
<li><span class="link-container"><a class="reference external" href="asyncio.html">异步 I/O (asyncio)</a></span></li>
<li><span class="link-container"><a class="reference external" href="associationproxy.html">关联代理</a></span></li>
<li><span class="link-container"><a class="reference external" href="automap.html">自动映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="baked.html">摘要</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative/index.html">声明式扩展</a></span></li>
<li class="selected"><span class="link-container"><strong>Mypy / Pep-484的ORM映射支持</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id5">安装</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id6">插件作用</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id11">插件的使用</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#typeengine">基于 TypeEngine 的列的内省</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id12">没有显式类型的列</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id15">映射带有命令性表的列</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id16">映射关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="#declared-attrdeclarative-mixins">使用&#64;declared_attr和Declarative Mixins</a></span></li>
<li><span class="link-container"><a class="reference external" href="#dataclasses">结合Dataclasses或其他类型敏感的属性系统</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="mutable.html">变异跟踪</a></span></li>
<li><span class="link-container"><a class="reference external" href="orderinglist.html">排序列表</a></span></li>
<li><span class="link-container"><a class="reference external" href="horizontal_shard.html">水平分片</a></span></li>
<li><span class="link-container"><a class="reference external" href="hybrid.html">混合属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="indexable.html">可索引对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="instrumentation.html">备选类仪器</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="../examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="declarative/index.html" title="previous chapter">声明式扩展</a></li>
                <li><b>Next:</b>
                <a href="mutable.html" title="next chapter">变异跟踪</a></li>

            <li><b>Up:</b> <a href="../../index.html">Home</a></li>
                    <ul><li><a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="index.html" title="ORM扩展">ORM扩展</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#mypy-pep-484orm">Mypy / Pep-484的ORM映射支持</a><ul>
<li><a class="reference internal" href="#id5">安装</a></li>
<li><a class="reference internal" href="#id6">插件作用</a></li>
<li><a class="reference internal" href="#id11">插件的使用</a><ul>
<li><a class="reference internal" href="#typeengine">基于 TypeEngine 的列的内省</a></li>
<li><a class="reference internal" href="#id12">没有显式类型的列</a></li>
<li><a class="reference internal" href="#id15">映射带有命令性表的列</a></li>
<li><a class="reference internal" href="#id16">映射关系</a></li>
<li><a class="reference internal" href="#declared-attrdeclarative-mixins">使用&#64;declared_attr和Declarative Mixins</a></li>
<li><a class="reference internal" href="#dataclasses">结合Dataclasses或其他类型敏感的属性系统</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-extensions-mypy" >
        
<section id="mypy-pep-484orm">
<span id="mypy-toplevel"></span><h1>Mypy / Pep-484的ORM映射支持<a class="headerlink" href="#mypy-pep-484orm" title="Permalink to this heading">¶</a></h1>
<p>在使用SQLAlchemy的 <a class="reference internal" href="../declarative_config.html"><span class="std std-ref">declarative</span></a> 映射时，直接引用:class:<cite>_schema.Column</cite>
对象而非SQLAlchemy 2.0中引入的 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 构造，支持:pep:<a href="#id1"><span class="problematic" id="id2">`</span></a>484`类型注解以及Mypy_类型检查工具。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 2.0: </span><strong>SQLAlchemy Mypy Plugin已不建议使用，将在SQLAlchemy 2.1发布时移除。请务必尽快进行迁移！</strong></p>
<p>该插件无法在不断变化的Mypy版本中维护其稳定性，因此未来的稳定性无法保证。</p>
<p>现代SQLAlchemy现已提供 :ref:<a href="#id3"><span class="problematic" id="id4">`</span></a>完全符合pep-484的映射语法&lt;whatsnew_20_orm_declarative_typing&gt;`的语法结构；
可以查看相关部分以获取迁移详细信息。</p>
</div>
<aside class="topic">
<p class="topic-title">SQLAlchemy Mypy 插件状态更新</p>
<p><strong>更新于 2023 年 7 月</strong></p>
<p>对于 SQLAlchemy 2.0，Mypy插件仍在SQLAlchemy 1.4版本中的级别上工作。不过，
SQLAlchemy 2.0具有一种全新的类型系统 ，用于ORM声明模型，它消除了Mypy插件的
需要，并具有通常情况下优秀的一致性和高级功能。
请注意，此新功能 <strong>不是SQLAlchemy 1.4的一部分，它仅存在于SQLAlchemy 2.0中</strong>。</p>
<p>虽然Mypy插件在技术上从未离开过“alpha”阶段，但现应**将其视为SQLAlchemy 2.0中不建议使用的插件，
即使在使用SQLAlchemy 1.4时仍然需要该插件以支持 Mypy 的完整支持。**</p>
<p>Mypy插件本身并不能解决使用诸如Pylance/Pyright、Pytype、Pycharm等其他类型工具提供正确类型的问题，
这些工具无法使用Mypy插件。此外，开发、维护和测试Mypy插件非常困难，因为Mypy插件必须与Mypy内部的数据结构
和进程深度集成，而Mypy内部的数据结构和进程本身也不稳定。当使用与基本模式不同的代码时，使用Mypy插件会有很多限制
，而这些代码可能会引发定期报告。</p>
<p>出于这些原因，针对 Mypy 插件的新的非回归问题不太可能被修复。
<strong>在安装SQLAlchemy 2.0的同时使用Mypy插件，现有代码将继续通过所有检查而不需要任何更改</strong>。
SQLAlchemy 2.0的API与SQLAlchemy 1.4的API以及Mypy插件行为是完全向后兼容的。</p>
<p>在SQLAlchemy 1.4上全部通过Mypy检查的代码，一旦该代码在完全运行于SQLAlchemy 2.0上，将可以逐步迁移到
新结构。有关此迁移的背景，请参见：<a class="reference internal" href="../../changelog/whatsnew_20.html#whatsnew-20-orm-declarative-typing"><span class="std std-ref">ORM Declarative Models</span></a>。</p>
<p>完全迁移到新声明结构的代码将完全符合pep-484，并能正常工作于IDE和其他类型工具中，而无需插件。</p>
</aside>
<section id="id5">
<h2>安装<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>只对**SQLAlchemy 2.0有效**：不应安装任何笔尖，<a href="#id17"><span class="problematic" id="id18">并且应完全卸载sqlalchemy-stubs_</span></a> 和 sqlalchemy2-stubs_等程序包。</p>
<p>Mypy_本身是依赖。</p>
<p>可以使用 pip 安装Mypy，使用“mypy”额外钩子：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>pip install sqlalchemy[mypy]</pre></div>
</div>
<p>该插件本身的配置方法如下所述：
<a class="reference external" href="https://mypy.readthedocs.io/en/latest/extending_mypy.;html#configuring-mypy-to-use-plugins">Configuring mypy to use Plugins</a>
使用sqlalchemy的扩展.mypy.plugin模块名称，例如在
<code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> 中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">mypy</span><span class="p">]</span>
<span class="n">plugins</span> <span class="o">=</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">mypy</span><span class="o">.</span><span class="n">plugin</span></pre></div>
</div>
</section>
<section id="id6">
<h2>插件作用<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>Mypy插件的主要目的是截取并更改SQLAlchemy的静态定义
<a class="reference internal" href="../declarative_config.html"><span class="std std-ref">declarative mappings</span></a> 以使其与
<code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code> 对象对其进行*instrumented* 后的结构匹配。
对于Orm映射本身以及使用该类的代码，这允许Mypy工具的行为是可理解的，
否则会基于当前声明的已知方法**无法进行声明映射**。</p>
<p>与为库如`dataclasses &lt;<a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">https://docs.python.org/3/library/dataclasses.html</a>&gt;`_ 所需
的类似插件相似，插件与在运行时动态修改类的类似插件不同。插件在以下
主要领域发挥作用：</p>
<ul class="simple">
<li><p>使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code> 生成“Base”的动态类将继承其子类的
映射确定。它还可以在 :ref:<a href="#id7"><span class="problematic" id="id8">`</span></a>orm_declarative_decorator`中描述的类装饰器
方法中实现。</p></li>
<li><p>针对以“内联”样式定义的ORM映射属性的类型推理。例如，在上面的例子中，
<code class="docutils literal notranslate"><span class="pre">User</span></code> 类的 <code class="docutils literal notranslate"><span class="pre">id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性。这包括 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实例将使用类型
<code class="docutils literal notranslate"><span class="pre">int``表示</span> <span class="pre">``id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">str</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">name</span></code>。这还包括当访问 <code class="docutils literal notranslate"><span class="pre">User.id</span></code>
和 <code class="docutils literal notranslate"><span class="pre">User.name</span></code> 类级别属性时（如上面的 <code class="docutils literal notranslate"><span class="pre">select()</span></code> 语句中），它们与
派生自 <a class="reference internal" href="../internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a> 的 SQL 表达式行为兼容。</p></li>
<li><p>为没有显式构造函数的映射类应用 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 方法，该构造函数接受特定类型的
关键字参数（如果已检测到）。</p></li>
</ul>
<p>当Mypy插件处理以上文件时，传递给Mypy工具的静态类定义和Python代码将转化为以下内容：</p>
<blockquote>
<div><p>from sqlalchemy import Column, Integer, String, select
from sqlalchemy.orm import Mapped
from sqlalchemy.orm.decl_api import DeclarativeMeta</p>
<dl>
<dt>class Base(metaclass=DeclarativeMeta):</dt><dd><p>__abstract__ = True</p>
</dd>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”</p>
<dl class="simple">
<dt>id: Mapped[Optional[int]] = Mapped._special_method(</dt><dd><p>Column(Integer, primary_key=True)</p>
</dd>
</dl>
<p>)
name: Mapped[Optional[str]] = Mapped._special_method(Column(String))</p>
<dl class="simple">
<dt>def __init__(self, id: Optional[int] = …, name: Optional[str] = …) -&gt; None:</dt><dd><p>…</p>
</dd>
</dl>
</dd>
</dl>
<p>some_user = User(id=5, name=”user”)</p>
<p>print(f”Username: {some_user.name}”)</p>
<p>select_stmt = select(User).where(User.id.in_([3, 4, 5])).where(User.name.contains(“s”))</p>
</div></blockquote>
<p>以上重要步骤包括：</p>
<ul class="simple">
<li><p><a href="#id9"><span class="problematic" id="id10">``</span></a>Base``类现在明确地定义为使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeMeta</span></code> 类，而不是
动态类。</p></li>
<li><p>在 <a class="reference internal" href="../internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 类中定义具有其特定Python类型的属性，代表Python检查器和
SQLAlchemy orm检查器的兼容性，即从类级别访问这些属性和从实例级别访问这些属性之间
应有的行为不同。</p></li>
<li><p>从声明映射属性分配中删除右侧。因为 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>
类通常会将这些属性替换为 <a class="reference internal" href="../internals.html#sqlalchemy.orm.InstrumentedAttribute" title="sqlalchemy.orm.InstrumentedAttribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstrumentedAttribute</span></code></a> 的特定实例。
原始表达式移动到函数调用中，这将允许仍然可以对其进行类型检查而不会与左侧冲突。
Mypy仅需左侧类型注释即可理解其属性的行为。</p></li>
<li><p>为未包含显式构造函数的映射类添加 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 方法，该函数接受已检测到的所有
映射属性类型的关键字参数。</p></li>
</ul>
</section>
<section id="id11">
<h2>插件的使用<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h2>
<p>以下子章节将介绍迄今为止已考虑为pep-484兼容性的各个用例。</p>
<section id="typeengine">
<h3>基于 TypeEngine 的列的内省<a class="headerlink" href="#typeengine" title="Permalink to this heading">¶</a></h3>
<p>对于包括显式数据类型的映射列，当它们作为内联属性映射时，
映射类型将自动进行内省：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># …</p>
<p>id = Column(Integer, primary_key=True)
name = Column(“employee_name”, String(50), nullable=False)
other_name = Column(String(50))</p>
</dd>
</dl>
</div></blockquote>
<p>以上代码段中的 <code class="docutils literal notranslate"><span class="pre">id</span></code>，<code class="docutils literal notranslate"><span class="pre">name</span></code> 和 <code class="docutils literal notranslate"><span class="pre">other_name</span></code> 的最终类级别数据类型
将被内省为 <code class="docutils literal notranslate"><span class="pre">Mapped[Optional[int]]</span></code>，<code class="docutils literal notranslate"><span class="pre">Mapped[Optional[str]]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Mapped[Optional[str]]</span></code>。
默认情况下，这些类型始终被视为 <code class="docutils literal notranslate"><span class="pre">Optional</span></code>，即使是主键和非空列也是如此。原因是
尽管数据库列“id”和“name”不能为NULL，但Python属性“id”和“name”肯定可以是
在没有显示构造函数的情况下为“None”的情况下：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">id</span>
<span class="go">None</span></pre></div>
</div>
<p>以上列的类型可以明确说明为更清晰的自我文档和可控制的可选类型的两个优点：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># …</p>
<p>id: int = Column(Integer, primary_key=True)
name: str = Column(“employee_name”, String(50), nullable=False)
other_name: Optional[str] = Column(String(50))</p>
</dd>
</dl>
</div></blockquote>
<p>Mypy插件将接受上述``int``, <code class="docutils literal notranslate"><span class="pre">str``和``Optional[str]</span></code>,并将其转换为包围它们的``Mapped[]``类型。
也可以显式使用``Mapped[]``构造函数：</p>
<blockquote>
<div><p>from sqlalchemy.orm import Mapped</p>
<dl>
<dt>class MyClass(Base):</dt><dd><p># …</p>
<p>id: Mapped[int] = Column(Integer, primary_key=True)
name: Mapped[str] = Column(“employee_name”, String(50), nullable=False)
other_name: Mapped[Optional[str]] = Column(String(50))</p>
</dd>
</dl>
</div></blockquote>
<p>当类型是非可选的时，仅表示访问``MyClass`` 的实例时
将被视为非``None``：</p>
<blockquote>
<div><p>mc = MyClass(…)</p>
<p># 将通过mypy –strict测试
name: str = mc.name</p>
</div></blockquote>
<p>对于可选的属性，Mypy认为这种类型必须包含空值
或者是``Optional``：</p>
<blockquote>
<div><p>mc = MyClass(…)</p>
<p># 将通过mypy –strict测试
other_name: Optional[str] = mc.name</p>
</div></blockquote>
<p>无论映射属性被标记为``Optional``或不可选，
<code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 方法的生成仍将**考虑所有关键字都是可选的**。这再次
与验证系统（如Python <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code>）的行为不同，后者将生成一个
与注释匹配的构造函数，其中包括必需和可选属性的注释。</p>
</section>
<section id="id12">
<h3>没有显式类型的列<a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<p>对于包含:class:<a href="#id13"><span class="problematic" id="id14">`</span></a>_schema.ForeignKey`修饰符的列，在SQLAlchemy声明映射中，
它们不需要声明显式数据类型。对于此类属性，插件将需要在左侧指定明确的类型注释：</p>
<blockquote>
<div><p># .. 其他导入项
from sqlalchemy.sql.schema import ForeignKey</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”</p>
<p>id = Column(Integer, primary_key=True)
name = Column(String)</p>
</dd>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”</p>
<p>id = Column(Integer, primary_key=True)
user_id = Column(ForeignKey(“user.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>插件将以以下方式输出消息：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ mypy test3.py --strict
test3.py:20: error: [SQLAlchemy Mypy plugin] Can&#39;t infer type from
ORM mapped expression assigned to attribute &#39;user_id&#39;; please specify a
Python type or Mapped[&lt;python type&gt;] on the left hand side.
Found 1 error in 1 file (checked 1 source file)</pre></div>
</div>
<p>为解决此问题，需要在 <code class="docutils literal notranslate"><span class="pre">Address.user_id</span></code> 列上应用明确的类型注释：</p>
<blockquote>
<div><dl>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”</p>
<p>id = Column(Integer, primary_key=True)
user_id: int = Column(ForeignKey(“user.id”))</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id15">
<h3>映射带有命令性表的列<a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<p>在 <span class="xref std std-ref">imperative table style</span> 中，
<a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 定义包含在:class:<cite>_schema.Table</cite> 构造函数内，该构造函数与映射属性本身分离。
插件不考虑此 <a class="reference internal" href="../../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>，而是支持可以使用的显式完整注释，必须使用 <a class="reference internal" href="../internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>
类来将其识别为映射属性：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><dl class="simple">
<dt>__table__ = Table(</dt><dd><p>“mytable”,
Base.metadata,
Column(Integer, primary_key=True),
Column(“employee_name”, String(50), nullable=False),
Column(String(50)),</p>
</dd>
</dl>
<p>)</p>
<p>id: Mapped[int]
name: Mapped[str]
other_name: Mapped[Optional[str]]</p>
</dd>
</dl>
</div></blockquote>
<p>上述 <a class="reference internal" href="../internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 注释被认为是映射列，并将包含在默认构造函数中，同时为在类级别和实例级别正确提供
<code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 的输入行为提供了正确的定型概要。</p>
</section>
<section id="id16">
<h3>映射关系<a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h3>
<p>该插件仅能支持极少的使用类型推理检测关系类型能力。对于不能检测到其类型的所有这些关系，它将发出
⼀个 informative error message ，即可在所有案例中明确指定
类型，无论使用:class:<cite>_orm.Mapped`类还是可以忽略其进行内联声明的类型。插件还需要确定关系是引用集合
还是标量，其中依赖于 :paramref:`_orm.relationship.uselist</cite> 和 / 或 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code>
参数的显式值。如果这两个参数都不存在，则需要使用显式类型说明，就像 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 目标类型是字符串或callable，而不是类一样：</p>
<blockquote>
<div><dl>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”</p>
<p>id = Column(Integer, primary_key=True)
name = Column(String)</p>
</dd>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”</p>
<p>id = Column(Integer, primary_key=True)
user_id: int = Column(ForeignKey(“user.id”))</p>
<p>user = relationship(User)</p>
</dd>
</dl>
</div></blockquote>
<p>以上映射将产生以下错误：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>test3.py:22: error: [SQLAlchemy Mypy plugin] Can&#39;t infer scalar or
collection for ORM mapped expression assigned to attribute &#39;user&#39;
if both &#39;uselist&#39; and &#39;collection_class&#39; arguments are absent from the
relationship(); please specify a type annotation on the left hand side.
Found 1 error in 1 file (checked 1 source file)</pre></div>
</div>
<p>通过使用 <code class="docutils literal notranslate"><span class="pre">relationship(User,</span> <span class="pre">uselist=False)</span></code> 或提供类型（在这种情况下为单个标量``User`` 对象），
可以解决此问题：</p>
<blockquote>
<div><dl>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”</p>
<p>id = Column(Integer, primary_key=True)
user: User = relationship(User)</p>
</dd>
</dl>
</div></blockquote>
<p>对于集合，类似的模式适用，如果找不到 <code class="docutils literal notranslate"><span class="pre">uselist=True</span></code> 或 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.collection_class</span></code>，
则可以使用诸如``List``的注释。可以将类的字符串名称作为注释中支持的pep-484，确保采用
使用该类的 <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/#runtime-or-type-checking">TYPE_CHECKING block</a> 的类导入：</p>
<blockquote>
<div><p>from typing import TYPE_CHECKING, List</p>
<p>from .mymodel import Base</p>
<dl>
<dt>if TYPE_CHECKING:</dt><dd><p># 如果关系目标位于另一个模块中，
# 当无法在运行时正常导入该模块时
from .myaddressmodel import Address</p>
</dd>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”</p>
<p>id = Column(Integer, primary_key=True)
name = Column(String)
addresses: List[“Address”] = relationship(“Address”)</p>
</dd>
</dl>
</div></blockquote>
<p>与列一样， <a class="reference internal" href="../internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 类也可以显式应用于这些标注：</p>
<blockquote>
<div><dl>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”</p>
<p>id = Column(Integer, primary_key=True)
name = Column(String)</p>
<p>addresses: Mapped[List[“Address”]] = relationship(“Address”, back_populates=”user”)</p>
</dd>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”</p>
<p>id = Column(Integer, primary_key=True)
user_id: int = Column(ForeignKey(“user.id”))</p>
<p>user: Mapped[User] = relationship(User, back_populates=”addresses”)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="declared-attrdeclarative-mixins">
<span id="mypy-declarative-mixins"></span><h3>使用&#64;declared_attr和Declarative Mixins<a class="headerlink" href="#declared-attrdeclarative-mixins" title="Permalink to this heading">¶</a></h3>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code> 类允许在类级别函数中声明declarative映射属性，当使用:ref:<cite>declarative mixins &lt;orm_mixins_toplevel&gt;`时特别有用。
对于这些函数，函数的返回值应使用``Mapped[]`</cite> 构造函数来注释，或指示函数返回的确切对象类型。
另外，没有映射的“mixin”类（即不扩展 <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code> 类，也没有使用任何方法如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">registry.mapped()</span></code> 进行映射）
应使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_mixin()</span></code> 装饰器进行修饰，它为Mypy插件提供了关于特定类用作declarative混合类的提示：</p>
<blockquote>
<div><p>from sqlalchemy.orm import declarative_mixin, declared_attr</p>
<p>&#64;declarative_mixin
class HasUpdatedAt:</p>
<blockquote>
<div><p>&#64;declared_attr
def updated_at(cls) -&gt; Column[DateTime]:  # uses Column</p>
<blockquote>
<div><p>return Column(DateTime)</p>
</div></blockquote>
</div></blockquote>
<p>&#64;declarative_mixin
class HasCompany:</p>
<blockquote>
<div><p>&#64;declared_attr
def company_id(cls) -&gt; Mapped[int]:  # uses Mapped</p>
<blockquote>
<div><p>return Column(ForeignKey(“company.id”))</p>
</div></blockquote>
<p>&#64;declared_attr
def company(cls) -&gt; Mapped[“Company”]:</p>
<blockquote>
<div><p>return relationship(“Company”)</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>class Employee(HasUpdatedAt, HasCompany, Base):</dt><dd><p>__tablename__ = “employee”</p>
<p>id = Column(Integer, primary_key=True)
name = Column(String)</p>
</dd>
</dl>
</div></blockquote>
<p>请注意，像 <code class="docutils literal notranslate"><span class="pre">HasCompany.company</span></code> 这样的方法的实际返回类型与其注释之间的不匹配之处。
插件将所有 <code class="docutils literal notranslate"><span class="pre">&#64;declared_attr</span></code> 函数转换为简单的注释属性，以避免此种复杂性：</p>
<blockquote>
<div><p># Mypy看到的内容
class HasCompany:</p>
<blockquote>
<div><p>company_id: Mapped[int]
company: Mapped[“Company”]</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="dataclasses">
<h3>结合Dataclasses或其他类型敏感的属性系统<a class="headerlink" href="#dataclasses" title="Permalink to this heading">¶</a></h3>
<p>Python dataclasses 集成的示例在 <a class="reference internal" href="../dataclasses.html#orm-declarative-dataclasses"><span class="std std-ref">将ORM映射应用于现有的数据类（传统数据类使用）</span></a> 中显示了一个问题：
Python dataclasses 需要一个显式的类型，它将使用它构建类，而给定的值在每个分配语句中都是有意义的。
更具体地说，类必须明确声明如下才能被dataclasses接受：</p>
<blockquote>
<div><p>mapper_registry: registry = registry()</p>
<p>&#64;mapper_registry.mapped
&#64;dataclass
class User:</p>
<blockquote>
<div><dl class="simple">
<dt>__table__ = Table(</dt><dd><p>“user”,
mapper_registry.metadata,
Column(“id”, Integer, primary_key=True),
Column(“name”, String(50)),
Column(“fullname”, String(50)),
Column(“nickname”, String(12)),</p>
</dd>
</dl>
<p>)
id: int = field(init=False)
name: Optional[str] = None
fullname: Optional[str] = None
nickname: Optional[str] = None
addresses: List[Address] = field(default_factory=list)</p>
<dl class="simple">
<dt>__mapper_args__ = {  # type: ignore</dt><dd><p>“properties”: {“addresses”: relationship(“Address”)}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>我们不能对属性“id”，“name”等应用 <code class="docutils literal notranslate"><span class="pre">Mapped[]</span></code> 类型，因为它们将被 <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> 装饰器拒绝。
此外，Mypy还有另一个针对dataclasses的插件，可以干扰到我们所做的事情。</p>
<dl>
<dt>上述类将通过Mypy的类型检查而不会产生问题。我们错过的唯一东西是``User`` 上的属性并</dt><dd><p>不能用于SQL表达式，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span></pre></div>
</div>
</dd>
</dl>
<p>为解决此问题，插件有一个附加功能，即我们可以指定一个额外的属性 <code class="docutils literal notranslate"><span class="pre">_mypy_mapped_attrs</span></code>，它是一个
包含类级对象或它们的字符串名称的列表。此属性可以在 <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> 变量中条件化：</p>
<blockquote>
<div><p>&#64;mapper_registry.mapped
&#64;dataclass
class User:</p>
<blockquote>
<div><dl class="simple">
<dt>__table__ = Table(</dt><dd><p>“user”,
mapper_registry.metadata,
Column(“id”, Integer, primary_key=True),
Column(“name”, String(50)),
Column(“fullname”, String(50)),
Column(“nickname”, String(12)),</p>
</dd>
</dl>
<p>)
id: int = field(init=False)
name: Optional[str] = None
fullname: Optional[str]
nickname: Optional[str]
addresses: List[Address] = field(default_factory=list)</p>
<dl class="simple">
<dt>if TYPE_CHECKING:</dt><dd><p>_mypy_mapped_attrs = [id, name, “fullname”, “nickname”, addresses]</p>
</dd>
<dt>__mapper_args__ = {  # type: ignore</dt><dd><p>“properties”: {“addresses”: relationship(“Address”)}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>使用以上建议，列在``_mypy_mapped_attrs`` 字段中将被赋予等效的 <a class="reference internal" href="../internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 类型信息，
以便当以class-bound上下文使用``User`` 类时，<code class="docutils literal notranslate"><span class="pre">User</span></code> 类会像SQLAlchemy映射类一样行为。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="declarative/index.html" title="previous chapter">声明式扩展</a>
        Next:
        <a href="mutable.html" title="next chapter">变异跟踪</a>

    <div id="docs-copyright">
        &copy; <a href="../../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:47:29

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../../_static/init.js"></script>


    </body>
</html>


