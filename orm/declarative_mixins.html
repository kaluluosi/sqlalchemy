<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    使用 Mixin 构建映射层次结构
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="通过声明性方式映射类" href="declarative_mapping.html" />
        <link rel="next" title="与dataclasses和attrs集成" href="dataclasses.html" />
        <link rel="prev" title="使用声明式进行Mapper配置" href="declarative_config.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span><ul>
<li><span class="link-container"><a class="reference external" href="mapping_styles.html">ORM映射类概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mapping.html">通过声明性方式映射类</a></span><ul>
<li><span class="link-container"><a class="reference external" href="declarative_styles.html">声明式映射风格</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_tables.html">使用Declarative配置Table</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_config.html">使用声明式进行Mapper配置</a></span></li>
<li class="selected"><span class="link-container"><strong>使用 Mixin 构建映射层次结构</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">混合使用和基础类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id2">混入列</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-mixins-relationships">混合使用关系</a></span></li>
<li><span class="link-container"><a class="reference external" href="#decl-mixin-inheritance">使用Mixin类和基类与 映射继承模式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">使用 Mixin 创建索引</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="dataclasses.html">与dataclasses和attrs集成</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_sql_expr.html">将SQL表达式映射为属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_attributes.html">更改属性行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="composites.html">复合列类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="inheritance.html">映射类继承层次结构</a></span></li>
<li><span class="link-container"><a class="reference external" href="nonstandard_mappings.html">非传统映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="versioning.html">配置版本计数器</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapping_api.html">类映射API</a></span></li>
<li><span class="link-container"><a class="reference external" href="scalar_mapping.html">映射SQL表达式</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="declarative_config.html" title="previous chapter">使用声明式进行Mapper配置</a></li>
                <li><b>Next:</b>
                <a href="dataclasses.html" title="next chapter">与dataclasses和attrs集成</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="mapper_config.html" title="ORM映射类配置">ORM映射类配置</a></li>
                    <ul><li><a href="declarative_mapping.html" title="通过声明性方式映射类">通过声明性方式映射类</a></li>
                </ul>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#mixin">使用 Mixin 构建映射层次结构</a><ul>
<li><a class="reference internal" href="#id1">混合使用和基础类</a></li>
<li><a class="reference internal" href="#id2">混入列</a></li>
<li><a class="reference internal" href="#orm-declarative-mixins-relationships">混合使用关系</a></li>
<li><a class="reference internal" href="#decl-mixin-inheritance">使用Mixin类和基类与 映射继承模式</a></li>
<li><a class="reference internal" href="#id5">使用 Mixin 创建索引</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-declarative_mixins" >
        
<section id="mixin">
<h1>使用 Mixin 构建映射层次结构<a class="headerlink" href="#mixin" title="Permalink to this heading">¶</a></h1>
<p>使用   <a class="reference internal" href="mapping_styles.html#orm-declarative-mapping"><span class="std std-ref">Declarative</span></a>  风格映射类时，常见的需求是共享普通功能，
比如特定的列、表或映射器选项、命名方案或其他映射属性。使用声明性映射时，可以通过使用  <span class="xref std std-term">mixin 类</span>  或增强声明性基类本身的方法来支持此约定。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>除了 mixin 类之外，还可以使用  <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a>  中的 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型在多个类之间共享公共列选项；请参见   <a class="reference internal" href="declarative_tables.html#orm-declarative-mapped-column-type-map-pep593"><span class="std std-ref">将多个类型配置映射到 Python 类型</span></a>  和   <a class="reference internal" href="declarative_tables.html#orm-declarative-mapped-column-pep593"><span class="std std-ref">将整个列声明映射到Python类型</span></a> ，了解关于这些 SQLAlchemy 2.0 功能的背景信息。</p>
</div>
<p>以下是一些常见的混用习惯的示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">declared_attr</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">CommonMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;定义一系列通用元素，这些元素可以通过使用这个类作为 mixin 类，并应用到映射类中。</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@declared_attr</span><span class="o">.</span><span class="n">directive</span>
    <span class="k">def</span> <span class="nf">__tablename__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mysql_engine&quot;</span><span class="p">:</span> <span class="s2">&quot;InnoDB&quot;</span><span class="p">}</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;eager_defaults&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">HasLogRecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;标记类，该类与 LogRecord 类之间有一对多关系。&quot;&quot;&quot;</span>

    <span class="n">log_record_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;logrecord.id&quot;</span><span class="p">))</span>

    <span class="nd">@declared_attr</span>
    <span class="k">def</span> <span class="nf">log_record</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;LogRecord&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;LogRecord&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LogRecord</span><span class="p">(</span><span class="n">CommonMixin</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">log_info</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">CommonMixin</span><span class="p">,</span> <span class="n">HasLogRecord</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>上述示例说明了一个名为 <code class="docutils literal notranslate"><span class="pre">MyModel</span></code> 的类，该类在其基类中包括两个 Mixin 类 <code class="docutils literal notranslate"><span class="pre">CommonMixin</span></code> 和 <code class="docutils literal notranslate"><span class="pre">HasLogRecord</span></code>，以及一个补充类 <code class="docutils literal notranslate"><span class="pre">LogRecord</span></code>，它也包括 <code class="docutils literal notranslate"><span class="pre">CommonMixin</span></code>，演示了一系列对于 Mixin 和基类都支持的构造的构造，包括：</p>
<ul class="simple">
<li><p>使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 、  <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  或   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  声明的列将从 mixin 或基类复制到要映射的目标类上；上述示例通过列属性 <code class="docutils literal notranslate"><span class="pre">CommonMixin.id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">HasLogRecord.log_record_id</span></code> 进行了说明。</p></li>
<li><p>Declarative 指令，如 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__mapper_args__</span></code> 可以分配给 mixin 或基类，在继承自 mixin 或基类的任何类中都会自动生效。上述示例使用了 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__mapper_args__</span></code> 属性说明了这个特性。</p></li>
<li><p>所有 Declarative 指令，包括所有的 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code>, <code class="docutils literal notranslate"><span class="pre">__table__</span></code>, <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__mapper_args__</span></code>, 都可以使用用户定义的类方法来实现，这些方法被修饰符   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  装饰(具体见  <code class="xref py py-attr docutils literal notranslate"><span class="pre">declared_attr.directive</span></code>  成员)。上述例子使用了一个 <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">__tablename__(cls)</span></code> 类方法，动态地生成一个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  名称；当应用于 <code class="docutils literal notranslate"><span class="pre">MyModel</span></code> 类时，表名将生成为 <code class="docutils literal notranslate"><span class="pre">&quot;mymodel&quot;</span></code>，而当应用于 <code class="docutils literal notranslate"><span class="pre">LogRecord</span></code> 类时，表名将生成为 <code class="docutils literal notranslate"><span class="pre">&quot;logrecord&quot;</span></code>。</p></li>
<li><p>也可以使用用户定义的类方法，在将修饰符   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  调用此类方法时，在要映射的目标类上生成其他 ORM 属性，如   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 。上述例子使用一个 many-to-one   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  生成一个映射对象，该映射对象称为 <code class="docutils literal notranslate"><span class="pre">LogRecord</span></code>。</p></li>
</ul>
<p>上述特性都可以通过一个   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  示例来展示：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">MyModel</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">MyModel</span><span class="o">.</span><span class="n">log_record</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">mymodel</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">mymodel</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">mymodel</span><span class="p">.</span><span class="n">log_record_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">mymodel</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">logrecord</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">logrecord</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mymodel</span><span class="p">.</span><span class="n">log_record_id</span>
</div></pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  的示例将尝试说明每个方法示例的正确  <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  注释。对于   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  函数，注释使用是 <strong>完全可选的</strong>，并且不会被 Declarative 使用；但是，这些注释是必需的，以便通过 Mypy <code class="docutils literal notranslate"><span class="pre">--strict</span></code> 类型检查。</p>
<p>此外，上面说明的  <code class="xref py py-attr docutils literal notranslate"><span class="pre">declared_attr.directive</span></code>  细分成员也是可选的，而且只对  <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  类型工具具有重要意义，因为它调整了在创建方法以覆盖 Declarative 指令时所预期的返回类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>作为 SQLAlchemy ORM 的  <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  类型支持的一部分，添加了  <code class="xref py py-attr docutils literal notranslate"><span class="pre">declared_attr.directive</span></code> ，以区分   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  属性和 Declarative 配置属性。</p>
</div>
</div>
<section id="id1">
<h2>混合使用和基础类<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>除了使用纯混用外，在这个部分中，这个大多数的技术也可以应用于基类本身的构建上，这些基类的模式应该应用于从特定基础类派生的所有类。下面的例子用了之前一节的 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 类来演示一些例子：</p>
<blockquote>
<div><p>from sqlalchemy import ForeignKey
from sqlalchemy.orm import declared_attr
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>“””定义一系列通用元素，这些元素可以应用于映射类
使用此类作为基类。</p>
<p>“””</p>
<p>&#64;declared_attr.directive
def __tablename__(cls) -&gt; str:</p>
<blockquote>
<div><p>return cls.__name__.lower()</p>
</div></blockquote>
<p>__table_args__ = {“mysql_engine”: “InnoDB”}
__mapper_args__ = {“eager_defaults”: True}</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)</p>
</dd>
<dt>class HasLogRecord:</dt><dd><p>“””标记类，该类与 LogRecord 类之间有一对多关系。”””</p>
<p>log_record_id: Mapped[int] = mapped_column(ForeignKey(“logrecord.id”))</p>
<p>&#64;declared_attr
def log_record(self) -&gt; Mapped[“LogRecord”]:</p>
<blockquote>
<div><p>return relationship(“LogRecord”)</p>
</div></blockquote>
</dd>
<dt>class LogRecord(Base):</dt><dd><p>log_info: Mapped[str]</p>
</dd>
<dt>class MyModel(HasLogRecord, Base):</dt><dd><p>name: Mapped[str]</p>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，每个 <code class="docutils literal notranslate"><span class="pre">MyModel</span></code> 和 <code class="docutils literal notranslate"><span class="pre">LogRecord</span></code> 的基类将从它自己中继承所有的 Declarative 指令和列定义。下面是多继承和混用的各个情况无固定的规则。普通的 Python 方法解析规则适用，同时对于以上示例，以下用法同样适用：</p>
<blockquote>
<div><dl class="simple">
<dt>class MyModel(Base, HasLogRecord, CommonMixin):</dt><dd><p>name: Mapped[str] = mapped_column()</p>
</dd>
</dl>
</div></blockquote>
<p>这对于 Python 方法解析规则来说同样适用，以上面的示例为例，也可以按照下面的方式命名：</p>
<p>..tip::尽管上面的示例使用了基于   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注释类的   <a class="reference internal" href="declarative_tables.html#orm-declarative-mapped-column"><span class="std std-ref">Annotated Declarative Table</span></a>  表单，但 mixin 类也完全可以与非注释和遗留 Declarative 表单混合使用，例如，当直接使用   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  时，而不是使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>对于 1.4 系列的 SQLAlchemy 用户，他们可能一直在使用   <a class="reference internal" href="extensions/mypy.html"><span class="std std-ref">mypy plugin</span></a> ，现在无需使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_mixin()</span></code>  类装饰器来标记声明性 mixin，只需要不使用 mypy 插件即可。</p>
</div>
</section>
<section id="id2">
<h2>混入列<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>在混用情况下，可以在使用   <a class="reference internal" href="declarative_tables.html#orm-declarative-table"><span class="std std-ref">declarative table</span></a>  风格的配置时指示列，以便从混用复制到 Declarative 过程生成的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  中。   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 、  <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  和   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  构造中的所有三种形式都可以在声明式 mixin 中进行声明：</p>
<blockquote>
<div><dl>
<dt>class TimestampMixin:</dt><dd><p>created_at: Mapped[datetime] = mapped_column(default=func.now())
updated_at: Mapped[datetime]</p>
</dd>
<dt>class MyModel(TimestampMixin, Base):</dt><dd><p>__tablename__ = “test”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str]</p>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，所有包含 <code class="docutils literal notranslate"><span class="pre">TimestampMixin</span></code> 的声明式类都将自动包含一个“created_at”列，该列将在所有行插入时应用时间戳，以及一个“updated_at”列，该列不包含默认值，为了示例目的，如果有默认值(有默认值，我们将使用  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.onupdate" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.onupdate</span></code></a>  参数，该参数被   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  接受)。 这些列构造在始发 mixin 或基类中始终**从始发 mixin 或基类复制**，以便同一 mixin/base 类可应用于任意数量的目标类，每个目标类都会有自己的列构造。</p>
<p>除了   <code class="xref py py-class docutils literal notranslate"><span class="pre">relationship</span></code>  之外，Declarative Mixin 的所有形式的 Declarative 表单都受支持，例如，以下 Declarative 列形式都是可以接受的：</p>
<ul>
<li><p><strong>带注释的属性</strong>——带或不带   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TimestampMixin</span><span class="p">:</span>
    <span class="n">created_at</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="n">updated_at</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span></pre><div class="code-annotations-key"></div></div>
</div>
</li>
<li><p><strong>mapped_column</strong>——带或不带   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TimestampMixin</span><span class="p">:</span>
    <span class="n">created_at</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="n">updated_at</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">()</span></pre><div class="code-annotations-key"></div></div>
</div>
</li>
<li><p><strong>Column</strong>——遗留的 Declarative 形式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TimestampMixin</span><span class="p">:</span>
    <span class="n">created_at</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="n">updated_at</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">DateTime</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</li>
</ul>
<p>在上述所有形式中，Declarative 处理 mixin 类上的基于列的属性，通过创建**构造的复制品**，该构造的复制品然后应用于目标类。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>表示配置API现在可以容纳  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  构造，并且无需使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code>  即可使用 mixins 使用 ForeignKey 元素的列。以前的限制阻止具有   <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>  元素的列直接在 mixins 中使用，现在已经删除了。</p>
</div>
</section>
<section id="orm-declarative-mixins-relationships">
<span id="id3"></span><h2>混合使用关系<a class="headerlink" href="#orm-declarative-mixins-relationships" title="Permalink to this heading">¶</a></h2>
<p>由   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  创建的关系是通过声明性 mixin 类来提供的，它使用了   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  方法，从而消除了复制关系及其可能绑定列内容所造成的任何歧义。下面是一个示例，演示了如何将一个外键列和一个关系组合在一起，以便两个类，<code class="docutils literal notranslate"><span class="pre">Foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Bar</span></code>，都可以通过多对一引用公共目标类：</p>
<blockquote>
<div><p>from sqlalchemy import ForeignKey
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import declared_attr
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class RefTargetMixin:</dt><dd><p>target_id: Mapped[int] = mapped_column(ForeignKey(“target.id”))</p>
<p>&#64;declared_attr
def target(cls) -&gt; Mapped[“Target”]:</p>
<blockquote>
<div><p>return relationship(“Target”)</p>
</div></blockquote>
</dd>
<dt>class Foo(RefTargetMixin, Base):</dt><dd><p>__tablename__ = “foo”
id: Mapped[int] = mapped_column(primary_key=True)</p>
</dd>
<dt>class Bar(RefTargetMixin, Base):</dt><dd><p>__tablename__ = “bar”
id: Mapped[int] = mapped_column(primary_key=True)</p>
</dd>
<dt>class Target(Base):</dt><dd><p>__tablename__ = “target”
id: Mapped[int] = mapped_column(primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
<p>有了上述的映射，每个 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 都含有通过 <code class="docutils literal notranslate"><span class="pre">.target</span></code> 访问的映射到 <code class="docutils literal notranslate"><span class="pre">Target</span></code> 的关系：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Foo</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">target_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">target_id</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Bar</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Bar</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">target_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">target_id</span>
</div></pre></div>
</div>
<p>特殊参数，例如  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.primaryjoin</span></code> ，也可以在混用类方法中使用，这些类方法通常需要引用正在被映射的类。对于本地映射列需要引用的方案，在普通情况下，这些列的属性是作为   <code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code>  装饰符的属性在声明式类上展示的，所以它们可以用于创建新属性，如下面的例子，将两个列相加：</p>
<blockquote>
<div><p>from sqlalchemy.orm import column_property
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import declared_attr
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class SomethingMixin:</dt><dd><p>x: Mapped[int]
y: Mapped[int]</p>
<p>&#64;declared_attr
def x_plus_y(cls) -&gt; Mapped[int]:</p>
<blockquote>
<div><p>return column_property(cls.x + cls.y)</p>
</div></blockquote>
</dd>
<dt>class Something(SomethingMixin, Base):</dt><dd><p>__tablename__ = “something”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
<p>在上述示例中，我们可以在使用 <code class="docutils literal notranslate"><span class="pre">Something.x_plus_y</span></code> 时产生全表达式：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Something</span><span class="o">.</span><span class="n">x_plus_y</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">something</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">something</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">something</span>
</div></pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  装饰符使其被装饰的可调用对象的行为完全像 classmethod 一样。但是，诸如 <a class="reference external" href="https://github.com/microsoft/pylance-release">Pylance</a> 这样的类型工具可能无法识别这一点，这有时会导致它在函数体内访问变量 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 时发出警告。要在发现这种情况时解决此问题，可以将 <code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 装饰符与   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  直接结合使用，如下所示：</p>
<blockquote>
<div><dl>
<dt>class SomethingMixin:</dt><dd><p>x: Mapped[int]
y: Mapped[int]</p>
<p>&#64;declared_attr
&#64;classmethod
def x_plus_y(cls) -&gt; Mapped[int]:</p>
<blockquote>
<div><p>return column_property(cls.x + cls.y)</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>作为  <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  类型支持的一部分，  <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  可以与 <code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 修饰的函数结合使用，以帮助  <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  集成，如有必要。</p>
</div>
</div>
</section>
<section id="decl-mixin-inheritance">
<span id="id4"></span><h2>使用Mixin类和基类与 映射继承模式<a class="headerlink" href="#decl-mixin-inheritance" title="Permalink to this heading">¶</a></h2>
<p>在处理映射继承模式时，可以使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  在 mixin 类上定义函数，也可以对基类进行增强和未映射的超类，实现一些附加的功能。</p>
<p>在 mixins 或基类上定义由   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  装饰符装饰的函数时，存在以下重要区别：这些函数生成 Declarative 风格的特殊名称，例如 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code>，<code class="docutils literal notranslate"><span class="pre">__mapper_args__</span></code>，与可能展示为映射属性的函数不同，如   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  和   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 。<strong>定义 Declarative 指令</strong> 的函数被**针对继承层次结构中的每个子类**调用，而为类生成**映射属性** 的函数仅在继承层次结构中的**第一个映射的超类**上调用。</p>
<p>在母类中定义 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> 函数以生成映射的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  名称是一个常见的 mixin 方案，在这种情况下，我们需要注意每个类的**列选项具有这个特征**: 如果我们想在一个除第一个外其它的类中添加一个新的列，我们必须手动为这个类添加列定义，否则 Declarative 映射信息将不完整。 这在下一个部分中说明。</p>
<p>使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code>  生成特定于每个表的子列和属性</p>
<p>在使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  与   <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code>  类一起使用时，有一种技术可以应用于继承重载列方案，使得在超类里面定义的列属性在子类中也能被复用。 为了将 <code class="docutils literal notranslate"><span class="pre">id</span></code> 属性向下分配到子类中，我们可以在下面的 mixin 基本类型中添加一个叫做 <code class="docutils literal notranslate"><span class="pre">HasIdMixin</span></code> 的基类：</p>
<blockquote>
<div><dl>
<dt>class HasIdMixin:</dt><dd><p>id: Mapped[int] = mapped_column(primary_key=True)</p>
</dd>
<dt>class Person(HasIdMixin, Base):</dt><dd><p>discriminator: Mapped[str]
__mapper_args__ = {“polymorphic_on”: “discriminator”}</p>
</dd>
<dt>class Engineer(HasIdMixin, Person):</dt><dd><p>id: Mapped[int] = mapped_column(ForeignKey(“person.id”), primary_key=True)</p>
<p>primary_language: Mapped[str]</p>
<p>__mapper_args__ = {“polymorphic_identity”: “engineer”}</p>
</dd>
<dt>class Manager(Person):</dt><dd><p>__mapper_args__ = {“polymorphic_identity”: “Manager”}</p>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，只有 <code class="docutils literal notranslate"><span class="pre">Person</span></code> 类接收了一个名叫 <code class="docutils literal notranslate"><span class="pre">id</span></code> 的列，映射将在 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 类上失败，因为它没有定义一个主键。
通常，在联结表继承中，我们希望在每个子类中都有明确定义的列名。 但是在这种情况下，我们可能希望每个表上都有一个名为 <code class="docutils literal notranslate"><span class="pre">id</span></code> 的列，并让它们通过外键相互引用。我们可以通过使用  <code class="xref py py-attr docutils literal notranslate"><span class="pre">declared_attr.cascading</span></code>  修饰符，在实践中为 mixin [前]定义的组及其基类的构造函数提供支持。它指示该函数应该**针对继承层次结构中的每个类**调用，几乎与 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> 一样（请参阅下面的警告）。</p>
<blockquote>
<div><dl>
<dt>class HasIdMixin:</dt><dd><p>&#64;declared_attr.cascading
def id(cls) -&gt; Mapped[int]:</p>
<blockquote>
<div><dl class="simple">
<dt>if has_inherited_table(cls):</dt><dd><p>return mapped_column(ForeignKey(“person.id”), primary_key=True)</p>
</dd>
<dt>else:</dt><dd><p>return mapped_column(Integer, primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>class Person(HasIdMixin, Base):</dt><dd><p>discriminator: Mapped[str]
__mapper_args__ = {“polymorphic_on”: “discriminator”}</p>
</dd>
<dt>class Engineer(Person):</dt><dd><p>primary_language: Mapped[str]
__mapper_args__ = {“polymorphic_identity”: “engineer”}</p>
</dd>
<dt>class Manager(Person):</dt><dd><p>__mapper_args__ = {“polymorphic_identity”: “Manager”}</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">declared_attr.cascading</span></code>  功能目前**不允许**一个子类用不同的函数或值覆盖该属性的值。这是``&#64;declared_attr`` 被解析的内部方法目前的限制条件，如果检测到这种情况，则会发出警告。此限制仅适用于 ORM 映射列、relationship 和其他   <a class="reference internal" href="internals.html#sqlalchemy.orm.MapperProperty" title="sqlalchemy.orm.MapperProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapperProperty</span></code></a>  类型的属性。它**不**适用于 Declarative 指令，如 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code>, <code class="docutils literal notranslate"><span class="pre">__mapper_args__</span></code> 等，这些指令的解析方式与 <code class="docutils literal notranslate"><span class="pre">(MapperProperty)</span></code> 样式的属性不同。从多个 Mixin 中组合表/映射器参数</p>
</div>
<hr class="docutils" />
<p>在使用声明性 Mixin 指定 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 或 <code class="docutils literal notranslate"><span class="pre">__mapper_args__</span></code> 的情况下，您可能希望将一些参数从几个 Mixin 中与您希望在类本身上定义的参数结合起来。在这里可以使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">declared_attr</span></code>  装饰器创建用户定义的排序例程，以从多个集合中提取参数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">declarative_mixin</span><span class="p">,</span> <span class="n">declared_attr</span>


<span class="k">class</span> <span class="nc">MySQLSettings</span><span class="p">:</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mysql_engine&quot;</span><span class="p">:</span> <span class="s2">&quot;InnoDB&quot;</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">MyOtherMixin</span><span class="p">:</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="s2">&quot;foo&quot;</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">MySQLSettings</span><span class="p">,</span> <span class="n">MyOtherMixin</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_model&quot;</span>

    <span class="nd">@declared_attr</span>
    <span class="k">def</span> <span class="nf">__table_args__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">dict</span><span class="p">()</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">MySQLSettings</span><span class="o">.</span><span class="n">__table_args__</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">MyOtherMixin</span><span class="o">.</span><span class="n">__table_args__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</section>
<section id="id5">
<h2>使用 Mixin 创建索引<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>要定义应用于从 Mixin 派生的所有表的命名的、可能是多列的   <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> ，可使用 “inline” 形式的   <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>  并将其作为 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 的一部分建立:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyMixin</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>

    <span class="nd">@declared_attr</span>
    <span class="k">def</span> <span class="nf">__table_args__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;test_idx_</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">__tablename__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">),)</span>


<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">MyMixin</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;atable&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="declarative_config.html" title="previous chapter">使用声明式进行Mapper配置</a>
        Next:
        <a href="dataclasses.html" title="next chapter">与dataclasses和attrs集成</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:43:55

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


