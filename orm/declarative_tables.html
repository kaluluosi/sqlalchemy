<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    使用Declarative配置Table
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="通过声明性方式映射类" href="declarative_mapping.html" />
        <link rel="next" title="使用声明式进行Mapper配置" href="declarative_config.html" />
        <link rel="prev" title="声明式映射风格" href="declarative_styles.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span><ul>
<li><span class="link-container"><a class="reference external" href="mapping_styles.html">ORM映射类概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mapping.html">通过声明性方式映射类</a></span><ul>
<li><span class="link-container"><a class="reference external" href="declarative_styles.html">声明式映射风格</a></span></li>
<li class="selected"><span class="link-container"><strong>使用Declarative配置Table</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#mapped-column-declarative-table">使用 <code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的Declarative Table</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#declarative-table-mapped-column">在类型注释中使用注释式的Declarative Table (<code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的类型注释形式)</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#mapped-column-mapped"><code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 从 <code class="docutils literal notranslate"><span class="pre">Mapped</span></code> 注释中派生类型和可空性</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-mapped-column-type-map">自定义类型映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python">将多个类型配置映射到 Python 类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-mapped-column-pep593">将整个列声明映射到Python类型</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#enums">本机 Enums 和命名</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">更改默认枚举的配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="#enum-enum-typing-literal">链接特定的 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 或 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 到其他数据类型</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#mapped-column-dataclass"><code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 中的 dataclass 特性</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-metadata">访问表和元数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-table-configuration">声明式表配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="#declarative-table">使用 Declarative Table 的显式模式名称</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-table-column-naming">为映射表列显式命名</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#imperative-table-declarative-declarative">具有 Imperative Table 的 Declarative （俗称混合 Declarative）</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mapper-reflection">基于反射的映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="#automap">使用 Automap 反射</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mapper-automated-reflection-schemes">从反射表中自动化列命名方案</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mapper-primary-key">映射到一组明确设置的主键列</a></span></li>
<li><span class="link-container"><a class="reference external" href="#include-exclude-cols">映射表的一个子集的列</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="declarative_config.html">使用声明式进行Mapper配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="declarative_mixins.html">使用 Mixin 构建映射层次结构</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="dataclasses.html">与dataclasses和attrs集成</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_sql_expr.html">将SQL表达式映射为属性</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapped_attributes.html">更改属性行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="composites.html">复合列类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="inheritance.html">映射类继承层次结构</a></span></li>
<li><span class="link-container"><a class="reference external" href="nonstandard_mappings.html">非传统映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="versioning.html">配置版本计数器</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapping_api.html">类映射API</a></span></li>
<li><span class="link-container"><a class="reference external" href="scalar_mapping.html">映射SQL表达式</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span></li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="declarative_styles.html" title="previous chapter">声明式映射风格</a></li>
                <li><b>Next:</b>
                <a href="declarative_config.html" title="next chapter">使用声明式进行Mapper配置</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="mapper_config.html" title="ORM映射类配置">ORM映射类配置</a></li>
                    <ul><li><a href="declarative_mapping.html" title="通过声明性方式映射类">通过声明性方式映射类</a></li>
                </ul>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#declarativetable">使用Declarative配置Table</a><ul>
<li><a class="reference internal" href="#mapped-column-declarative-table">使用 <code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的Declarative Table</a><ul>
<li><a class="reference internal" href="#declarative-table-mapped-column">在类型注释中使用注释式的Declarative Table (<code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的类型注释形式)</a><ul>
<li><a class="reference internal" href="#mapped-column-mapped"><code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 从 <code class="docutils literal notranslate"><span class="pre">Mapped</span></code> 注释中派生类型和可空性</a></li>
<li><a class="reference internal" href="#orm-declarative-mapped-column-type-map">自定义类型映射</a></li>
<li><a class="reference internal" href="#python">将多个类型配置映射到 Python 类型</a></li>
<li><a class="reference internal" href="#orm-declarative-mapped-column-pep593">将整个列声明映射到Python类型</a><ul>
<li><a class="reference internal" href="#enums">本机 Enums 和命名</a></li>
<li><a class="reference internal" href="#id5">更改默认枚举的配置</a></li>
<li><a class="reference internal" href="#enum-enum-typing-literal">链接特定的 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 或 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 到其他数据类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mapped-column-dataclass"><code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 中的 dataclass 特性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm-declarative-metadata">访问表和元数据</a></li>
<li><a class="reference internal" href="#orm-declarative-table-configuration">声明式表配置</a></li>
<li><a class="reference internal" href="#declarative-table">使用 Declarative Table 的显式模式名称</a></li>
<li><a class="reference internal" href="#orm-declarative-table-column-naming">为映射表列显式命名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#imperative-table-declarative-declarative">具有 Imperative Table 的 Declarative （俗称混合 Declarative）</a></li>
<li><a class="reference internal" href="#mapper-reflection">基于反射的映射</a></li>
<li><a class="reference internal" href="#automap">使用 Automap 反射</a></li>
<li><a class="reference internal" href="#mapper-automated-reflection-schemes">从反射表中自动化列命名方案</a></li>
<li><a class="reference internal" href="#mapper-primary-key">映射到一组明确设置的主键列</a></li>
<li><a class="reference internal" href="#include-exclude-cols">映射表的一个子集的列</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-declarative_tables" >
        
<section id="declarativetable">
<span id="orm-declarative-table-config-toplevel"></span><h1>使用Declarative配置Table<a class="headerlink" href="#declarativetable" title="Permalink to this heading">¶</a></h1>
<p>在   <a class="reference internal" href="mapping_styles.html#orm-declarative-mapping"><span class="std std-ref">声明式映射</span></a>  中介绍了Declarative风格包含生成映射的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象的功能或直接容纳   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  或其他   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a>  对象。</p>
<p>下面的示例假设Declarative基类为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>

<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>所有接下来的示例都展示了从上面继承 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 类。 此外，   <a class="reference internal" href="declarative_styles.html#orm-declarative-decorator"><span class="std std-ref">使用装饰器声明式映射（无声明式基类）</span></a>  中引入的装饰器样式也完全支持所有以下示例，以及通过   <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code>  生成的基类形式的Declarative Base。</p>
<section id="mapped-column-declarative-table">
<span id="orm-declarative-table"></span><h2>使用 <code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的Declarative Table<a class="headerlink" href="#mapped-column-declarative-table" title="Permalink to this heading">¶</a></h2>
<p>使用Declarative时，要映射的类的主体在大多数情况下包括一个名为 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> 的属性，该属性指示应在映射期间生成一个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  的字符串名称。 然后在类主体内使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造，该构造包含ORM特定的其他配置能力，这些能力在普通的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  类中不可用，以指示表中的列。</p>
<p>下面的示例演示了在Declarative映射中使用此构造的最基本的用法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>

<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">nickname</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面，   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造被放置在类定义内的类级别属性中。在声明类的时，Declarative映射过程将针对与Declarative“Base”相关联的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  集合生成一个新的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象；然后将使用每个   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  来在此过程中生成一个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象，该对象将成为该   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象的  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.columns</span></code>  集合的一部分。</p>
<p>在上面的示例中，Declarative将构建一个等价于以下内容的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  构造:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># equivalent Table object produced</span>
<span class="n">user_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;user&quot;</span><span class="p">,</span>
    <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;fullname&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">()),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;nickname&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">)),</span>
<span class="p">)</span></pre></div>
</div>
<p>当上面的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类被映射时，此   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象可以通过 <code class="docutils literal notranslate"><span class="pre">__table__</span></code> 属性直接访问；有关详细信息，请参见   <a class="reference internal" href="#orm-declarative-metadata"><span class="std std-ref">访问表和元数据</span></a> 。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造 <strong>仅在Declarative类映射内有效</strong>。在构建   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象时，无论是使用Core还是使用   <a class="reference internal" href="#orm-imperative-table-configuration"><span class="std std-ref">imperative table</span></a>  配置，都需要   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  构造来指示存在数据库列。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">mapping_columns_toplevel</span>  - 包含有关影响   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  如何解释传入的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象的其他注释。</p>
</div>
<section id="declarative-table-mapped-column">
<span id="orm-declarative-mapped-column"></span><h3>在类型注释中使用注释式的Declarative Table (<code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的类型注释形式)<a class="headerlink" href="#declarative-table-mapped-column" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">mapped_column</span></code>  构造能够从关联到在用于声明Declarative映射类的Python缺省  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapped</span></code>  类型注释中的类型注释  <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  中派生其列配置信息。如果使用，则这些类型注释**必须**存在于名为   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  的特殊的 SQLAlchemy 类型内，该类型是一个通用类型，然后表示其中一个特定的Python类型。</p>
</div></blockquote>
<p>下面演示了从上一节中进行映射，添加了对使用   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  的示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">fullname</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">str</span><span class="p">]]</span>
    <span class="n">nickname</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>上面的示例中，Declarative在每个类属性进行处理时，如果存在，则每个   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  将从相应的左侧   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  类型注释派生出额外的参数。此外，当遇到没有分配任何值的   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  类型注释的情况下，Declarative将在此类形式的情况下隐式生成一个空的   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  指令，进而从   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注释中派生其配置。</p>
<section id="mapped-column-mapped">
<span id="orm-declarative-mapped-column-nullability"></span><h4><code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 从 <code class="docutils literal notranslate"><span class="pre">Mapped</span></code> 注释中派生类型和可空性<a class="headerlink" href="#mapped-column-mapped" title="Permalink to this heading">¶</a></h4>
<p>从   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注释导出的   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  得出的两个特性是：</p>
<ul>
<li><p><strong>datatype</strong> - 给定内部的   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  中的 Python 类型，包含在 <code class="docutils literal notranslate"><span class="pre">typing.Optional</span></code> 中的构造（如果存在）与   <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>  子类相关联，例如  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> ，   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> ，   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>  或   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Uuid" title="sqlalchemy.types.Uuid"><code class="xref py py-class docutils literal notranslate"><span class="pre">Uuid</span></code></a>  等常见类型。</p>
<p>数据类型是根据 Python 类型到 SQLAlchemy 数据类型的字典确定的。此字典是完全可定制的，如下一节   <a class="reference internal" href="#orm-declarative-mapped-column-type-map"><span class="std std-ref">自定义类型映射</span></a>  所述。 默认类型映射实现如下面的代码示例：：</p>
<blockquote>
<div><p>from typing import Any
from typing import Dict
from typing import Type</p>
<p>import datetime
import decimal
import uuid</p>
<p>from sqlalchemy import types</p>
<p># 基于 Mapped[] 注释导出类型的默认映射，此构造方式仅适用于 Declarative 映射
type_map: Dict[Type[Any], TypeEngine[Any]] = {</p>
<blockquote>
<div><p>bool: types.Boolean(),
bytes: types.LargeBinary(),
datetime.date: types.Date(),
datetime.datetime: types.DateTime(),
datetime.time: types.Time(),
datetime.timedelta: types.Interval(),
decimal.Decimal: types.Numeric(),
float: types.Float(),
int: types.Integer(),
str: types.String(),
uuid.UUID: types.Uuid(),</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>如果   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造指示传递给  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.__type</span></code>  参数的显式类型，则忽略给定的 Python 类型。</p>
</li>
<li><p><strong>nullability</strong> - 在   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  中，   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造首先使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.nullable</span></code>  参数来指示其   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code>。此外，如果出现  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.primary_key</span></code>  参数并设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则还将意味着该列应为 <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code>。</p>
<p>如果缺少**这两个**参数，则   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  类型注释中存在 <code class="docutils literal notranslate"><span class="pre">typing.Optional[]</span></code> 的存在将用于确定可空性，其中 <code class="docutils literal notranslate"><span class="pre">typing.Optional[]</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，而不包含 <code class="docutils literal notranslate"><span class="pre">typing.Optional[]</span></code> 则表示 <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code>。如果根本没有出现 <code class="docutils literal notranslate"><span class="pre">Mapped[]</span></code> 注释，并且没有  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.nullable</span></code>  或  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.primary_key</span></code>  参数，则使用 SQLAlchemy 的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  的通常默认 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p>在下面的示例中， <code class="docutils literal notranslate"><span class="pre">id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">data</span></code> 列将为 <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code>，而 <code class="docutils literal notranslate"><span class="pre">additional_info</span></code> 列将是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；</p>
<blockquote>
<div><p>from typing import Optional</p>
<p>from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class SomeClass(Base):</dt><dd><p>__tablename__ = “some_table”</p>
<p># primary_key=True，因此将为 NOT NULL
id: Mapped[int] = mapped_column(primary_key=True)</p>
<p># not Optional[]，因此将为 NOT NULL
data: Mapped[str]</p>
<p># Optional[]，因此将为 NULL
additional_info: Mapped[Optional[str]]</p>
</dd>
</dl>
</div></blockquote>
</li>
</ul>
<p>同时，还可以拥有   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  ，其可空性与注释所表示的可能**不同**。例如，ORM映射属性可以在 Python 代码中标记为允许 <code class="docutils literal notranslate"><span class="pre">None</span></code>，因为它在首次创建和填充对象时使用，但最终该值将写入在模式级别上为 <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code> 的数据库列中。当  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.nullable</span></code>  参数存在时，始终会优先使用：</p>
<blockquote>
<div><dl>
<dt>class SomeClass(Base):</dt><dd><p># …</p>
<p># pep-484类型将为Optional，但是值在数据库中是 NOT NULL
created_at: Mapped[Optional[timestamp]] = mapped_column(nullable=False)</p>
</dd>
</dl>
</div></blockquote>
<p>同样，对于必须为非 None 而写入数据库列的 ORM 映射属性， 则列如果需要为 NULL，即使数据在 Python 中是非 None 的，  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.nullable</span></code>  也必须设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code>：</p>
<blockquote>
<div><dl>
<dt>class SomeClass(Base):</dt><dd><p># …</p>
<p># 将为 NULL 的 String()，但类型检查器将不会在预期此属性为None时给出提示
data: Mapped[str] = mapped_column(nullable=True)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="orm-declarative-mapped-column-type-map">
<span id="id1"></span><h4>自定义类型映射<a class="headerlink" href="#orm-declarative-mapped-column-type-map" title="Permalink to this heading">¶</a></h4>
<p>在以前的章节中描述的 Python 类型与 SQLAlchemy   <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>  类型之间的映射默认为硬编码的字典，在 <code class="docutils literal notranslate"><span class="pre">sqlalchemy.sql.sqltypes</span></code> 模块中提供。但是，Declarative映射过程的协调器   <code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code>  对象将在首次使用时首先查看一个用户定义的本地字典，该字典可能会传递为构建   <code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code>  时的  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>  参数，并且可以与   <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code>  超类相关联。</p>
<p>例如，如果我们希望将 Python <code class="docutils literal notranslate"><span class="pre">int</span></code> 映射到 <code class="docutils literal notranslate"><span class="pre">_sqltypes.BIGINT</span></code> 数据类型，将 Python <code class="docutils literal notranslate"><span class="pre">datetime.datetime</span></code> 映射到带有 <code class="docutils literal notranslate"><span class="pre">timezone=True</span></code> 的 <code class="docutils literal notranslate"><span class="pre">_sqltypes.TIMESTAMP</span></code> 数据类型，并且仅在 Microsoft SQL Server 上使用 <code class="docutils literal notranslate"><span class="pre">_sqltypes.NVARCHAR</span></code> 数据类型时使用 Python <code class="docutils literal notranslate"><span class="pre">str</span></code>，则可对 registry 和 Declarative base 进行配置:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">BIGINT</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">NVARCHAR</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">TIMESTAMP</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span><span class="p">,</span> <span class="n">mapped_column</span><span class="p">,</span> <span class="n">registry</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="n">type_annotation_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">int</span><span class="p">:</span> <span class="n">BIGINT</span><span class="p">,</span>
        <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span> <span class="n">TIMESTAMP</span><span class="p">(</span><span class="n">timezone</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">()</span><span class="o">.</span><span class="n">with_variant</span><span class="p">(</span><span class="n">NVARCHAR</span><span class="p">,</span> <span class="s2">&quot;mssql&quot;</span><span class="p">),</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;some_table&quot;</span>

    <span class="n">short_name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str_30</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">long_name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str_50</span><span class="p">]</span>
    <span class="n">num_value</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">num_12_4</span><span class="p">]</span>
    <span class="n">short_num_value</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">num_6_2</span><span class="p">]</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>在上面的示例中，Python 类型被作为键传递到  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>  字典中， link the base  :class:<a href="#id2"><span class="problematic" id="id3">`</span></a>_types.TypeEngine`来升级数据类型的设置。</p>
<p>&#64;RunWith：_::<cite>大型二进制</cite>，   <code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code>   可配置的参数，其中较少的一部分是在 <code class="docutils literal notranslate"><span class="pre">_sqltypes</span></code> 模块中定义。 因此，使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>  的便捷性在于，您可以根据需要链接类似的类型，例如将 Python <code class="docutils literal notranslate"><span class="pre">int</span></code> 映射到 <code class="docutils literal notranslate"><span class="pre">_sqltypes.BIGINT</span></code> 或 <code class="docutils literal notranslate"><span class="pre">_sqltypes.INTEGER</span></code> 或其他兼容的 SQL 数据类型:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">BIGINT</span><span class="p">,</span> <span class="n">INTEGER</span>

<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="n">type_annotation_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">int</span><span class="p">:</span> <span class="n">BIGINT</span><span class="p">,</span>
        <span class="n">int</span><span class="p">:</span> <span class="n">INTEGER</span><span class="p">,</span>
    <span class="p">}</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>如果上面的示例未满足您的要求，您也可以像下面的示例那样声明自己的类型映射字典，以连接适合您应用以及要使用的数据库的类型:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="kn">import</span> <span class="n">TypeEngine</span><span class="p">,</span> <span class="n">TypeDecorator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Type</span>

<span class="n">type_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">TypeEngine</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">CustomDataType</span><span class="p">:</span> <span class="n">TypeDecorator</span><span class="p">(</span><span class="n">custom_type_str</span><span class="p">),</span>
    <span class="n">int</span><span class="p">:</span> <span class="n">INTEGER</span><span class="p">,</span>
    <span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
    <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">:</span> <span class="n">Numeric</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span> <span class="n">TIMESTAMP</span><span class="p">(),</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">CustomClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">custom_registry</span> <span class="o">=</span> <span class="n">registry</span><span class="p">(</span><span class="n">type_annotation_map</span><span class="o">=</span><span class="n">type_map</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>在本示例中，我们连接了四个不同的数据类型（其中一个是自定义类型）以及一个自定义数据类型到我们想要使用的SQLAlchemy数据类型的映射。</p>
</section>
<section id="python">
<span id="orm-declarative-mapped-column-type-map-pep593"></span><h4>将多个类型配置映射到 Python 类型<a class="headerlink" href="#python" title="Permalink to this heading">¶</a></h4>
<p>由于类型注释可与任何使用 Python 内置 <code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code> 的用户定义 Python 类型作为键相关联，因此也可以使用 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 类型字面值作为键。</p>
<p>下面是一个示例，用于到 <code class="docutils literal notranslate"><span class="pre">Literal</span></code> 类型作为键，通过数据类型控制字符串的输入内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">Status</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pending&quot;</span><span class="p">,</span> <span class="s2">&quot;received&quot;</span><span class="p">,</span> <span class="s2">&quot;completed&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;some_table&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Status</span><span class="p">]</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>在上面的示例中，“SomeClass.status” 映射属性将与数据类型为 <code class="docutils literal notranslate"><span class="pre">Enum(Status)</span></code> 的列连接。 我们可以在使用 PostgreSQL 数据库时看到这一点，如下所示：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TYPE</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">ENUM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;PENDING&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RECEIVED&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;COMPLETED&#39;</span><span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">SERIAL</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>同样地，也可以使用  <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a>  的 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 构造函数及 Python 的 <code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code> 类型定义来添加元数据到类型中，实现对 ORM 映射的自定义控制。以下示例使用自定义枚举类型 <code class="docutils literal notranslate"><span class="pre">Status</span></code> 作为映射类型：：</p>
<blockquote>
<div><p>import enum</p>
<p>from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Status(enum.Enum):</dt><dd><p>PENDING = “pending”
RECEIVED = “received”
COMPLETED = “completed”</p>
</dd>
<dt>class SomeClass(Base):</dt><dd><p>__tablename__ = “some_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
status: Mapped[Status]</p>
</dd>
</dl>
</div></blockquote>
<p>在上面的示例中，映射属性 <code class="docutils literal notranslate"><span class="pre">SomeClass.status</span></code> 将链接到具有 <code class="docutils literal notranslate"><span class="pre">Enum(Status)</span></code> 数据类型的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 。我们可以看到下面的 PostgreSQL 数据库中，<code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> 输出：：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TYPE</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">ENUM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;PENDING&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;RECEIVED&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;COMPLETED&#39;</span><span class="p">)</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">SERIAL</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0.1,: </span>支持 <code class="docutils literal notranslate"><span class="pre">Literal</span></code> 类型字面值协议，可以使用 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 定义类参数的值。</p>
</div>
</section>
<section id="orm-declarative-mapped-column-pep593">
<span id="id4"></span><h4>将整个列声明映射到Python类型<a class="headerlink" href="#orm-declarative-mapped-column-pep593" title="Permalink to this heading">¶</a></h4>
<p>前面的部分演示了如何将   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  连接到定义在 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 中的特定列和函数中。使用此形式，我们可以定义不仅适用于Python类型的相似SQL数据类型拼接，还可以设置许多其他参数，例如时间戳、默认值和约束等，其中许多设置是预先定义的在声明中的列所具有的。我们可以将这些配置组成可重用的   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造函数，然后直接从 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 实例中提取它们，在您的类定义中可以多次使用。</p>
<p>ORM模型通常具有所有映射类都通用的主键样式。此外，可能存在相似的列配置，例如具有默认值的时间戳和其他预先设置的大小和配置的字段。我们可以将这些配置组合成   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  实例，然后将实例直接打包到 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 实例中，以便在任意数量的类声明中重复使用此配置。当以此方式提供 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 对象时，Declarative 会解压缩 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 对象，跳过不适用于 SQLAlchemy 的任何其他指令，并仅搜索 SQLAlchemy ORM 构造。</p>
<p>下面的示例演示了用于此类用途的各种预配置的字段类型，其中我们定义了 <code class="docutils literal notranslate"><span class="pre">intpk</span></code> 以代表一个整数类型的主键列， <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> 代表一个   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>  类型，将使用 <code class="docutils literal notranslate"><span class="pre">CURRENT_TIMESTAMP</span></code> 作为 DDL 级别的列默认值，以及 <code class="docutils literal notranslate"><span class="pre">required_name</span></code> ，它是一个长度为 30 的   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>  且为 <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code> 的字段:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Annotated</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>


<span class="n">intpk</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">int</span><span class="p">,</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
<span class="n">timestamp</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
    <span class="n">mapped_column</span><span class="p">(</span><span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">server_default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">CURRENT_TIMESTAMP</span><span class="p">()),</span>
<span class="p">]</span>
<span class="n">required_name</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span></pre></div>
</div>
<p>在上面的示例中， <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 对象可以直接在   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  中使用，其中预配置的   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  构造将从 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 对象中提取并复制到将针对每个属性特定的新实例中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;some_table&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">intpk</span><span class="p">]</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">required_name</span><span class="p">]</span>
    <span class="n">created_at</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">timestamp</span><span class="p">]</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>下面是用于以上映射创建的 <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> 语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sqlalchemy</span><span class="p">.</span><span class="k">schema</span><span class="w"> </span><span class="n">import</span><span class="w"> </span><span class="n">CreateTable</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">CreateTable</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">.</span><span class="n">__table__</span><span class="p">))</span>
<span class="err">{</span><span class="n">printsql</span><span class="err">}</span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">created_at</span><span class="w"> </span><span class="n">DATETIME</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>在 Declarative 中解析逻辑能够解析 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 子类型以及 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 的实例，来匹配  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>  字典中的 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 或 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 条目。   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  SQL 类型然后知道如何生成一个配置的版本，包括默认字符串长度。如果传递了一个不仅包含字符串值的 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code>，则会引发具有说明性的错误信息。</p>
<section id="enums">
<h5>本机 Enums 和命名<a class="headerlink" href="#enums" title="Permalink to this heading">¶</a></h5>
<blockquote>
<div><p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.native_enum</span></code></a>   参数指的是是否应该创建所谓的 “本机” 枚举。在 MySQL/MariaDB 中是 <code class="docutils literal notranslate"><span class="pre">ENUM</span></code> 数据类型，在 PostgreSQL 中是由 <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TYPE</span></code> 创建的新的 <code class="docutils literal notranslate"><span class="pre">TYPE</span></code> 对象，或者是 “非本机” 枚举，这意味着将使用 <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> 创建数据类型。对于除 MySQL/MariaDB 或 PostgreSQL 之外的后端，将在所有情况下使用 <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> (第三方方言可能具有其自己的行为）。</p>
</div></blockquote>
<p>由于 PostgreSQL 的 <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TYPE</span></code> 要求为要创建的类型指定显式名称，因此当使用隐式生成的   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  且未在映射中指定显式的   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  数据类型时，存在特殊的回滚逻辑：</p>
<ol class="arabic simple">
<li><p>如果   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  与 <code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code> 对象相关联，则  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.native_enum</span></code></a>  参数默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，并且枚举的名称将来自 <code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code> 数据类型的名称。PostgreSQL 后端将默认假定 <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TYPE</span></code> 以此名称。</p></li>
<li><p>如果   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  链接到 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 对象，则  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.native_enum</span></code></a>  参数默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，不生成名称，且假定使用 <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>。</p></li>
</ol>
<p>要将 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 与 PostgreSQL <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TYPE</span></code> 类型一起使用，必须使用显式   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.sql.sqltypes.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> ，无论是在类型映射中：</p>
<blockquote>
<div><p>import enum
import typing</p>
<p>import sqlalchemy
from sqlalchemy.orm import DeclarativeBase</p>
<p>Status = Literal[“pending”, “received”, “completed”]</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><dl class="simple">
<dt>type_annotation_map = {</dt><dd><p>Status: sqlalchemy.Enum(“pending”, “received”, “completed”, name=”status_enum”),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>或者是在   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  中：</p>
<blockquote>
<div><p>import enum
import typing</p>
<p>import sqlalchemy
from sqlalchemy.orm import DeclarativeBase</p>
<p>Status = Literal[“pending”, “received”, “completed”]</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class SomeClass(Base):</dt><dd><p>__tablename__ = “some_table”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
status: Mapped[Status] = mapped_column(</p>
<blockquote>
<div><p>sqlalchemy.Enum(“pending”, “received”, “completed”, name=”status_enum”)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id5">
<h5>更改默认枚举的配置<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h5>
<p>为了修改隐式生成的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code>  数据类型的固定配置，请在  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>  中指定额外的条目，以指示其他参数。例如，要无条件地使用 “非本机枚举”，可以将  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum" title="sqlalchemy.types.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.native_enum</span></code></a>  参数设置为 <code class="docutils literal notranslate"><span class="pre">False</span></code>：</p>
<blockquote>
<div><p>import enum
import typing
import sqlalchemy
from sqlalchemy.orm import DeclarativeBase</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><dl class="simple">
<dt>type_annotation_map = {</dt><dd><p>enum.Enum: sqlalchemy.Enum(enum.Enum, native_enum=False),
typing.Literal: sqlalchemy.Enum(enum.Enum, native_enum=False),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0.1: </span>实现了支持在建立  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>  时重写  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum" title="sqlalchemy.types.Enum"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Enum.native_enum</span></code></a>  等参数的功能。先前，这个功能无法使用。</p>
</div>
<p>要为特定的 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 子类型使用特定配置，例如在使用上面的 <code class="docutils literal notranslate"><span class="pre">Status</span></code> 数据类型时将字符串长度设置为 50：</p>
<blockquote>
<div><p>import enum
import sqlalchemy
from sqlalchemy.orm import DeclarativeBase</p>
<dl>
<dt>class Status(enum.Enum):</dt><dd><p>PENDING = “pending”
RECEIVED = “received”
COMPLETED = “completed”</p>
</dd>
<dt>class Base(DeclarativeBase):</dt><dd><dl class="simple">
<dt>type_annotation_map = {</dt><dd><p>Status: sqlalchemy.Enum(Status, length=50, native_enum=False)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="enum-enum-typing-literal">
<h5>链接特定的 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 或 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 到其他数据类型<a class="headerlink" href="#enum-enum-typing-literal" title="Permalink to this heading">¶</a></h5>
<p>上面的示例演示了   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  如何自动配置适用于 <code class="docutils literal notranslate"><span class="pre">Enum.Enum</span></code> 或 <code class="docutils literal notranslate"><span class="pre">typing.Literal</span></code> 类型对象的参数/属性。对于特定类型应链接到其他类型的用例中，这些特定类型也可以放置在类型映射中。在下面的示例中，包含非字符串类型的 <code class="docutils literal notranslate"><span class="pre">Literal[]</span></code> 条目将链接到   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>  数据类型：</p>
<blockquote>
<div><p>from typing import Literal</p>
<p>from sqlalchemy import JSON
from sqlalchemy.orm import DeclarativeBase</p>
<p>my_literal = Literal[0, 1, True, False, “true”, “false”]</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>type_annotation_map = {my_literal: JSON}</p>
</dd>
</dl>
</div></blockquote>
<p>在以上配置中， <code class="docutils literal notranslate"><span class="pre">my_literal</span></code> 数据类型将解析为一个   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>  实例。其他 <code class="docutils literal notranslate"><span class="pre">Literal</span></code> 变体将继续解析为   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>  数据类型。</p>
</section>
</section>
<section id="mapped-column-dataclass">
<h4><code class="docutils literal notranslate"><span class="pre">mapped_column()</span></code> 中的 dataclass 特性<a class="headerlink" href="#mapped-column-dataclass" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  结构集成了 SQLAlchemy 的 “原生数据类” 特性，如在
<a class="reference internal" href="dataclasses.html#orm-declarative-native-dataclasses"><span class="std std-ref">声明数据类映射</span></a>  中所述。请参阅该部分，了解   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  支持的其他指令。</p>
</div></blockquote>
</section>
</section>
<section id="orm-declarative-metadata">
<span id="id6"></span><h3>访问表和元数据<a class="headerlink" href="#orm-declarative-metadata" title="Permalink to this heading">¶</a></h3>
<p>装饰器声明的类将始终包括一个名为 <code class="docutils literal notranslate"><span class="pre">__table__</span></code> 的属性；使用上述使用 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> 的配置后，声明过程将通过 <code class="docutils literal notranslate"><span class="pre">__table__</span></code> 属性使   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  可用：</p>
<blockquote>
<div><p># 访问 Table
user_table = User.__table__</p>
</div></blockquote>
<p>上述表最终与  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.local_table</span></code>  属性对应，我们可以通过   <span class="xref std std-ref">运行时检测系统</span>  来查看：</p>
<blockquote>
<div><p>from sqlalchemy import inspect</p>
<p>user_table = inspect(User).local_table</p>
</div></blockquote>
<p>在 ddl 操作(例如 CREATE) 以及与迁移工具（例如 Alembic）一起使用时，与 Declarative 注册基类相关联的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  集合通常是必需的。该对象可以通过   <code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code>  的 <code class="docutils literal notranslate"><span class="pre">.metadata</span></code> 属性以及 Declarative 基类进行访问。以下是一个小脚本，我们可能希望使用它来针对 SQLite 数据库发出 CREATE 所有表的命令：</p>
<blockquote>
<div><p>engine = create_engine(“sqlite://”)</p>
<p>Base.metadata.create_all(engine)</p>
</div></blockquote>
</section>
<section id="orm-declarative-table-configuration">
<span id="id7"></span><h3>声明式表配置<a class="headerlink" href="#orm-declarative-table-configuration" title="Permalink to this heading">¶</a></h3>
<p>使用 Declarative 表配置时，提供应提供给   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  构造函数的附加参数应在 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 声明类属性中指定。</p>
<p>该属性接受按位置排列的参数和关键字参数，这些通常发送到   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  构造函数。
可以使用字典指定属性：</p>
<blockquote>
<div><dl class="simple">
<dt>class MyClass(Base):</dt><dd><p>__tablename__ = “sometable”
__table_args__ = {“mysql_engine”: “InnoDB”}</p>
</dd>
</dl>
</div></blockquote>
<p>或者，使用每个参数作为位置参数（通常是约束条件）的元组：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p>__tablename__ = “sometable”
__table_args__ = (</p>
<blockquote>
<div><p>ForeignKeyConstraint([“id”], [“remote_table.id”]),
UniqueConstraint(“foo”),</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>通过将字典指定为最后一个参数，可以使用关键字参数：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p>__tablename__ = “sometable”
__table_args__ = (</p>
<blockquote>
<div><p>ForeignKeyConstraint([“id”], [“remote_table.id”]),
UniqueConstraint(“foo”),
{“autoload”: True},</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>一个类还可以使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">declared_attr()</span></code>  方法装饰器以动态样式指定 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 声明属性，以及 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> 属性。请参阅   <span class="xref std std-ref">orm_mixins_toplevel</span>  了解详情。</p>
</section>
<section id="declarative-table">
<span id="orm-declarative-table-schema-name"></span><h3>使用 Declarative Table 的显式模式名称<a class="headerlink" href="#declarative-table" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  中描述的模式名称   <a class="reference internal" href="../core/metadata.html#schema-table-schema-name"><span class="std std-ref">指定模式名称</span></a>  被应用于一个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> ，使用  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.schema" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.schema</span></code></a>  参数。当使用 Declarative 时，此选项应像任何其他选项一样在 <code class="docutils literal notranslate"><span class="pre">__table_args__</span></code> 字典中传递：</p>
<blockquote>
<div><p>from sqlalchemy.orm import DeclarativeBase</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class MyClass(Base):</dt><dd><p>__tablename__ = “sometable”
__table_args__ = {“schema”: “some_schema”}</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/metadata.html#schema-table-schema-name"><span class="std std-ref">指定模式名称</span></a>  - 在   <span class="xref std std-ref">metadata_toplevel</span>  文档中。</p>
</div>
</section>
<section id="orm-declarative-table-column-naming">
<span id="id8"></span><h3>为映射表列显式命名<a class="headerlink" href="#orm-declarative-table-column-naming" title="Permalink to this heading">¶</a></h3>
<p>上述示例演示了如何使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>  为生成的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象提供与它们映射的属性名称不同的在 SQL 中表达的名称。</p>
<p>在使用 Imperative Table 配置时，我们已经有了现有的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象。为了将这些   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象从与它们绑定的属性名称映射到备用名称，我们可以直接将   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  赋值给所需的属性：</p>
<blockquote>
<div><dl class="simple">
<dt>user_table = Table(</dt><dd><p>“user”,
Base.metadata,
Column(“user_id”, Integer, primary_key=True),
Column(“user_name”, String),</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>class User(Base):</dt><dd><p>__table__ = user_table</p>
<p>id = user_table.c.user_id
name = user_table.c.user_name</p>
</dd>
</dl>
</div></blockquote>
<p>上述 <code class="docutils literal notranslate"><span class="pre">User</span></code> 映射将通过 <code class="docutils literal notranslate"><span class="pre">User.id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">User.name</span></code> 属性引用 <code class="docutils literal notranslate"><span class="pre">&quot;user_id&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&quot;user_name&quot;</span></code> 列，在和在   <a class="reference internal" href="#orm-declarative-table-column-naming"><span class="std std-ref">为映射表列显式命名</span></a>  中演示的方式相同。</p>
<p>上述映射的一个注意事项是，在使用  <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>  类型提示工具时，将无法正确地对直接的行链接到   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 。解决此问题的策略是在   <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code>  中应用   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象；虽然   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  已经自动为其内部使用生成了此属性对象，但是通过在类声明中命名它，类型提示工具将能够将属性与   <a class="reference internal" href="internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>  注释相匹配：</p>
<blockquote>
<div><p>from sqlalchemy.orm import column_property
from sqlalchemy.orm import Mapped</p>
<dl>
<dt>class User(Base):</dt><dd><p>__table__ = user_table</p>
<p>id: Mapped[int] = column_property(user_table.c.user_id)
name: Mapped[str] = column_property(user_table.c.user_name)</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#orm-declarative-table-column-naming"><span class="std std-ref">为映射表列显式命名</span></a>  - 适用于 Declarative Table</p>
</div>
</section>
</section>
<section id="imperative-table-declarative-declarative">
<span id="orm-imperative-table-configuration"></span><h2>具有 Imperative Table 的 Declarative （俗称混合 Declarative）<a class="headerlink" href="#imperative-table-declarative-declarative" title="Permalink to this heading">¶</a></h2>
<p>声明式映射可以映射到一个通过反射进入的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象系列，这些对象使用在   <span class="xref std std-ref">metadata_reflection</span>  中描述的反射过程进行了内省。</p>
<p>将一个类映射到从数据库反射出来的表，简单的示例如下所示，使用混合声明式映射：</p>
<blockquote>
<div><p>from sqlalchemy import create_engine
from sqlalchemy import Table
from sqlalchemy.orm import DeclarativeBase</p>
<p>engine = create_engine(“postgresql+psycopg2://user:pass&#64;hostname/my_existing_database”)</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class MyClass(Base):</dt><dd><dl class="simple">
<dt>__table__ = Table(</dt><dd><p>“mytable”,
Base.metadata,
autoload_with=engine,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>为了将多个表映射到一个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> ，可以使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code>  方法一次反射完整的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象集，然后从   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  引用它们：</p>
<blockquote>
<div><p>from sqlalchemy import create_engine
from sqlalchemy import Table
from sqlalchemy.orm import DeclarativeBase</p>
<p>engine = create_engine(“postgresql+psycopg2://user:pass&#64;hostname/my_existing_database”)</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
</dl>
<p>Base.metadata.reflect(engine)</p>
<dl class="simple">
<dt>class MyClass(Base):</dt><dd><p>__table__ = Base.metadata.tables[“mytable”]</p>
</dd>
</dl>
</div></blockquote>
<p>上述方法中的一个提示是，除非表的元数据真正地被反射出来，否则无法声明映射类。这要求在声明应用程序类时存在数据库连接源；通常的情况是，当应用程序的模块被导入时，类被声明，但数据库连接需要应用程序开始运行代码才会可用，以便使用配置信息并创建引擎。目前有两种方法可以解决这个问题，在下面的两个部分中描述。</p>
<p id="orm-declarative-reflected-deferred-reflection">为了适应反映表元数据后才能声明映射类的用例，提供了一个名为   <a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection" title="sqlalchemy.ext.declarative.DeferredReflection"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeferredReflection</span></code></a>  混合的简单扩展，它改变了声明式映射过程，以便在特殊的类级别  <a class="reference internal" href="extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare" title="sqlalchemy.ext.declarative.DeferredReflection.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DeferredReflection.prepare()</span></code></a>  方法被调用后延迟映射过程，这将从目标数据库针对一个目标表执行反射过程，并将结果集成到声明式表映射过程中，也就是使用 <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> 属性的类：</p>
<blockquote>
<div><p>from sqlalchemy.ext.declarative import DeferredReflection
from sqlalchemy.orm import DeclarativeBase</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Reflected(DeferredReflection):</dt><dd><p>__abstract__ = True</p>
</dd>
<dt>class Foo(Reflected, Base):</dt><dd><p>__tablename__ = “foo”
bars = relationship(“Bar”)</p>
</dd>
<dt>class Bar(Reflected, Base):</dt><dd><p>__tablename__ = “bar”</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="mapper-reflection">
<span id="id9"></span><h2>基于反射的映射<a class="headerlink" href="#mapper-reflection" title="Permalink to this heading">¶</a></h2>
<p>有时，我们需要将已存在的表或者数据库映射到 SQLAlchemy 的 ORM 中。这种情况下，你可以使用 SQLAlchemy ORM 的反射机制，该机制允许自动检测表或整个数据库。对于基于反射的表映射，必须通过某种方式将列和整个表映射到 Python 类上。
两种主要实现表级的反射已经在 SQLAlchemy ORM 中得到支持—通过显式预定义类声明和推迟映射，以及零配置的基于自动映射的实现。</p>
<p>以 Foo 类为例，举例说明基于类声明的表反射如何工作:</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bar_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;bar.id&#39;</span><span class="p">))</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Text</span><span class="p">)</span>

    <span class="n">bars</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s1">&#39;foos&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Text</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>execute()　方法只是执行了 SQL 语句 ‘CREATE TABLE foo’ 。没有生成描述 foo 表列的 Python 对应类。通过创建一个混合类，你可以创建一个与自己的定义组合的类，并直接映射列定义到你自己的类定义中：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reflected</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;当调用 Reflected.prepare() 方法时，它就会将基类反射成关联的表并且建立映射&quot;&quot;&quot;</span>

    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;autoload&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">engine</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;将类上的映射关系关联到表以进行映射&quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">engine</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Reflected</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>

    <span class="n">bars</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s1">&#39;foos&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Reflected</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>Reflected 类只是一个包含几个在它派生类中自动执行反射的 SQLALchemy 基类。最重要的是 __table_args__ = {‘autoload’: True} 选项，当该选项设置为 True 时，SQLAlchemy 就会自动反射表并将表的列映射到 Python 中的列属性中。
在 Foo 和 Bar 类中，我们不需要在映射关系中指定实际的列属性，因为 Reflected 类在 prepare() 方法中将表关联到该类，并自动将列属性映射到基类中：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql+psycopg2://user:pass@hostname/my_existing_database&#39;</span><span class="p">)</span>
<span class="n">Reflected</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span></pre></div>
</div>
<p>上面，我们创建了一个混合类 Reflected，它将用作我们的声明式层次结构中映射的基础。该映射不完整，直到我们这样做，即给出一个   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> ：</p>
<p>Reflected 类的目的在于定义应反映哪些类的范围。插件将搜索目标子类树以反射声明的类命名的所有表。</p>
<p>反射表中与映射无关并且与目标表没有任何关系的表将不会反射。</p>
</section>
<section id="automap">
<h2>使用 Automap 反射<a class="headerlink" href="#automap" title="Permalink to this heading">¶</a></h2>
<p>自动建立与现有的数据库表的映射，除了手工映射的方法外，还可以使用   :ref:<a href="#id10"><span class="problematic" id="id11">`</span></a>automap_toplevel `  扩展。这个扩展将从数据库模式中生成完整的映射类，包括基于观察到的外键约束之间的类之间的关系。虽然它包括自定义类命名和关系命名方案的钩子，但 automap 取向于零配置的方便使用。如果一个应用希望拥有一个明确的模型并使用表反射，那么 DeferredReflection 类可能更适合，因为其 less automated 的方法。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">automap_toplevel</span></p>
</div>
</section>
<section id="mapper-automated-reflection-schemes">
<span id="id12"></span><h2>从反射表中自动化列命名方案<a class="headerlink" href="#mapper-automated-reflection-schemes" title="Permalink to this heading">¶</a></h2>
<p>当使用任何前面描述的反射技术时，我们可以改变映射过程中的列映射命名的方式。 默认情况下，采用的是与数据库表中列的物理结构一致的使命名方式。对于不符合你的指定的规则的结果，需要自定义名字策略，例如使用下划线或小写字母。在我们使用表反射时，可以使用元编程技术，以便在收到的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  参数中拦截名称，包括 <code class="docutils literal notranslate"><span class="pre">.key</span></code> 属性，但也包括数据类型，如下所示：</p>
<p>通过使用  <a class="reference internal" href="../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a>  事件来将类中接收的参数与 column_info 变量关联起来，可以定义   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 。这个事件是最容易与正在使用的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象相关联的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="s2">&quot;column_reflect&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">column_reflect</span><span class="p">(</span><span class="n">inspector</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">column_info</span><span class="p">):</span>
    <span class="c1"># set column.key = &quot;attr_&lt;lower_case_name&gt;&quot;</span>
    <span class="n">column_info</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;attr_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">column_info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>如上所述，   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象的反射将被被拦截，添加新的 “.key” 元素，比如下面的映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">autoload_with</span><span class="o">=</span><span class="n">some_engine</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>这个方法同时适用于 DeferredReflection 基类以及 automap_toplevel 扩展。特别是，参见   <a class="reference internal" href="extensions/automap.html#automap-intercepting-columns"><span class="std std-ref">Intercepting Column Definitions</span></a>  部分了解更多背景信息。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><span class="xref std std-ref">orm_declarative_reflected</span></p>
</div></blockquote>
<p><a class="reference internal" href="../core/events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a></p>
<blockquote>
<div><p><a class="reference internal" href="extensions/automap.html#automap-intercepting-columns"><span class="std std-ref">Intercepting Column Definitions</span></a>  - 在   <span class="xref std std-ref">automap_toplevel</span>  文档中</p>
</div></blockquote>
</div>
</section>
<section id="mapper-primary-key">
<span id="id13"></span><h2>映射到一组明确设置的主键列<a class="headerlink" href="#mapper-primary-key" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  构造用于成功将表映射必须始终标识至少一个列作为该可选择性的“主键”。这样，在加载或持久化 ORM 对象时，它才能以适当的 ID 键放置在  <span class="xref std std-term">identity map</span>  中。</p>
</div></blockquote>
<p>在需要映射的反射表不包含主键约束的情况下（这种情况可能在反射场景中发生），以及一般情况下可能不存在主键列的   <a class="reference internal" href="nonstandard_mappings.html#orm-mapping-arbitrary-subqueries"><span class="std std-ref">针对任意可选择性的映射</span></a> ，提供了  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.primary_key</span></code>  参数，以便任何一组列都可以配置为该表的“主键”，就 ORM 映射而言。</p>
<p>以没有明确主键约束的反射表用作插图，可以通过下面的方式进行映射：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">MetaData</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">UniqueConstraint</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>


<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">group_users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;group_users&quot;</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;group_id&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">UniqueConstraint</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="s2">&quot;group_id&quot;</span><span class="p">),</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">GroupUsers</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">group_users</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;primary_key&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">group_users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">group_users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">group_id</span><span class="p">]}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面代码的 group_users 表是某种类型的关联表，具有字符串列 user_id 和 group_id，但没有设置主键；相反，只有一个   <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.UniqueConstraint" title="sqlalchemy.schema.UniqueConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueConstraint</span></code></a>  约束，确定这两个列表示一个唯一的键。类似地, 我们不必在映射关系中指定实际的主键。</p>
</section>
<section id="include-exclude-cols">
<span id="id14"></span><h2>映射表的一个子集的列<a class="headerlink" href="#include-exclude-cols" title="Permalink to this heading">¶</a></h2>
<p>有时反射表可能包含不会在需要的领域上使用的列，可安全忽略。对于这样的表，其具体列不会被 ORM 引用。功能  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.include_properties</span></code>  或  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Mapper.exclude_properties</span></code>  参数可指示只在映射期间包括每个列的子集，其中来自目标   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  的其他列将不被 ORM 以任何方式考虑。示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">user_table</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;include_properties&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="s2">&quot;user_name&quot;</span><span class="p">]}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在上面的示例中，该 User 类将映射到 user_table 表，并只包括 user_id 和 user_name 两列 - 其他列不会被引用。</p>
<p>同样的方式：</p>
<blockquote>
<div><dl class="simple">
<dt>class Address(Base):</dt><dd><p>__table__ = address_table
__mapper_args__ = {“exclude_properties”: [“street”, “city”, “state”, “zip”]}</p>
</dd>
</dl>
</div></blockquote>
<p>将把 Address 类映射到 address_table 表，并包括除 street、city、state 和 zip 以外的所有列。</p>
<p>如示例中所示，列的引用方式可以是字符串名称或直接引用   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象。直接引用可能对于明确性或解析映射到可能具有重复名称的多表结构时有用。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">user_table</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;include_properties&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_name</span><span class="p">]</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>当列未包含在映射中时，这些列将不会在任何 SELECT 语句中引用，即使你执行   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  或旧的   <a class="reference internal" href="queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  对象，也不会有映射属性在映射的类中来表示该列。为该名称分配属性将没有影响，仅有记忆作用。</p>
<p>但是，重要的事情要注意：<strong>schema level column defaults 仍然适用于这些包括它们的   :class:`_schema.Column`  对象，即使他们被从 ORM 映射中排除</strong>。</p>
<p>“schema level column defaults” 指的是在   <a class="reference internal" href="../core/defaults.html#metadata-defaults"><span class="std std-ref">列INSERT/UPDATE默认值</span></a>  中描述的默认值，包括  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.default</span></code></a> 、  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.onupdate" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.onupdate</span></code></a>  、  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.server_default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_default</span></code></a>   和  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_onupdate</span></code></a>  参数。这样构造物继续正常工作，因为在  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.default</span></code></a>  和  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.onupdate" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.onupdate</span></code></a>  的情况下，  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象仍然存在于底层的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  上，因此允许在 ORM 发出 INSERT 或 UPDATE 时使用默认函数，在  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.server_default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_default</span></code></a>  和  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_onupdate</span></code></a>  的情况下，关系数据库本身会发出这些默认值，作为服务器端行为。</p>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="declarative_styles.html" title="previous chapter">声明式映射风格</a>
        Next:
        <a href="declarative_config.html" title="next chapter">使用声明式进行Mapper配置</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:43:56

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


