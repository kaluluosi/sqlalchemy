<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    会话基础知识
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="用 Session" href="session.html" />
        <link rel="next" title="状态管理" href="session_state_management.html" />
        <link rel="prev" title="用 Session" href="session.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="quickstart.html">ORM快速入门</a></span></li>
<li><span class="link-container"><a class="reference external" href="mapper_config.html">ORM映射类配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="relationships.html">关系配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="queryguide/index.html">ORM 查询指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="session.html">用 Session</a></span><ul>
<li class="selected"><span class="link-container"><strong>会话基础知识</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id2">会话的作用是什么？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-basics">使用会话的基础</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#session-getting">开启和关闭会话</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-begin-commit-rollback-block">构建/提交/回滚块</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sessionmaker">使用 sessionmaker</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-querying-20">查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-adding">添加新项或现有项</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-deleting">删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-flushing">刷新</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-get">按主键获取</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-expiring">过期/刷新</a></span></li>
<li><span class="link-container"><a class="reference external" href="#where-update-delete">使用任意 WHERE 子句进行 UPDATE 和 DELETE</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-autobegin">自动启动</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#autobegin">禁用 Autobegin 以防止隐式事务</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#session-committing">提交</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-close">关闭</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-rollback">回滚</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-closing">关闭</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#session-faq">会话常见问答</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id18">何时创建   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code> ？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session">何时构建   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，何时提交，何时关闭？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id19">Session 是缓存吗？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id22">如何获取某个对象的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-asyncsession">Session 是线程安全的吗？在并发任务中共享 AsyncSession 是安全的吗？</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="session_state_management.html">状态管理</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_transaction.html">事务和连接管理</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html">附加的持久化技术</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#sql-flush">将SQL插入/更新表达式嵌入到Flush中</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#sessionssql">在Sessions中使用SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#null">在具有默认值的列上强制执行NULL</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#orm-server-defaults">提取服务器生成的默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#insertupdateon-conflict-upsert-orm">使用INSERT、UPDATE和ON CONFLICT（即upsert）返回ORM对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#session">分区策略（例如 Session 上的多个数据库后端）</a></span></li>
<li><span class="link-container"><a class="reference external" href="persistence_techniques.html#bulk-operations">批量操作</a></span></li>
<li><span class="link-container"><a class="reference external" href="contextual.html">上下文/线程本地会话</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_events.html">使用事件追踪查询、对象和会话更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="session_api.html">会话API</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="extending.html">事件和内部机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="extensions/index.html">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="examples.html">ORM 示例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="session.html" title="previous chapter">用 Session</a></li>
                <li><b>Next:</b>
                <a href="session_state_management.html" title="next chapter">状态管理</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a></li>
                    <ul><li><a href="session.html" title="用 Session">用 Session</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">会话基础知识</a><ul>
<li><a class="reference internal" href="#id2">会话的作用是什么？</a></li>
<li><a class="reference internal" href="#session-basics">使用会话的基础</a><ul>
<li><a class="reference internal" href="#session-getting">开启和关闭会话</a></li>
<li><a class="reference internal" href="#session-begin-commit-rollback-block">构建/提交/回滚块</a></li>
<li><a class="reference internal" href="#sessionmaker">使用 sessionmaker</a></li>
<li><a class="reference internal" href="#session-querying-20">查询</a></li>
<li><a class="reference internal" href="#session-adding">添加新项或现有项</a></li>
<li><a class="reference internal" href="#session-deleting">删除</a></li>
<li><a class="reference internal" href="#session-flushing">刷新</a></li>
<li><a class="reference internal" href="#session-get">按主键获取</a></li>
<li><a class="reference internal" href="#session-expiring">过期/刷新</a></li>
<li><a class="reference internal" href="#where-update-delete">使用任意 WHERE 子句进行 UPDATE 和 DELETE</a></li>
<li><a class="reference internal" href="#session-autobegin">自动启动</a><ul>
<li><a class="reference internal" href="#autobegin">禁用 Autobegin 以防止隐式事务</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-committing">提交</a></li>
<li><a class="reference internal" href="#session-close">关闭</a></li>
<li><a class="reference internal" href="#session-rollback">回滚</a></li>
<li><a class="reference internal" href="#session-closing">关闭</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-faq">会话常见问答</a><ul>
<li><a class="reference internal" href="#id18">何时创建   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code> ？</a></li>
<li><a class="reference internal" href="#session">何时构建   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，何时提交，何时关闭？</a></li>
<li><a class="reference internal" href="#id19">Session 是缓存吗？</a></li>
<li><a class="reference internal" href="#id22">如何获取某个对象的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ？</a></li>
<li><a class="reference internal" href="#session-asyncsession">Session 是线程安全的吗？在并发任务中共享 AsyncSession 是安全的吗？</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar orm-session_basics" >
        
<section id="id1">
<h1>会话基础知识<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<section id="id2">
<h2>会话的作用是什么？<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>从最一般的角度来看，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  建立所有与数据库的对话，并代表“持有区”包含您在它的寿命期内加载或关联的所有对象。它是 SELECT 和其他查询的接口，这些查询将返回和修改 ORM 映射的对象。 ORM 对象本身是在   :class:` .Session`  中维护的，在一个叫做  <span class="xref std std-term">身份映射(identity map)</span>  的结构中 - 一个数据结构，维护每个对象的唯一副本，其中 “唯一” 意味着“只有一个具有特定主键的对象”。</p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  开始时基本上是一个无状态的，在发出查询或持久化其他对象后，它会从与   :class:` .Session`  关联的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  中请求一个连接资源，然后在连接上建立一个事务。这个事务将一直保持到   :class:` .Session`  被指示提交或回滚事务为止。</p>
</div></blockquote>
<p>被   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  维护的 ORM 对象是  :term:` instrumented` ，当 Python 程序中的属性或集合被修改时，会生成一个更改事件，这个事件会被记录到   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中。当要查询数据库时，或者在事务将要提交时，  :class:` _orm.Session`  首先将内存中存储的所有待决更改刷新到数据库。这被称为  <span class="xref std std-term">unit of work</span>  模式。</p>
<p>使用一个   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  时，将 ORM 映射的对象维护为 <strong>代理对象(proxy object)</strong>，而这些对象对于保持与当前交易匹配的状态非常有用。为了保持对象在数据库中的状态与实际情况一致，有各种事件会导致对象重新访问数据库以保持同步。可以“分离”   :class:` .Session`  中的对象，并继续使用，虽然这种做法是有危险的。通常建议，当要再次使用这些对象时，应将它们重新关联到另一个   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中，以便它们可以恢复正常的数据库状态。</p>
</section>
<section id="session-basics">
<span id="id3"></span><h2>使用会话的基础<a class="headerlink" href="#session-basics" title="Permalink to this heading">¶</a></h2>
<p>这里介绍了最基本的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  使用模式。</p>
<section id="session-getting">
<span id="id4"></span><h3>开启和关闭会话<a class="headerlink" href="#session-getting" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  可以独立构建，也可以使用   :class:` _orm.sessionmaker`  类。通常情况下，会在开始时预先传递一个   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  对象作为连接资源。一种典型的用法可能是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="c1"># 连接资源由Session使用</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/&quot;</span><span class="p">)</span>

<span class="c1"># 创建会话并添加对象</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_other_object</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
</div></blockquote>
<p>上面的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  被实例化为关联到特定数据库 URL 的   :class:` _engine.Engine` 。然后它在 Python 上下文管理器（即 <cite>with:</cite> 语句）中使用，以便在块结束时它会被自动关闭。这相当于调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code>  方法。</p>
<p>调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  是可选的，并且仅在与   :class:` _orm.Session`  的工作包括新数据需要持久化到数据库时才需要。如果我们只是发出 SELECT 调用并且不需要写任何更改，则不需要调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>注意，在调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  之后，无论是显式调用还是使用上下文管理器，与   :class:` .Session`  关联的所有对象都被  <span class="xref std std-term">expired</span> ，意味着它们的内容被擦除以在下一个事务中重新加载。如果这些对象被  :term:` detach` ，除非使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.expire_on_commit</span> <span class="pre">`</span>&#160; <span class="pre">参数来禁用这个行为，否则它们将无法使用，直到重新关联到新的</span>&#160;&#160; <span class="pre">:class:</span></code> .Session` 。请参阅本节   <a class="reference internal" href="#session-committing"><span class="std std-ref">提交</span></a>  中的详细信息。</p>
</div>
</section>
<section id="session-begin-commit-rollback-block">
<span id="id5"></span><h3>构建/提交/回滚块<a class="headerlink" href="#session-begin-commit-rollback-block" title="Permalink to this heading">¶</a></h3>
<p>我们还可以在块中将  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  调用和整体“框架”的事务包含在一个上下文管理器中，用于那些将提交数据写入数据库的情况。发挥“框架”的意思是，如果所有操作都成功，那么将调用  :meth:` _orm.Session.commit`  方法，但如果出现任何异常，则将调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code>  方法，以便立即回滚事务，然后将异常向外传播。在 Python 中，这通常会使用类似于一个“try：/except：/else：”块来表达，如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 上一段示例的详细版</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_other_object</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>如上所示的操作序列，可以更简洁地实现，方法是使用由  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin()</span></code>  方法返回的   :class:` _orm.SessionTransaction`  对象，该对象为相同的操作序列提供了上下文管理器接口:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建会话并添加对象</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_other_object</span><span class="p">)</span>
    <span class="c1"># 内部上下文调用 session.commit()，如果没有异常</span>
<span class="c1"># 外部上下文调用 session.close()</span></pre></div>
</div>
<p>更简洁的是，可以合并这两个上下文:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建会话并添加对象</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">,</span> <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_other_object</span><span class="p">)</span>
<span class="c1"># 内部上下文调用 session.commit()，如果没有异常</span>
<span class="c1"># 外部上下文调用 session.close()</span></pre></div>
</div>
</section>
<section id="sessionmaker">
<h3>使用 sessionmaker<a class="headerlink" href="#sessionmaker" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  的作用是提供一个具有固定配置的   :class:` _orm.Session`  对象的工厂。由于应用程序通常会在模块范围内拥有一个   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  对象，因此   :class:` _orm.sessionmaker`  可以为针对此引擎的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  对象提供一个工厂:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="c1"># 连接资源由 Session 使用</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/&quot;</span><span class="p">)</span>

<span class="c1"># sessionmaker()，在与引擎相同的范围内使用</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># 我们现在可以构建一个 Session()，而不需要每次传递引擎</span>
<span class="k">with</span> <span class="n">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_other_object</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="c1"># 关闭会话</span></pre></div>
</div>
</div></blockquote>
<p>与   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  的行为相似，  :class:` _orm.sessionmaker`  是模块级函数级会话/连接的工厂。因此，它也具有它自己的  <code class="xref py py-meth docutils literal notranslate"><span class="pre">sessionmaker.begin()</span></code>  方法，类似于  :meth:` _engine.Engine.begin` ，该方法返回一个   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  对象，同时也维护一个 begin/commit/rollback 块:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="c1"># 连接资源由Session使用</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/&quot;</span><span class="p">)</span>

<span class="c1"># 此处engine是父级提供程序</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># 我们现在可以使用 Session.begin() 创建 Session() 并包含 begin()/commit()/rollback()</span>
<span class="k">with</span> <span class="n">Session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_other_object</span><span class="p">)</span>
<span class="c1"># 提交事务，关闭会话</span></pre></div>
</div>
<p>上面的例子中，当上述“with:”块结束时，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  将在提交事务并关闭：class:` _orm.Session`。</p>
<p>在编写应用程序时，应该将   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  工厂与由   :func:` _sa.create_engine`  创建的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  对象具有相同的作用域，通常在模块级或全局级别。由于这些对象都是工厂，它们可以被任意数量的函数和线程同时使用。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code></p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></p>
</div>
</section>
<section id="session-querying-20">
<span id="id6"></span><h3>查询<a class="headerlink" href="#session-querying-20" title="Permalink to this heading">¶</a></h3>
<p>查询的主要方式是利用   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  构造函数创建一个   :class:` _sql.Select`  对象，然后使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  和  :meth:` _orm.Session.scalars`  等方法执行它以返回结果。然后以类似于   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象的形式返回结果，其中包括子变量，例如   :class:` _result.ScalarResult` 。</p>
<p>ORM 查询的完整指南可以在   <a class="reference internal" href="queryguide/index.html"><span class="std std-ref">ORM 查询指南</span></a>  中找到。以下是一些简短的示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="c1"># 查询 ``User`` 对象</span>
    <span class="n">statement</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;ed&quot;</span><span class="p">)</span>

    <span class="c1"># ``User`` 对象列表</span>
    <span class="n">user_obj</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="c1"># 查询单个列</span>
    <span class="n">statement</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>

    <span class="c1"># Row 对象列表</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.0: </span>2.0 查询方式是标准的。有关从 1.x 系列的迁移说明，请参见   <a class="reference internal" href="../changelog/migration_20.html#migration-20-query-usage"><span class="std std-ref">ORM使用2.0迁移</span></a> 。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="queryguide/index.html"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</section>
<section id="session-adding">
<span id="id7"></span><h3>添加新项或现有项<a class="headerlink" href="#session-adding" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code>   用于将实例放置在会话中。对于  :term:` transient` （即全新的）实例，这将对下一个刷新时进行插入。对于  <span class="xref std std-term">persistent</span> （i.e. 是由此会话加载的）实例，它们已经存在，并不需要添加。可以使用这种方法来  :term:` detach` （即已从会话移除）的实例重新关联会话:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;user1&quot;</span><span class="p">)</span>
<span class="n">user2</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;user2&quot;</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user1</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user2</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 将更改写入数据库</span></pre></div>
</div>
</div></blockquote>
<p>要一次将项目列表添加到会话中，请使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add_all()</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">item3</span><span class="p">])</span>

<span class="p">:</span><span class="n">meth</span><span class="p">:</span><span class="err">`</span><span class="o">~.</span><span class="n">Session</span><span class="o">.</span><span class="n">add</span><span class="err">`</span>   <span class="n">操作沿着</span> <span class="err">“</span><span class="n">save</span><span class="o">-</span><span class="n">update</span><span class="err">”</span> <span class="n">级联</span><span class="err">，</span> <span class="n">对其属性和集合进行更改时发生级联操作的相关重要行为</span><span class="err">，</span><span class="n">请参阅</span>   <span class="p">:</span><span class="n">ref</span><span class="p">:</span><span class="err">`</span> <span class="n">unitofwork_cascades</span><span class="err">`</span>  <span class="n">节</span><span class="err">。</span></pre></div>
</div>
</section>
<section id="session-deleting">
<span id="id8"></span><h3>删除<a class="headerlink" href="#session-deleting" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code>   方法将实例放置到会话的对象删除列表中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code>   标记要删除的对象，将对每个受影响的主键发出 DELETE 语句。在待删除的行在刷新之前，标有“删除”的对象将存在于  :attr:` _orm.Session.deleted`  集合中。在执行 DELETE 之后，他们将从   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中删除，并且在事务提交后，   :class:` _orm.Session`  变为永久状态。</p>
</div></blockquote>
<p>与  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code>  相关的各种重要行为，特别是如何处理其他对象和集合的关系，有各种信息。在   :ref:` unitofwork_cascades`  节中有更多关于这公司工作的信息，但通常的规则是：</p>
<ul class="simple">
<li><p>通过   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  指令与删除对象相关联的映射对象对应的行默认情况下是不会删除的，如果这些对象对待删除的行具有反向的外键约束，则这些列将被设置为 NULL。如果这些列是不可为空的，则会导致约束冲突。</p></li>
<li><p>通过在   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  上使用   :ref:` cascade_delete`  级联将“SET NULL”更改为删除相关对象的行。</p></li>
<li><p>对于通过  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.secondary</span></code>  参数连接为“多对多”的表中的行，在删除它们所引用的对象时，在所有情况下它们都将被删除。</p></li>
<li><p>当相关对象包括对被删除对象的外键约束并且它们所属的关联集合当前未加载到内存中时，单元操作将发出一个 SELECT，以便其主键值或在这些相关行上发出 UPDATE 或 DELETE 语句。这样，ORM 将在不需要其他指令的情况下执行 ON DELETE CASCADE 的功能，即使在使用此功能时未对 Core 的   <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>  进行配置。</p></li>
<li><p>可以使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.passive_deletes</span></code>  参数调整此行为，并自然地依赖于“ON DELETE CASCADE”。当设置为 True 时，此 SELECT 操作将不再发生，但是适用本地存在的行仍会受到显式 SET NULL 或 DELETE 的影响。将  :paramref:` _orm.relationship.passive_deletes`  设置为字符串 <cite>“all”</cite> 将禁用所有相关对象更新/删除。</p></li>
<li><p>当删除一个标记为删除的对象时，不会自动从引用它的集合或对象引用中移除对象。当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  过期时，这些集合可以再次加载，以便对象不再存在。然而，与其使用  :meth:` _orm.Session.delete`  删除这些对象，不如将对象从其集合中移除，然后使用   <a class="reference internal" href="cascades.html#cascade-delete-orphan"><span class="std std-ref">delete-orphan</span></a>  使它在移除集合时作为次要效应被删除。请参阅   :ref:` session_deleting_from_collections`  节以获取此类示例。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="cascades.html#cascade-delete"><span class="std std-ref">delete</span></a>  —— 描述“删除级联”，当引导对象被删除时，它标记相关对象以被删除。</p>
<p><a class="reference internal" href="cascades.html#cascade-delete-orphan"><span class="std std-ref">delete-orphan</span></a>  —— 描述了“删除孤儿级联 orphan”，它标记相关对象以在其与引导对象的关系被取消时删除。</p>
<p><span class="xref std std-ref">session_deleting_from_collections</span>  —— 重要的背景信息，删除涉及关系在内存中刷新的方式。</p>
</div>
</section>
<section id="session-flushing">
<span id="id9"></span><h3>刷新<a class="headerlink" href="#session-flushing" title="Permalink to this heading">¶</a></h3>
<p>当使用其默认配置的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  时，刷新步骤几乎总是透明执行的。特别是，在执行任何单个 SQL 语句的结果之前，都会刷新所有未处理的 SQL 语句，或使用查询返回结果（最终使用  :meth:` _orm.Session.execute` ），或者如果在  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  调用之前更改了内部   :class:` .Session`  对象的状态，那么在  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  之前也会进行刷新。在使用  :meth:` .Session.begin_nested`  时发出保存点时，也会进行刷新。</p>
<p>可以随时通过调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.flush()</span></code>  方法来强制执行会话刷新:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></pre></div>
</div>
<p>几乎总是在特定方法的范围内执行自动刷新步骤，这些方法包括:</p>
<ul class="simple">
<li><p>当针对启用 ORM 的 SQL 结构，例如引用了 ORM 实体和/或 ORM 映射属性的   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  对象或其他 SQL 执行方法时，例如  :meth:` _orm.Session.execute`  和其他 SQL 执行方法。</p></li>
<li><p>当使用   <a class="reference internal" href="queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  执行以返回结果的方式执行时（这最终使用  :meth:` _orm.Session.execute` ）。</p></li>
<li><p>当在  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.merge()</span></code>  方法之前进行本地未处理对象刷新时。</p></li>
<li><p>懒加载操作针对未加载的对象属性时。</p></li>
</ul>
<p>此外，还有一些点无条件地执行 <strong>刷新</strong>。这些点是键事务边界，包括：</p>
<ul class="simple">
<li><p>在  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  方法的过程中。</p></li>
<li><p>当调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin_nested()</span></code>  时</p></li>
<li><p>当使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.prepare()</span></code>  的 2PC 方法。</p></li>
</ul>
<p>所谓的 <strong>自动刷新</strong> 行为，用于上面的列表中的行为，可以通过构造使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.autoflush</span></code>  参数为 ` <cite>False`</cite> 的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  或   :class:` .sessionmaker`  来禁用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">autoflush</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></pre></div>
</div>
<p>此外，可在使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  时使用  :attr:` .Session.no_autoflush`  上下文管理器临时禁用自动刷新:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">mysession</span><span class="o">.</span><span class="n">no_autoflush</span><span class="p">:</span>
    <span class="n">mysession</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
    <span class="n">mysession</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></pre></div>
</div>
<p>需要重申的是，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  仅在以  :term:` DBAPI`  事务上下文执行 SQL 命令时才会发出刷新，只要 DBAPI 不在   <a class="reference internal" href="../core/connections.html#dbapi-autocommit"><span class="std std-ref">driver level autocommit</span></a>  模式下。这意味着假设数据库连接在其事务设置中提供  :term:` 原子性` ，如果在刷新中有任何单个 DML 语句失败，则整个操作将被回滚。</p>
<p>当刷新失败时，为了继续使用同一   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，必须在刷新失败后显式调用  :meth:` ~.Session.rollback` ，即使底层事务已经回滚了（即使数据库驱动程序在技术上处于驱动程序级别的自动提交模式）。这是为了始终保持所谓的 “子事务” 嵌套模式的一致性。FAQ 节   <a class="reference internal" href="../faq/sessions.html#faq-session-rollback"><span class="std std-ref">“This Session’s transaction has been rolled back due to a previous exception during flush.” (或类似消息)</span></a>  中包含有关此行为的更详细说明。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../faq/sessions.html#faq-session-rollback"><span class="std std-ref">“This Session’s transaction has been rolled back due to a previous exception during flush.” (或类似消息)</span></a>  —— 关于刷新失败时为什么必须调用  :meth:` _orm.Session.rollback`  的进一步背景信息。</p>
</div>
</section>
<section id="session-get">
<span id="id10"></span><h3>按主键获取<a class="headerlink" href="#session-get" title="Permalink to this heading">¶</a></h3>
<p>由于   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  使用  :term:` identity map`  引用当前内存中的对象和主键，因此提供了用于按主键定位对象的  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get()</span></code>  方法，首先在当前身份映射中查找对象，然后在数据库中查询缺失数据。例如，要定位主键标识符为 ` <cite>(5,)`</cite> 的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">my_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">:</span><span class="n">meth</span><span class="p">:</span><span class="err">`</span><span class="n">_orm</span><span class="o">.</span><span class="n">Session</span><span class="o">.</span><span class="n">get</span><span class="err">`</span>   <span class="n">还包括调用形式</span><span class="err">，</span><span class="n">用于传递组合主键值</span><span class="err">，</span><span class="n">这些值可以作为元组或字典传递</span><span class="err">，</span><span class="n">以及允许特定的加载程序和执行选项的附加参数</span><span class="err">。</span><span class="n">有关完整的参数列表</span><span class="err">，</span><span class="n">请参见</span>  <span class="p">:</span><span class="n">meth</span><span class="p">:</span><span class="err">`</span> <span class="n">_orm</span><span class="o">.</span><span class="n">Session</span><span class="o">.</span><span class="n">get</span><span class="err">`</span> <span class="err">。</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get()</span></code></p>
</div>
</section>
<section id="session-expiring">
<span id="id11"></span><h3>过期/刷新<a class="headerlink" href="#session-expiring" title="Permalink to this heading">¶</a></h3>
<p>使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  时，一个重要的考虑因素通常是处理从数据库加载的对象的状态，以保持它们与当前事务的最新状态同步。SQLAlchemy ORM 基于一个  :term:` identity map`  的概念，因此，当从 SQL 查询中“加载”一个对象时，将维护对应于特定数据库标识符的唯一 Python 对象实例。这意味着，如果我们发出两个分开的查询，每个查询，针对同一行，得到一个映射对象，那么这两个查询将返回同一个 Python 对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="ow">is</span> <span class="n">u2</span>
<span class="go">True</span></pre></div>
</div>
<p>由此引申出来，当 ORM 从查询中获得行时，它将跳过为已经加载的对象进行属性复制。这里设计的假设是假设事务是完全隔离的，然后到某种程度上事务不是隔离的，应用程序可以根据需要采取步骤刷新对象从数据库事务。FAQ 链接   <a class="reference internal" href="../faq/sessions.html#faq-session-identity"><span class="std std-ref">我正在使用会话重新加载数据，但是没有看到在其他地方提交的更改</span></a>  更详细地讨论了这个概念。</p>
<p>当 ORM 映射对象被加载到内存中时，有三种一般方法可以使用当前事务的新数据刷新其内容：</p>
<ul>
<li><p><strong>过期() 方法</strong> ——  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.expire()</span></code>  方法可擦除对象的选择性或所有属性的内容，以便在下一次访问它们时从数据库中加载，例如，使用  :term:` lazy loading`  模式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="n">u1</span><span class="o">.</span><span class="n">some_attribute</span>  <span class="c1"># &lt;-- 从事务中进行的懒加载</span></pre></div>
</div>
</li>
<li><p><strong>刷新() 方法</strong> ——  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.refresh()</span></code>  方法密切相关，它表现得和  :meth:` _orm.Session.expire`  方法相同，但还会立即发出一次或多次 SQL 查询，以实际刷新对象的内容:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>  <span class="c1"># &lt;-- 发出 SQL 查询</span>
<span class="n">u1</span><span class="o">.</span><span class="n">some_attribute</span>  <span class="c1"># &lt;-- 从事务中进行刷新</span></pre></div>
</div>
</li>
<li><p><strong>populate_existing() 方法或执行选项</strong> —— 这是一个在   <a class="reference internal" href="queryguide/api.html#orm-queryguide-populate-existing"><span class="std std-ref">填充现有的实例</span></a>  中记录的执行选项；在遗留形式中，它在   :class:` _orm.Query`  对象上被称为  <a class="reference internal" href="queryguide/query.html#sqlalchemy.orm.Query.populate_existing" title="sqlalchemy.orm.Query.populate_existing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.populate_existing()</span></code></a>  方法。在任一形式中，这个操作指示返回查询的对象应该从它们在数据库中的内容中进行不可条件地的重新生成:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">populate_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span></pre></div>
</div>
</li>
</ul>
<p>有关刷新/过期概念的更多讨论可以在   <a class="reference internal" href="session_state_management.html#session-expire"><span class="std std-ref">刷新/到期</span></a>  找到。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="session_state_management.html#session-expire"><span class="std std-ref">刷新/到期</span></a></p>
<p><a class="reference internal" href="../faq/sessions.html#faq-session-identity"><span class="std std-ref">我正在使用会话重新加载数据，但是没有看到在其他地方提交的更改</span></a></p>
</div>
</section>
<section id="where-update-delete">
<h3>使用任意 WHERE 子句进行 UPDATE 和 DELETE<a class="headerlink" href="#where-update-delete" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 2.0 包括增强功能，以发出几种启用 ORM 的 INSERT、UPDATE 和 DELETE 语句。请参见  <a class="reference internal" href="queryguide/dml.html"><span class="doc">ORM-启用的INSERT、UPDATE和DELETE语句</span></a>  中的文档。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="queryguide/dml.html"><span class="doc">ORM-启用的INSERT、UPDATE和DELETE语句</span></a></p>
<blockquote>
<div><p><a class="reference internal" href="queryguide/dml.html#orm-queryguide-update-delete-where"><span class="std std-ref">带有自定义WHERE条件的ORM UPDATE and DELETE</span></a></p>
</div></blockquote>
</div>
</section>
<section id="session-autobegin">
<span id="id12"></span><h3>自动启动<a class="headerlink" href="#session-autobegin" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  对象具有被称为 <strong>autobegin</strong> 的行为。这表示   :class:` _orm.Session`  在内部将自身视为“事务”状态，只要使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  执行任何工作，无论是涉及到修改   :class:` _orm.Session`  的内部状态与对象状态更改的情况，还是涉及到需要数据库连接的操作。</p>
</div></blockquote>
<p>当首次构造   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  时，不存在事务状态。当调用像  :meth:` _orm.Session.add`  或  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  这样的方法时，或者类似地，如果执行查询以返回结果（最终使用  :meth:` _orm.Session.execute` ），或者修改了  <span class="xref std std-term">persistent</span>  对象上的属性，那么会自动开始处理事务状态。</p>
<p>可以通过访问  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.in_transaction()</span></code>  方法来检查   :class:` _orm.Session`  的事务状态，它返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>，指示“autobegin”步骤是否已经进行。虽然通常不需要，但  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.get_transaction()</span></code>  方法将返回表示此事务状态的实际   :class:` _orm.SessionTransaction`  对象。</p>
<p>也可以通过调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin()</span></code>  显式启动   :class:` _orm.Session`  的事务状态。当调用此方法时，无条件地将   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  置于“事务”状态。  :meth:` _orm.Session.begin`  可以按照   <a class="reference internal" href="#session-begin-commit-rollback-block"><span class="std std-ref">构建/提交/回滚块</span></a>  中所述的方式作为上下文管理器使用。</p>
<section id="autobegin">
<span id="session-autobegin-disable"></span><h4>禁用 Autobegin 以防止隐式事务<a class="headerlink" href="#autobegin" title="Permalink to this heading">¶</a></h4>
<p>可以使用  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.autobegin</span></code>  参数将“autobegin”行为设置为 ` <cite>False`</cite> 以禁用它。使用此参数，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  将要求必须显式调用  :meth:` _orm.Session.begin`  才能使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 。在构造后，在调用任何  :meth:` _orm.Session.rollback` 、  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>   或  :meth:` _orm.Session.close`  方法后，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  将不会在隐式地开始任何新的事务；如果在不首先调用  :meth:` _orm.Session.begin`  的情况下尝试使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，则会引发错误:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">autobegin</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>  <span class="c1"># &lt;-- 如有必要，否则下一次调用将抛出 InvalidRequestError</span>

    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;u1&quot;</span><span class="p">))</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

    <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>  <span class="c1"># &lt;-- 如有必要，否则下一次调用将抛出InvalidRequestError</span>

    <span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;u1&quot;</span><span class="p">))</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>添加了  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.autobegin</span></code> ，允许禁用“autobegin”行为</p>
</div>
</section>
</section>
<section id="session-committing">
<span id="id13"></span><h3>提交<a class="headerlink" href="#session-committing" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>   用于提交当前事务。从本质上讲，这表示在事务性方法（例如  :meth:` .Session.commit`  和  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin_nested()</span></code> ）发出之前在内部发出 ` COMMIT` 语句。同时也会在  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  之前进一步持久化任何待处理的 SQL 操作。</p>
</div></blockquote>
<p>以下是一个简单的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s2">&quot;ed&quot;</span><span class="p">,</span> <span class="s2">&quot;Ed Jones&quot;</span><span class="p">,</span> <span class="s2">&quot;edspassword&quot;</span><span class="p">)</span>
    <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code></p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.begin_nested()</span></code></p>
</div>
</section>
<section id="session-close">
<span id="id14"></span><h3>关闭<a class="headerlink" href="#session-close" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  对象被设计为不可重用。也就是说，在调用  :meth:` .Session.commit` 、  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code>   或  :meth:` .Session.close`  之一之后，必须丢弃对象并创建新对象，才能继续执行新的数据库操作。</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></p>
</div></blockquote>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code> 所有当前拥有事务的数据库连接；</p>
</div>
<p>从  <span class="xref std std-term">DBAPI</span>  的视角来看，这意味着会在每个 DBAPI 的连接上调用 ` <cite>connection.commit()`</cite> 方法。</p>
<p>当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中没有进行事务，表示自上一次调用  :meth:` .Session.commit`  以来，没有在此   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  上执行任何操作时，该方法将开始并提交一个仅在内部使用的“逻辑”事务，这通常不会对数据库产生影响，除非检测到挂起的刷新更改，但仍将调用事件处理程序和对象过期规则。</p>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>   操作始终在发出 COMMIT 命令之前无条件地发出  :meth:` ~.Session.flush` 。如果没有检测到任何挂起的更改，则不会向数据库发出 SQL。此行为不可配置，并且不受  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.autoflush</span></code>  参数的影响。</p>
</div></blockquote>
<p>在此之后，如果存在实际的数据库事务，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>   将提交这些事务。</p>
<p>最后，在事务结束时，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  中的所有对象都将被  :term:` 过期` 。这样，当实例下次被访问时，无论是通过属性访问还是通过它们出现在 SELECT 的结果中，它们都会接收到最新的状态。此行为可以通过  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.expire_on_commit</span></code>  参数控制，如果不希望发生该行为，则可以将其设置为 ` <cite>False`</cite>。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#session-autobegin"><span class="std std-ref">自动启动</span></a></p>
</div>
</section>
<section id="session-rollback">
<span id="id15"></span><h3>回滚<a class="headerlink" href="#session-rollback" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code>   会回滚当前事务（如果有）。如果没有正在进行的事务，则该方法会静默传递。</p>
</div></blockquote>
<p>对于默认配置的会话，
在既定的事务开始通过   <a class="reference internal" href="#session-autobegin"><span class="std std-ref">autobegin</span></a>  方法时，
Session 在回滚后的状态如下：</p>
<ul class="simple">
<li><p>所有事务都将被回滚，所有连接都将返回到连接池中，除非 Session 直接绑定到连接，否则连接仍然保持（但仍会回滚）。</p></li>
<li><p>在事务生命周期内最初处于  <span class="xref std std-term">待定</span>  状态的对象将被清除，与将其 INSERT 语句回滚相对应。它们的属性状态保持不变。</p></li>
<li><p>在事务生命周期中标记为  <span class="xref std std-term">删除</span>  的对象将被提升回  :term:` 持久性`  状态，与将它们的 DELETE 语句回滚相对应。请注意，如果这些对象在事务中首先处于  <span class="xref std std-term">待定</span>  状态，则优先级较高。</p></li>
<li><p>所有未被清除的对象都将完全过期-这与  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.expire_on_commit</span></code>  设置无关。</p></li>
</ul>
<p>了解了这种状态之后，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  可以在回滚发生后安全地继续使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.4: </span></p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  对象现在具有延迟“begin”行为，如   :ref:` autobegin &lt;session_autobegin&gt;`  中所述。如果没有启动事务，</p>
</div></blockquote>
<p>如  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  和  :meth:` _orm.Session.rollback`  方法将没有效果。
在非自动提交模式下，这种行为在 1.4 之前不会被观察到，因为事务总是隐式存在。</p>
</div>
<p>当  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.flush()</span></code>  失败时，通常是由于违反主键、外键或“非 null”约束等原因，将自动发出 ROLLBACK（目前不可能在部分故障后继续刷新）。但是，在此时，   :class:` _orm.Session`  进入一种称为“非活动”的状态，调用应用程序必须始终显式调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.rollback()</span></code>  方法，以便   :class:` _orm.Session`  可以回到可用状态（也可以简单地关闭和丢弃）。如需详细的讨论，请参见   <a class="reference internal" href="../faq/sessions.html#faq-session-rollback"><span class="std std-ref">“This Session’s transaction has been rolled back due to a previous exception during flush.” (或类似消息)</span></a>  中的 FAQ。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#session-autobegin"><span class="std std-ref">自动启动</span></a></p>
</div>
</section>
<section id="session-closing">
<span id="id16"></span><h3>关闭<a class="headerlink" href="#session-closing" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code>   方法会发出  :meth:` ~.Session.expunge_all` ，从会话中删除所有 ORM 映射对象，并将所有事务性 / 连接资源从固定到它的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  对象中释放。当将连接返回到连接池时，事务状态也会回滚。</p>
</div></blockquote>
<p>当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  关闭时，它本质上与初始构造时相同的状态，并且**可以再次使用**。在这方面，  :meth:` _orm.Session.close`  方法更像是一种“重置”回到清洁状态的方法，而不是像一种“数据库关闭”方法。</p>
<p>建议在   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  的作用域内限制  :meth:` _orm.Session.close`  的调用，特别是如果没有使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>  或  :meth:` _orm.Session.rollback`  方法。   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  可以作为上下文管理器使用，以确保调用  :meth:` _orm.Session.close`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span>

<span class="c1"># 自动关闭会话</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.4: </span></p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  对象具有延迟“begin”行为，如   :ref:` autobegin &lt;session_autobegin&gt;`  中所述。</p>
</div></blockquote>
<p>在调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.close()</span></code>  方法后不再立即开始新事务。</p>
</div>
</section>
</section>
<section id="session-faq">
<span id="id17"></span><h2>会话常见问答<a class="headerlink" href="#session-faq" title="Permalink to this heading">¶</a></h2>
<p>到这个时候，许多用户已经对会话有疑问了。本节提供一个迷你 FAQ（注意我们也有  <a class="reference internal" href="../faq/index.html"><span class="doc">完整的 FAQ</span></a> ），涵盖了使用   :class:` .Session`  时最基本的问题。</p>
<section id="id18">
<h3>何时创建   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code> ？<a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h3>
<p>只要在您应用程序的全局范围内的某个地方一次。它应该被视为您应用程序的配置的一部分。如果您的应用程序在一个包中有三个 .py 文件，则例如，您可以将   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  放在您的 ` <cite>__init__.py`</cite> 文件中；从那时起，其他模块可以说“from mypackage import Session”。这样，其他人只使用  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session()</span></code> ，而该会话的配置由该中心点控制。</p>
<p>如果应用程序启动，执行导入操作，但不知道将要连接到哪个数据库，则可以在稍后使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">sessionmaker.configure()</span></code>  将   :class:` .Session`  在“类”级别绑定到引擎。</p>
<p>在本节中的示例中，我们经常会展示   <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  在我们实际上调用   :class:` .Session`  之前创建。但这只是为了举例说明！实际上，  <code class="xref py py-class docutils literal notranslate"><span class="pre">sessionmaker</span></code>  将出现在模块级别的某个地方。由此生成   :class:` .Session`  的调用将放置在应用程序开始进行其工作的地方。</p>
</section>
<section id="session">
<span id="session-faq-whentocreate"></span><h3>何时构建   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，何时提交，何时关闭？<a class="headerlink" href="#session" title="Permalink to this heading">¶</a></h3>
<aside class="topic">
<p class="topic-title">简而言之;</p>
<ol class="arabic simple">
<li><p>通常情况下，应将会话的生命周期与访问和/或操作数据库数据的函数和对象**分开**。这将极大地有助于实现可预测且一致的事务范围。</p></li>
<li><p>确保您清楚地知道何时开始和结束事务，并使事务**短暂**，即在一系列操作结束时结束，而不是无限期地保持打开状态。</p></li>
</ol>
</aside>
<p>通常会在可能预期访问数据库的逻辑操作开始时构建   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 。</p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  每次与数据库通信时，都会立即开始数据库事务。该事务将保持在   :class:` .Session`  回滚，提交或关闭时，如无正在进行的事务。如果再次使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，则会开始新的事务，而非在前一个事务结束后。从这个角度来看，   :class:` .Session`  可以跨越多个事务的生命周期，但一次只能有一个。我们将这两个概念称为**事务范围**和**会话范围**。</p>
</div></blockquote>
<p>通常并不难确定在何处开始和结束   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  的范围，尽管可能会引入各种应用程序结构。</p>
<p>其中一些示例场景包括：</p>
<ul class="simple">
<li><p>Web 应用程序。在这种情况下，最好使用所用 Web 框架提供的 SQLAlchemy 集成。否则，基本模式是在 Web 请求开始时创建   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，在执行 POST、PUT 或 DELETE 的 Web 请求结束时调用  :meth:` _orm.Session.commit`  方法，然后在 Web 请求结束时关闭会话。通常，最好将  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.expire_on_commit</span></code>  设置为 False，这样前端代码中从   :class:` _orm.Session`  返回的对象不需要发出新的 SQL 查询以刷新对象，如果事务已经提交。</p></li>
<li><p>后台守护程序生成子进程。在这种情况下，最好为每个子进程创建一个本地的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，在处理的“作业”生命周期内使用该会话，然后在完成作业时将其关闭。</p></li>
<li><p>对于命令行脚本，应用程序将创建一个单独的全局   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，该 Session 在程序开始执行其工作时建立，并在程序完成其任务时立即提交它。</p></li>
<li><p>对于基于 GUI 界面的应用程序，  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  的作用范围可能最好位于用户生成的事件的范围内，例如按钮推送。或者，作用范围可能对应于明确的用户交互，例如用户”打开”一系列记录，然后将其“保存”。</p></li>
</ul>
<p>作为一般规则，应用程序应将会话的生命周期与特定数据处理函数和方法之外的数据分开*外部*来处理。这是一个基本的问题分离，使得数据特定操作能够获得对访问和操纵该数据的上下文的暴露。</p>
<p>例如，<strong>不要这样做</strong>：：</p>
<blockquote>
<div><p>### 这是**错误的** 范例 ###</p>
<dl>
<dt>class ThingOne:</dt><dd><dl>
<dt>def go(self):</dt><dd><p>session = Session()
try:</p>
<blockquote>
<div><p>session.execute(update(FooBar).values(x=5))
session.commit()</p>
</div></blockquote>
<dl class="simple">
<dt>except:</dt><dd><p>session.rollback()
raise</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>class ThingTwo:</dt><dd><dl>
<dt>def go(self):</dt><dd><p>session = Session()
try:</p>
<blockquote>
<div><p>session.execute(update(Widget).values(q=18))
session.commit()</p>
</div></blockquote>
<dl class="simple">
<dt>except:</dt><dd><p>session.rollback()
raise</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def run_my_program():</dt><dd><p>ThingOne().go()
ThingTwo().go()</p>
</dd>
</dl>
</div></blockquote>
<p>将会话（和通常是事务）的生命周期**分开**对于使用特定数据的操作是不太可能的。下面的示例说明了这可能如何看起来，同时还使用 Python 上下文管理器（即``with:`` 关键字）来自动处理   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  和其事务的范围：：</p>
<blockquote>
<div><p>### 这是一个更好但不是唯一的方式 ###</p>
<dl class="simple">
<dt>class ThingOne:</dt><dd><dl class="simple">
<dt>def go(self, session):</dt><dd><p>session.execute(update(FooBar).values(x=5))</p>
</dd>
</dl>
</dd>
<dt>class ThingTwo:</dt><dd><dl class="simple">
<dt>def go(self, session):</dt><dd><p>session.execute(update(Widget).values(q=18))</p>
</dd>
</dl>
</dd>
<dt>def run_my_program():</dt><dd><dl class="simple">
<dt>with Session() as session:</dt><dd><dl class="simple">
<dt>with session.begin():</dt><dd><p>ThingOne().go(session)
ThingTwo().go(session)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.4: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  可以作为上下文管理器使用，无需使用外部帮助器函数。</p>
</div>
</section>
<section id="id19">
<h3>Session 是缓存吗？<a class="headerlink" href="#id19" title="Permalink to this heading">¶</a></h3>
<p>有点是，因为它实现了  <a class="reference internal" href="../glossary.html#term-30"><span class="xref std std-term">标识映射</span></a> (identity map) 模式，并存储按其主键编为键的对象。但是，它不会缓存任何查询。这意味着，即使 ` <cite>Foo(name=’bar’)`</cite> 在唯一映射中，当您说``session.scalars(select(Foo).filter_by(name=’bar’))`` 时，Session 也不知道。它不得不向数据库发送 SQL，获取行，然后当它看到行中的主键时，<a href="#id20"><span class="problematic" id="id21">*</span></a>然后*才可以在本地标识映射中查找该对象。只有在您说 <code class="docutils literal notranslate"><span class="pre">query.get({some</span> <span class="pre">primary</span> <span class="pre">key})</span></code> 时，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  才不必发出查询。</p>
<p>此外，默认情况下，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  使用弱引用存储对象实例。这也破坏了将 Session 用作缓存的目的。</p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  不是设计成每个人都可以作为“注册表”查询的全局对象。这更多地是第二级缓存的工作。SQLAlchemy 提供了一种使用 ` dogpile.cache &lt;<a class="reference external" href="https://dogpilecache.readthedocs.io/">https://dogpilecache.readthedocs.io/</a>&gt;`_ 实现第二级缓存的方式，通过   <a class="reference internal" href="examples.html#examples-caching"><span class="std std-ref">Dogpile 缓存</span></a>  示例。</p>
</div></blockquote>
</section>
<section id="id22">
<h3>如何获取某个对象的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ？<a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h3>
<p>使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.object_session()</span></code>  类方法，该方法可用于  :class:` ~sqlalchemy.orm.session.Session`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">object_session</span><span class="p">(</span><span class="n">someobject</span><span class="p">)</span></pre></div>
</div>
<p>较新的   <span class="xref std std-ref">core_inspection_toplevel</span>  系统也可用于获取会话:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">inspect</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">someobject</span><span class="p">)</span><span class="o">.</span><span class="n">session</span></pre></div>
</div>
</section>
<section id="session-asyncsession">
<span id="session-faq-threadsafe"></span><h3>Session 是线程安全的吗？在并发任务中共享 AsyncSession 是安全的吗？<a class="headerlink" href="#session-asyncsession" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  是表示单个数据库事务的**可变状态对象**。因此，<strong>单个   :class:` .Session`  实例不能在并发线程或 asyncio 任务之间共享，除非小心同步</strong>。  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  旨在以**非并发**方式使用，即特定的   :class:` .Session`  实例应仅在一个线程或任务中使用。</p>
</div></blockquote>
<p>在使用 SQLAlchemy 的   <a class="reference internal" href="extensions/asyncio.html"><span class="std std-ref">异步 I/O (asyncio)</span></a>  扩展中的   :class:` _asyncio.AsyncSession`  对象时，该对象仅是在   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  顶部的一个薄代理，因此相同的规则适用;它是一个**不同步，可变的有状态对象**，因此一个单独的   :class:` _asyncio.AsyncSession`  实例不能方便地在多个 asyncio 任务中使用。</p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  或   :class:` _asyncio.AsyncSession`  的一个实例代表一个单一的逻辑数据库事务，只引用其绑定到的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  或   :class:` .AsyncEngine`  的一个   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 。请注意，这些对象均支持绑定到多个引擎，但在事务范围内，仍然每个引擎仅有一个连接处于活动状态。</p>
</div></blockquote>
<p>在事务中的数据库连接也是一个有状态的对象，它旨在以非并发序列方式进行操作。命令按一定的顺序在连接上发出，这些命令由数据库服务器按其发出的确切顺序处理。当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  发出命令并接收结果时，它本身正在通过内部状态转换，与此连接上的命令和数据状态相一致。这些状态包括是否启动、提交或回滚了事务，任何正在发挥作用的 SAVEPOINT，以及将数据库行状态与本地 ORM 映射的对象进行微调粒度的同步。</p>
<p>在设计并发性数据库应用程序时，应采用每个并发任务/线程使用自己的数据库事务的适当模型。因此，当讨论数据库并发问题时，使用的标准术语是**多个并发事务**。在传统的 RDMS 中，不存在接收和处理多个并发命令的单个数据库事务的类似物。</p>
<p>因此，SQLAlchemy 的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  和   :class:` _asyncio.AsyncSession`  的并发模型为**每个线程一个 Session，每个任务一个 AsyncSession**。使用多个线程或在 asyncio 中使用多个任务（例如，使用诸如 <a href="#id23"><span class="problematic" id="id24">``</span></a>asyncio.gather()``的 API）的应用程序将确保每个线程都有自己的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，每个 asyncio 任务都有自己的   :class:` _asyncio.AsyncSession` 。</p>
<p>确保使用本地范围内的标准上下文管理器模式在 Python 函数或任务的顶级内部管理   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  或   :class:` _asyncio.AsyncSession`  的范围，将确保   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  或   :class:` _asyncio.AsyncSession`  的生命周期在本地范围内维护。</p>
<p>对于应用程序从全局方面受益的全局   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ，其中将 Session 对象传递给特定的函数和方法的选项不是一个选择，   :class:` .scoped_session` .Session` 对象；请参见   <span class="xref std std-ref">unitofwork_contextual</span>  一节对此进行了说明。在 asyncio 上下文中，   :class:` .async_scoped_session`  对象是   <a class="reference internal" href="contextual.html#sqlalchemy.orm.scoped_session" title="sqlalchemy.orm.scoped_session"><code class="xref py py-class docutils literal notranslate"><span class="pre">scoped_session</span></code></a>  的 asyncio 对应物，但更难以配置，因为它需要一个自定义的“上下文”函数。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="session.html" title="previous chapter">用 Session</a>
        Next:
        <a href="session_state_management.html" title="next chapter">状态管理</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:59:03

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


