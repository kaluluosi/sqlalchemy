<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    SQLAlchemy 2.0 有什么新特性？
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="变更和迁移" href="index.html" />
        <link rel="next" title="2.0 变更日志" href="changelog_20.html" />
        <link rel="prev" title="SQLAlchemy 2.0 - 主要迁移指南" href="migration_20.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="变更和迁移">变更和迁移</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="migration_20.html">SQLAlchemy 2.0 - 主要迁移指南</a></span></li>
<li class="selected"><span class="link-container"><strong>SQLAlchemy 2.0 有什么新特性？</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#orm">核心和 ORM 中的新类型支持 - 不再使用存根 / 扩展</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sql">SQL 表达式 / 语句 / 结果集类型</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">工作原理和概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="#whatsnew-20-expression-typing-examples">SQL 表达式类型化 - 示例</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-models">ORM Declarative Models</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id3">概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="#whatsnew-20-orm-typing-migration">迁移现有的 ORM 映射</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#orm-declarative-base-orm-declarativebase">步骤一 - <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code> 被 <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code> 取代。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-mapped-column-declarative-schema-column">步骤二 - 使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 替换 Declarative 使用的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#python-orm-mapped">步骤三 - 根据需要应用确切的 Python 类型，使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code>。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-mapped-column">步骤四 - 移除 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的指令了</a></span></li>
<li><span class="link-container"><a class="reference external" href="#pep-593-annotated">步骤五 - 使用 pep-593 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 将常用的指令打包到类型中</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#whatsnew-20-migration">迁移指南</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#orm-dataclasses">原生支持作为 ORM 模型封装的 dataclasses</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python3-7">Python3.7 /类型批注动态关系支持</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#pep-517">安装现在完全支持pep-517</a></span></li>
<li><span class="link-container"><a class="reference external" href="#ccython">C扩展现已移植到Cython</a></span></li>
<li><span class="link-container"><a class="reference external" href="#api">数据库反射的主要架构、性能和API增强</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id23">性能概述</a></span></li>
<li><span class="link-container"><a class="reference external" href="#inspector">``Inspector()``的行为变化</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id30">新方法和Inspector()的改进</a></span></li>
<li><span class="link-container"><a class="reference external" href="#psycopg-3-psycopg">方言支持psycopg 3（也称“psycopg”）</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dialect-support-for-oracledb">Dialect support for oracledb</a></span></li>
<li><span class="link-container"><a class="reference external" href="#ddl">新的约束和索引条件DDL</a></span></li>
<li><span class="link-container"><a class="reference external" href="#date-time-datetime">DATE，TIME，DATETIME数据类型现在在所有后端都支持文本呈现</a></span></li>
<li><span class="link-container"><a class="reference external" href="#result-asyncresult"><code class="docutils literal notranslate"><span class="pre">Result</span></code>, ``AsyncResult``现在支持上下文管理器</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id65">行为变化</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#session">新的事务加入模式 <code class="docutils literal notranslate"><span class="pre">Session</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#str-engine-url"><code class="docutils literal notranslate"><span class="pre">str(engine.url)</span></code> 默认情况下会隐藏密码</a></span></li>
<li><span class="link-container"><a class="reference external" href="#table">以相同名称、键的列替换Table对象严格规则</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-sort-order">ORM映射的列顺序有所不同;使用``sort_order``控制行为</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sequence-sql-server">``Sequence``构造现在默认不具有任何显式的默认“开始”值；影响到SQL Server</a></span></li>
<li><span class="link-container"><a class="reference external" href="#with-variant-typeengine">``with_variant()``方法克隆原始的TypeEngine而不是更改类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python">Python除法操作符在所有后端上执行真除法；增加整数除法</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-7433">Session提示检测到非法并发或可重入访问时引发</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlitequeuepool">SQLite方言对基于文件的数据库使用QueuePool</a></span></li>
<li><span class="link-container"><a class="reference external" href="#oracle-float">新的带二进制精度的Oracle FLOAT类型；不直接接受十进制精度</a></span></li>
<li><span class="link-container"><a class="reference external" href="#range-multirangepostgresql">新的RANGE/MULTIRANGE支持和PostgreSQL后端的更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="#postgresql-match-plainto-tsquery-to-tsquery">PostgreSQL上的``match()``操作符使用``plainto_tsquery()``而不是``to_tsquery()``</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="changelog_20.html">2.0 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_14.html">1.4 版本更新历史</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9版本更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">版本记录</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_14.html">SQLAlchemy 1.4有哪些新内容？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">SQLAlchemy 1.3有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">SQLAlchemy 1.2有哪些新特性?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_11.html">SQLAlchemy 1.1新功能</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_10.html">SQLAlchemy 1.0有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_09.html">SQLAlchemy 0.9 的新特性</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_08.html">SQLAlchemy 0.8有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">SQLAlchemy 0.7有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">SQLAlchemy 0.6 有哪些新变化?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">SQLAlchemy 0.5有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id1">主要文档更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id6">退化源</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id7">需求更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id8">ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id21">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id22">模式/类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id23">连接池不再默认为线程本地</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#args-args">*args已接受，不再接受*args</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id44">删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id77">已重命名或已移动</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id86">已弃用</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">SQLAlchemy 0.4有什么新功能？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id1">首先要做什么</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id2">模块导入</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id3">对象关系映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id22">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id26">架构和反射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id28">SQL执行</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="migration_20.html" title="previous chapter">SQLAlchemy 2.0 - 主要迁移指南</a></li>
                <li><b>Next:</b>
                <a href="changelog_20.html" title="next chapter">2.0 变更日志</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="变更和迁移">变更和迁移</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#sqlalchemy-2-0">SQLAlchemy 2.0 有什么新特性？</a><ul>
<li><a class="reference internal" href="#orm">核心和 ORM 中的新类型支持 - 不再使用存根 / 扩展</a><ul>
<li><a class="reference internal" href="#sql">SQL 表达式 / 语句 / 结果集类型</a><ul>
<li><a class="reference internal" href="#id1">工作原理和概述</a></li>
<li><a class="reference internal" href="#whatsnew-20-expression-typing-examples">SQL 表达式类型化 - 示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm-declarative-models">ORM Declarative Models</a><ul>
<li><a class="reference internal" href="#id3">概述</a></li>
<li><a class="reference internal" href="#whatsnew-20-orm-typing-migration">迁移现有的 ORM 映射</a><ul>
<li><a class="reference internal" href="#orm-declarative-base-orm-declarativebase">步骤一 - <code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.declarative_base()</span></code> 被 <code class="xref py py-class docutils literal notranslate"><span class="pre">_orm.DeclarativeBase</span></code> 取代。</a></li>
<li><a class="reference internal" href="#orm-mapped-column-declarative-schema-column">步骤二 - 使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.mapped_column()</span></code> 替换 Declarative 使用的 <code class="xref py py-class docutils literal notranslate"><span class="pre">_schema.Column</span></code></a></li>
<li><a class="reference internal" href="#python-orm-mapped">步骤三 - 根据需要应用确切的 Python 类型，使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">_orm.Mapped</span></code>。</a></li>
<li><a class="reference internal" href="#orm-mapped-column">步骤四 - 移除 <code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.mapped_column()</span></code> 的指令了</a></li>
<li><a class="reference internal" href="#pep-593-annotated">步骤五 - 使用 pep-593 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 将常用的指令打包到类型中</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#whatsnew-20-migration">迁移指南</a><ul>
<li><a class="reference internal" href="#orm-dataclasses">原生支持作为 ORM 模型封装的 dataclasses</a></li>
<li><a class="reference internal" href="#python3-7">Python3.7 /类型批注动态关系支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-517">安装现在完全支持pep-517</a></li>
<li><a class="reference internal" href="#ccython">C扩展现已移植到Cython</a></li>
<li><a class="reference internal" href="#api">数据库反射的主要架构、性能和API增强</a><ul>
<li><a class="reference internal" href="#id23">性能概述</a></li>
<li><a class="reference internal" href="#inspector">``Inspector()``的行为变化</a></li>
<li><a class="reference internal" href="#id30">新方法和Inspector()的改进</a></li>
<li><a class="reference internal" href="#psycopg-3-psycopg">方言支持psycopg 3（也称“psycopg”）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dialect-support-for-oracledb">Dialect support for oracledb</a></li>
<li><a class="reference internal" href="#ddl">新的约束和索引条件DDL</a></li>
<li><a class="reference internal" href="#date-time-datetime">DATE，TIME，DATETIME数据类型现在在所有后端都支持文本呈现</a></li>
<li><a class="reference internal" href="#result-asyncresult"><code class="docutils literal notranslate"><span class="pre">Result</span></code>, ``AsyncResult``现在支持上下文管理器</a></li>
<li><a class="reference internal" href="#id65">行为变化</a><ul>
<li><a class="reference internal" href="#session">新的事务加入模式 <code class="docutils literal notranslate"><span class="pre">Session</span></code></a></li>
<li><a class="reference internal" href="#str-engine-url"><code class="docutils literal notranslate"><span class="pre">str(engine.url)</span></code> 默认情况下会隐藏密码</a></li>
<li><a class="reference internal" href="#table">以相同名称、键的列替换Table对象严格规则</a></li>
<li><a class="reference internal" href="#orm-sort-order">ORM映射的列顺序有所不同;使用``sort_order``控制行为</a></li>
<li><a class="reference internal" href="#sequence-sql-server">``Sequence``构造现在默认不具有任何显式的默认“开始”值；影响到SQL Server</a></li>
<li><a class="reference internal" href="#with-variant-typeengine">``with_variant()``方法克隆原始的TypeEngine而不是更改类型</a></li>
<li><a class="reference internal" href="#python">Python除法操作符在所有后端上执行真除法；增加整数除法</a></li>
<li><a class="reference internal" href="#change-7433">Session提示检测到非法并发或可重入访问时引发</a></li>
<li><a class="reference internal" href="#sqlitequeuepool">SQLite方言对基于文件的数据库使用QueuePool</a></li>
<li><a class="reference internal" href="#oracle-float">新的带二进制精度的Oracle FLOAT类型；不直接接受十进制精度</a></li>
<li><a class="reference internal" href="#range-multirangepostgresql">新的RANGE/MULTIRANGE支持和PostgreSQL后端的更改</a></li>
<li><a class="reference internal" href="#postgresql-match-plainto-tsquery-to-tsquery">PostgreSQL上的``match()``操作符使用``plainto_tsquery()``而不是``to_tsquery()``</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar changelog-whatsnew_20" >
        
<section id="sqlalchemy-2-0">
<span id="whatsnew-20-toplevel"></span><h1>SQLAlchemy 2.0 有什么新特性？<a class="headerlink" href="#sqlalchemy-2-0" title="Permalink to this heading">¶</a></h1>
<div class="admonition- admonition">
<p class="admonition-title">关于此文档</p>
<p>此文档记录了 SQLAlchemy 1.4 版本和 SQLAlchemy 2.0 版本之间的更改，独立于 <a class="reference internal" href="../glossary.html#term-1.x-style"><span class="xref std std-term">1.x style</span></a> 和 <a class="reference internal" href="../glossary.html#term-2.0-style"><span class="xref std std-term">2.0 style</span></a> 用法之间的主要更改。阅读者应始终先从 <a class="reference internal" href="migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - 主要迁移指南</span></a> 文档开始，这篇文档能让你最初了解 1.x 和 2.x 系列之间实现兼容所需的主要兼容更改。</p>
<p>除了 1.x - &gt; 2.x 迁移路径之外，SQLAlchemy 2.0 中最大的范式转变是与 <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 类型有关的深度集成, 特别是在 ORM 中。灵感源自 Python <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a> 的新类型驱动的 ORM 声明样式，以及与 <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a> 本身的新集成，这些都是一种最终不再需要存根(Stubs)且从 SQL 语句到结果集提供类型感知方法链的方法。</p>
<p>Python 开发人员对类型感知的重视程度已经越来越高，这不仅是为了让类型检查器像 <a class="reference external" href="https://mypy.readthedocs.io/en/stable/">mypy</a> 这样的运行无插件，更重要的是它使得 IDEs 像 <a class="reference external" href="https://code.visualstudio.com/">vscode</a> 和 pycharm _ 更加积极地协助开发者组合 SQLAlchemy 应用程序。</p>
</div>
<div class="admonition- admonition">
<p class="admonition-title">阅读者须知</p>
<p>SQLAlchemy 2.0 的迁移文档分为 <strong>两个</strong> 文档 - 一个文档详细说明从 1.x 到 2.x 系列的 API 显著更改，另一个文档详细说明了相对于 SQLAlchemy 1.4 的新功能和行为:</p>
<ul class="simple">
<li><p><a class="reference internal" href="migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - 主要迁移指南</span></a> - 1.x 到 2.x API 变化</p></li>
<li><p><a class="reference internal" href="#"><span class="std std-ref">SQLAlchemy 2.0 有什么新特性？</span></a> - 此文档, SQLAlchemy 2.0 的新功能和行为</p></li>
</ul>
<p>如果阅读者尚未将他们的 1.4 应用程序更新为遵循 SQLAlchemy 2.0 引擎和 ORM 惯例，则可以导航到 <a class="reference internal" href="migration_20.html"><span class="std std-ref">SQLAlchemy 2.0 - 主要迁移指南</span></a>，了解如何确保 SQLAlchemy 2.0 兼容性，这是版本 2.0 下运行代码的先决条件。</p>
</div>
<section id="orm">
<h2>核心和 ORM 中的新类型支持 - 不再使用存根 / 扩展<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h2>
<p>与版本 1.4 通过 <a class="reference external" href="https://github.com/sqlalchemy/sqlalchemy2-stubs">sqlalchemy2-stubs</a> 包提供的中间方法相比，SQLAlchemy 的类型方法在 Core 和 ORM 中的应用已彻底被重新设计。这种全新的方法从最基本的元素开始，即: class:<cite>_schema.Column</cite>，或者更准确地说：用于处理所有具有类型的 SQL 表达式的 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a>。这种表达级别的类型然后延伸到构建语句、执行语句和结果集的领域，最终到 ORM 的领域，其中新的 <a class="reference internal" href="../orm/declarative_config.html"><span class="std std-ref">declarative</span></a> 表单允许用于完全类型化的 ORM 模型，其从语句到结果集集成。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>类型支持应被视为**Beta Level**软件，但类型详细信息可能会发生变化，但不计划进行重大的不向后兼容的更改。</p>
</div>
<section id="sql">
<h3>SQL 表达式 / 语句 / 结果集类型<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h3>
<p>本节提供了 SQLAlchemy 新的 SQL 表达式类型化方法的背景和示例，该方法从基本的 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> 构造物开始，并贯穿整个 SQL 语句和结果集的领域，最终进入 ORM 映射的领域。</p>
<section id="id1">
<h4>工作原理和概述<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h4>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>本节进行了架构讨论。如果你想要快速了解新的类型化看法，可跳到 <a class="reference internal" href="#whatsnew-20-expression-typing-examples"><span class="std std-ref">SQL 表达式类型化 - 示例</span></a>。</p>
</div>
<p>在 <a class="reference external" href="https://github.com/sqlalchemy/sqlalchemy2-stubs">sqlalchemy2-stubs</a> 中，SQL 表达式被作为常规数据类型编写，并引用它们的 <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 对象，如 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>，<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">String`（例如</span> <span class="pre">'Column</span> <span class="pre">[Integer]'）作为它们的泛型实参。这本身就是与原始</span> <span class="pre">Dropbox</span> <span class="pre">sqlalchemy-stubs_</span> <span class="pre">包有所分歧之处，后者将</span> <span class="pre">:class:</span></code>.Column` 和其基本构造物直接作为 Python 类型的泛型，例如 ‘int’，’datetime’ 和 ‘str’。人们希望由于 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> / <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> / <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> 本身是相对于 <cite>int</cite> / <cite>datetime</cite> / <cite>str</cite> 泛型的，因此将有方法来维护两级信息，并且通过 <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 作为中间构造物从列表达式中提取 Python 类型。然而在大多数情况下这是不可能的，因为 <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 不具备足够丰富的功能（缺乏重要功能，例如用于更高阶的 TypeVars ），因此这种方法不再可行。</p>
<p>因此，在对 <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> 的现有功能进行认真评估之后，SQLAlchemy 2.0 认识到了 <a class="reference external" href="https://github.com/dropbox/sqlalchemy-stubs">sqlalchemy-stubs</a> 在这个领域的原始智慧，并直接链接列表达式到 Python 类型，这意味着，如果一个 SQL 表达式被不同于常规数据类型的任何子类型（如 ‘Column (VARCHAR)’ vs ‘Column (Unicode)’），那么它们的 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> 子类型的具体特定内容将不会被保留为 Python 数据，但在实践中，这通常不是问题，并且如果 Python 类型直接存在，一般情况下这会更有用。</p>
<p>具体地说，这意味着像“Column（’id’，Integer）”这样的表达式的类型定义为“Column [int]”。这可以使得从 SQLAlchemy 构件到 Python 数据类型的可行的管道被设置起来，而无需使用类型插件。重要的是，它允许完全的互操作性，即 ORM 将使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 包含用户映射实例，例如我们教程中使用的”User” 和”Address”示例）。虽然 Python 类型目前对元组类型（其中 <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a>, 第一蒟蒻尝试处理类似元组的对象的pep，被故意限制了其功能并因自身还不适用于任意元组操作而被限制到仅使用针对某些具有 **args 和 keyword 限制的原始函数的hack来工作）支持非常有限（ <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>），但已制定了一个相当不错的方法，使得基本 <code class="xref py py-func docutils literal notranslate"><span class="pre">Result`()</span></code>–&gt;:class:<cite>_engine.Row</cite> 的类型化方法链能够正常工作，包括 ORM 类，其中在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 对象被取消包装为单个列条目的点上，加入了一个小型与类型有关的访问器，它允许每个 Python 值维护与其源SQLExpresssion链接的特定 Python 类型（翻译：它有效）。</p>
</section>
<section id="whatsnew-20-expression-typing-examples">
<span id="id2"></span><h4>SQL 表达式类型化 - 示例<a class="headerlink" href="#whatsnew-20-expression-typing-examples" title="Permalink to this heading">¶</a></h4>
<p>快速浏览下 SQLAlchemy 的新类型行为。在下面的示例中，注释：指示了你在 <a class="reference external" href="https://code.visualstudio.com/">vscode</a> (或在使用 <a class="reference external" href="https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type">reveal_type()</a> 功能使用类型检查工具时会看到什么信息：</p>
<ul>
<li><p>将 Python 简单数据类型分配给 SQL 表达式</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># (variable) str_col: ColumnClause[str]</span>
<span class="n">str_col</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>

<span class="c1"># (variable) int_col: ColumnClause[int]</span>
<span class="n">int_col</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>

<span class="c1"># (variable) expr1: ColumnElement[str]</span>
<span class="n">expr1</span> <span class="o">=</span> <span class="n">str_col</span> <span class="o">+</span> <span class="s2">&quot;x&quot;</span>

<span class="c1"># (variable) expr2: ColumnElement[int]</span>
<span class="n">expr2</span> <span class="o">=</span> <span class="n">int_col</span> <span class="o">+</span> <span class="mi">10</span>

<span class="c1"># (variable) expr3: ColumnElement[bool]</span>
<span class="n">expr3</span> <span class="o">=</span> <span class="n">int_col</span> <span class="o">==</span> <span class="mi">15</span></pre></div>
</div>
</li>
<li><p>将单个 SQL 表达式分配到 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造，以及任何返回行的构造，包括返回行 DML，例如带有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">returning</span> <span class="pre">`</span> <span class="pre">的</span> <span class="pre">:class:`_sql.Insert()</span></code>，将被打包到一个 <code class="docutils literal notranslate"><span class="pre">Tuple[]</span></code> 类型中，该类型保留每个元素的 Python 类型。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># (variable) stmt: Select[Tuple[str, int]]</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">str_col</span><span class="p">,</span> <span class="n">int_col</span><span class="p">)</span>

<span class="c1"># (variable) stmt: ReturningInsert[Tuple[str, int]]</span>
<span class="n">ins_stmt</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">returning</span><span class="p">(</span><span class="n">str_col</span><span class="p">,</span> <span class="n">int_col</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p>来自任何返回行的构造的 <code class="docutils literal notranslate"><span class="pre">Tuple[]</span></code> 类型，当使用 <code class="docutils literal notranslate"><span class="pre">.execute()</span></code> 方法调用它时，将通过 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 传递。为了将 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 对象解包为元组，必须使使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Row.tuple()</span></code> 或 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Row.t</span></code> 访问器，本质上将 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 强制转换为相应的 <code class="docutils literal notranslate"><span class="pre">Tuple[]</span></code> (但在运行时仍保持相同的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 对象)。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="c1"># (variable) stmt: Select[Tuple[str, int]]</span>
    <span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">str_col</span><span class="p">,</span> <span class="n">int_col</span><span class="p">)</span>

    <span class="c1"># (variable) result: Result[Tuple[str, int]]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

    <span class="c1"># (variable) row: Row[Tuple[str, int]] | None</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># for typed tuple unpacking or indexed access,</span>
        <span class="c1"># use row.tuple() or row.t  (this is the small typing-oriented accessor)</span>
        <span class="n">strval</span><span class="p">,</span> <span class="n">intval</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">t</span>

        <span class="c1"># (variable) strval: str</span>
        <span class="n">strval</span>

        <span class="c1"># (variable) intval: int</span>
        <span class="n">intval</span></pre></div>
</div>
</li>
<li><p>单列语句的标量值使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.scalar()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.scalars()</span></code> 等方法时，会产生正确的值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># (variable) data: Sequence[str]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">str_col</span><span class="p">))</span><span class="o">.</span><span class="n">scalars</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
</li>
<li><p>对于 ORM 映射类，按预期工作。</p>
<p>典型用法是按 ORM 映射类选择纯粹的查询：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># (variable) users1: Sequence[User]</span>
<span class="n">users1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># (variable) user: User</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

<span class="c1"># (variable) user_iter: Iterator[User]</span>
<span class="n">user_iter</span> <span class="o">=</span> <span class="n">iter</span><span class="p">(</span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)))</span></pre></div>
</div>
<ul>
<li><p><a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 的独特功能被扩展：它在返回值级别上保留类型化，并允许数据类型作为元组或单值的类型。</p>
<blockquote>
<div><p># (variable) q1: RowReturningQuery[Tuple[int, str]]
q1 = session.query(User.id, User.name)</p>
<p># (variable) rows : List[Row[Tuple[int, str]]]
rows = q1.all()</p>
<p># (variable) q2: Query[User]
q2 = session.query(User)</p>
<p># (variable) users: List[User]
users = q2.all()</p>
</div></blockquote>
</li>
</ul>
</li>
<li><p>核心 Table 尚未找到有效的方法在访问 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.c" title="sqlalchemy.schema.Table.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.c</span></code></a> 时维护 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象的类型。</p>
<p>由于 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 被设置为类的实例，并且 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.c" title="sqlalchemy.schema.Table.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.c</span></code></a> 访问器通常按名称动态访问 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象，因此当前还没有为此方法确定类型的成熟方法，因此需要其他的语法。</p>
</li>
<li><p>ORM 类，标量等功能运行良好。</p>
<p>具有典型用法，如按需选择 ORM 类，标量值或元组的用例，2.x 和 1.x 样式的查询，以不管是“单个值”还是包含在适当的容器中，如 <code class="docutils literal notranslate"><span class="pre">Sequence[]</span></code>，<code class="docutils literal notranslate"><span class="pre">List[]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Iterator[]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># (variable) u1: Type[User]</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="c1"># (variable) stmt: Select[Tuple[User, User, str]]</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># (variable) result: Result[Tuple[User, User, str]]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="c1"># (variable) user_obj: User</span>
<span class="c1"># (variable) address_obj: Address</span>
<span class="n">user_obj</span><span class="p">,</span> <span class="n">address_obj</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">t</span></pre></div>
</div>
</li>
</ul>
<p>其中选择映射类的构造，例如:class:<cite>_orm.aliased</cite>, 与原始映射类的列级属性以及期望的语句返回类型一样有效。</p>
<div class="admonition- admonition">
<p class="admonition-title">注意事项 - 必须卸载所有存根</p>
<p>使用类型支持的一个关键限制是**必须卸载所有 SQLAlchemy stubs packages**，以使类型支持能够正常工作。当使用 <a class="reference external" href="https://mypy.readthedocs.io/en/stable/">mypy</a> 对 Python 虚拟环境运行时，这仅仅是卸载这些包。但是，当前版本的 <a class="reference external" href="https://github.com/python/typeshed">typeshed</a> 包中包含了 SQLAlchemy 的存根包，因此它本身被捆绑到某些类型检查工具中，例如 <a class="reference external" href="https://github.com/microsoft/pylance-release">Pylance</a>，因此在某些情况下，如果它们确实妨碍了新的打字支持正常工作，就必须定位这些包的文件并将其删除。</p>
<p>一旦 SQLAlchemy 2.0 发布为最终状态，typeshed 将从其自己的 stubs 源中删除 SQLAlchemy。</p>
</div>
</section>
</section>
<section id="orm-declarative-models">
<span id="whatsnew-20-orm-declarative-typing"></span><h3>ORM Declarative Models<a class="headerlink" href="#orm-declarative-models" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 1.4 引入了使用 <a class="reference external" href="https://github.com/sqlalchemy/sqlalchemy2-stubs">sqlalchemy2-stubs</a> 和 <a class="reference internal" href="../orm/extensions/mypy.html"><span class="std std-ref">Mypy Plugin</span></a> 的第一个 SQLAlchemy-native ORM 类型支持。在 SQLAlchemy 2.0 中，Mypy 插件**仍然可用，并已更新以使用 SQLAlchemy 2.0 的类型系统**，但现在应被认为是**已弃用的**，因为应用程序现在有一个简单的路径可用于采用新的类型支持，该路径不使用插件或存根。</p>
<section id="id3">
<h4>概述<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h4>
<p>新系统的基本方法是：当使用完全 <span class="xref std std-ref">Declarative</span> 模型(即，不是 <span class="xref std std-ref">hybrid declarative</span> 或 <a class="reference internal" href="../orm/mapping_styles.html#orm-imperative-mapping"><span class="std std-ref">imperative</span></a> 配置，这些配置的更改是无效的) 时，已映射列声明，首先通过检查每个属性声明左侧的类型注释来在运行时派生。如果注释存在，则左手注释可以在 :func: <cite>_orm.mapped_column</cite> 上参考右手端上的 :class: <cite>_schema.Column</cite>，后者用于提供关于将要生成并映射的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 的 Core 级架构信息。如果左侧没有注释，则可以使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 作为 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 指令的确切替代项，即不是在左侧存在注释的情况下。</p>
<p>这种方法的灵感源自 Python <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a> 方法，它从左侧注释开始，然后允许在右侧使用可选的``dataclasses.field()`` 规范；与 <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a> 方法的主要区别在于 SQLAlchemy 的方法是**严格选择性**的，其中没有类型注释的已存在映射，可以像以前一样工作， :func: <cite>_orm.mapped_column</cite> 可以作为 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 指令的直接替换品，即使左侧没有明确的注释。</p>
<p>在需要存在实际属性级Python类型的情况下，“_orm.Mapped” 注释必须显式地用于每个属性上，这些属性在 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 在没有显式注释的情况下将会被定义为“Any” 。</p>
</section>
<section id="whatsnew-20-orm-typing-migration">
<span id="id4"></span><h4>迁移现有的 ORM 映射<a class="headerlink" href="#whatsnew-20-orm-typing-migration" title="Permalink to this heading">¶</a></h4>
<p>过渡到新的 ORM 方法开始更加冗长，但随着使用的新功能越来越多，它会变得更加简洁，以下步骤详细说明了典型过渡，然后继续演示了一些更多的选项。</p>
<section id="orm-declarative-base-orm-declarativebase">
<h5>步骤一 - <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code> 被 <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code> 取代。<a class="headerlink" href="#orm-declarative-base-orm-declarativebase" title="Permalink to this heading">¶</a></h5>
<p>观察到的 Python 打字的一个限制是似乎不存在一种方法来从函数中动态生成一个类，然后再将其作为新类的基类，类型检查工具可以理解这些信息。为了解决这个问题，可以使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code> 类替换通常的 <code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code> 调用，这将产生与以前相同的“Base”对象，但类型检查工具可以理解它：</p>
<blockquote>
<div><p>from sqlalchemy.orm import DeclarativeBase</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="orm-mapped-column-declarative-schema-column">
<h5>步骤二 - 使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 替换 Declarative 使用的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a><a class="headerlink" href="#orm-mapped-column-declarative-schema-column" title="Permalink to this heading">¶</a></h5>
<p>在使用 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 的 ORM 类型中，可以直接使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>，它是 ORM 感知的构造，可以直接替换 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 的使用。考虑以下 1.x 的映射：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email_address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user_account.id&quot;</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;User&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</div></blockquote>
<p>将 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 替换为 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>，不需要更改任何参数：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email_address</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user_account.id&quot;</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;User&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</div></blockquote>
<p>上面的各列**尚未具有 Python 类型**，并且在实例级别上将被定义为“Mapped [Any]”；这是因为我们可以将任何列声明声明为可选或不可选，因此没有必要进行“猜测”，以免在明确定义类型的情况下进行类型错误。但在此步骤中，我们上面的映射已经为每个属性设置了适当的 <span class="xref std std-term">descriptor</span> 类型，可以在查询中使用，也可以用于实例级替换，所有这些都将在没有插件的情况下通过 mypy - strict 模式。</p>
</section>
<section id="python-orm-mapped">
<h5>步骤三 - 根据需要应用确切的 Python 类型，使用 <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>。<a class="headerlink" href="#python-orm-mapped" title="Permalink to this heading">¶</a></h5>
<p>这可以针对需要确切类型的所有属性完成；可以跳过可以被视为“Any”的属性。例如，为了提供 ORM 恒定类型，详细说明 <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 被使用的关于 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fullname</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email_address</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user_account.id&quot;</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
</div></blockquote>
<p>此时，我们的 ORM 映射已完全具有类型，并将生成精确类型化的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>、<a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code> 构造。现在，我们可以开始简化映射声明中的冗余。</p>
</section>
<section id="orm-mapped-column">
<h5>步骤四 - 移除 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的指令了<a class="headerlink" href="#orm-mapped-column" title="Permalink to this heading">¶</a></h5>
<p>所有“可选”参数都可以使用 <code class="docutils literal notranslate"><span class="pre">Optional[]</span></code> 隐含，如果没有 <code class="docutils literal notranslate"><span class="pre">Optional[]</span></code>，则 <code class="docutils literal notranslate"><span class="pre">nullable</span></code> 默认为“False”。所有 SQL 类型缺少参数，如 <code class="docutils literal notranslate"><span class="pre">Integer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">String</span></code> 只能作为 Python 注释表达。没有参数的 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 指令可以完全删除。<code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 现在将其类从左侧的注释中推导出来，支持用于字符串的”前向引用”(已经支持10年了；))。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">fullname</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">str</span><span class="p">]]</span>
    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email_address</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>
    <span class="n">user_id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user_account.id&quot;</span><span class="p">))</span>
    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
</div></blockquote>
</section>
<section id="pep-593-annotated">
<h5>步骤五 - 使用 pep-593 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 将常用的指令打包到类型中<a class="headerlink" href="#pep-593-annotated" title="Permalink to this heading">¶</a></h5>
<p>这是一个全新的功能，是作为一种提供面向类型的配置的替代或补充方法，并取代了一般的 <span class="xref std std-ref">declarative mixins</span>。Declarative 映射允许自定义 SQL 类型与 Python 类型之间的映射，例如“str”到 <code class="docutils literal notranslate"><span class="pre">String</span></code> 类型，使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code>。使用 <a href="#id5"><span class="problematic" id="id6">:pep:`593``Annotated``</span></a> 允许我们创建特定 Python 类型的变体，以便可以使用相同的类型，例如 <code class="docutils literal notranslate"><span class="pre">str</span></code>，每个提供 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> 的变体。使用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 的特定示例是，使用 :func: <cite>_orm.mapped_column</cite> 在注释左侧中传递 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 构造(使用者 credit to &#64;adriangb01 &lt;<a class="reference external" href="https://twitter.com/adriangb01/status/1532841383647657988">https://twitter.com/adriangb01/status/1532841383647657988</a>&gt; 为这个想法进行说明) 。</p>
<p>此功能在将来的发布版本中可以进一步扩展，以包括 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>, <a class="reference internal" href="../orm/composites.html#sqlalchemy.orm.composite" title="sqlalchemy.orm.composite"><code class="xref py py-func docutils literal notranslate"><span class="pre">composite()</span></code></a> 和其他构造，但当前仅限于 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code>。下面的示例除了我们的”str50”示例之外，还添加了其他 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型，以说明此功能：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>

<span class="n">str50</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">str</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>


<span class="c1"># 使用类型级别覆盖的 declarative 基础，使用一个预期在多个地方使用的类型</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="n">type_annotation_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">str50</span><span class="p">:</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
    <span class="p">}</span></pre><div class="code-annotations-key"></div></div>
</div>
</div></blockquote>
<p>在左手类型使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 时，Declarative 将从左侧类型提取完整的 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 定义，如果使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 构造作为 <code class="docutils literal notranslate"><span class="pre">Annotated[]</span></code> 的任何一个参数在左侧使用，即可实现此功能。目前此功能被限制为 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 的使用。下面的示例添加了其他 Annotated 类型以说明此功能：</p>
<blockquote>
<div><p>from typing_extensions import Annotated
from typing import List
from typing import Optional</p>
<dl class="simple">
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
</dl>
<p>str50 = Annotated[str, 50]
Email = Annotated[str, 50]
OptionalString = Annotated[Optional[str], False]</p>
<dl>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user_account”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
name: Mapped[str] = mapped_column(String(30))
fullname: Mapped[OptionalString]
addresses: Mapped[List[“Address”]] = relationship(back_populates=”user”)
email: Mapped[Email]</p>
</dd>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”</p>
<p>id: Mapped[int] = mapped_column(primary_key=True)
email_address: Mapped[str]
user_id: Mapped[int] = mapped_column(ForeignKey(“user_account.id”))
user: Mapped[User] = relationship(back_populates=”addresses”)</p>
</dd>
</dl>
</div></blockquote>
<p>同时使用``Annotated``和``type_annotation_map``的示例:</p>
<blockquote>
<div><p>from typing_extensions import Annotated
from typing import List, Optional, Type
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import mapped_column, relationship</p>
<p>str50 = Annotated[str, 50]</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><dl class="simple">
<dt>type_annotation_map = {</dt><dd><p>str50: String(50),</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>class User(Base):</dt><dd><p>__tablename__ = “users”</p>
<p># The Mapped[…] annotations describe the types at the Python level,
# absent the type_annotation_map dictionary which is used for leading the
# ORM to the correct types.
id: Mapped[int] = mapped_column(Integer, primary_key=True)
name: Mapped[str] = mapped_column(<a href="#id193"><span class="problematic" id="id194">str_</span></a>)
age: Mapped[Optional[int]] = mapped_column(Integer)</p>
<p># The List[Address] maps to Address.user, which is of type Mapped[User],
# where Mapped[User] maps to the class itself.
addresses: Mapped[List[“Address”]] = relationship(“Address”, back_populates=”user”)</p>
</dd>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “addresses”</p>
<p>id: Mapped[int] = mapped_column(Integer, primary_key=True)
email: Mapped[str] = mapped_column(<a href="#id195"><span class="problematic" id="id196">str_</span></a>)
user_id: Mapped[int] = mapped_column(ForeignKey(User.id))
user: <a href="#id197"><span class="problematic" id="id198">User.addresses.property.mapper.class_</span></a> = relationship(User, back_populates=”addresses”)</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>
</section>
</section>
<section id="whatsnew-20-migration">
<span id="id7"></span><h2>迁移指南<a class="headerlink" href="#whatsnew-20-migration" title="Permalink to this heading">¶</a></h2>
<p>### SQLExpression 升级</p>
<p>类型支持的要点是：</p>
<ol class="arabic simple">
<li><p>所有映射类中 <cite>Column</cite>，<cite>relationship</cite> 和 <cite>mapped_column</cite> 都应该用类型化建模。</p></li>
<li><p>ORM classes 根据 Python 类型进行建模，因此应该使用 <cite>Mapped</cite> 泛型。</p></li>
<li><p><cite>column</cite> 作为直接函数调用仍然支持。这意味着您不必修改查询构造，但如果想增加类型信息，则需要通过 <cite>type annotations</cite> 实现。</p></li>
</ol>
<p>&lt;br/&gt;</p>
<dl>
<dt>提请 Buildstream 维护者留意此次更改后 Buildstream 中的 SQLAlchemy 版本。    from sqlalchemy import ForeignKey</dt><dd><p>from sqlalchemy import String
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship</p>
<p># declarative base from previous example
str50 = Annotated[str, 50]</p>
<p># 基础类, 包含了一系列特定字段的注释.
class Base(DeclarativeBase):</p>
<blockquote>
<div><dl class="simple">
<dt>type_annotation_map = {</dt><dd><p>str50: String(50),</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p># 为 mapped_column() 方法进行重载, 使用常规的基础列风格, 所以要使用多个地方的格式.
intpk = Annotated[int, mapped_column(primary_key=True)]
user_fk = Annotated[int, mapped_column(ForeignKey(“user_account.id”))]</p>
<p># 描述用户模型的信息.
class User(Base):</p>
<blockquote>
<div><p>__tablename__ = “user_account”</p>
<p>id: Mapped[intpk]
name: Mapped[str50]
fullname: Mapped[Optional[str]]
addresses: Mapped[List[“Address”]] = relationship(back_populates=”user”)</p>
</div></blockquote>
<p># 描述地址模型的信息.
class Address(Base):</p>
<blockquote>
<div><p>__tablename__ = “address”</p>
<p>id: Mapped[intpk]
email_address: Mapped[str50]
user_id: Mapped[user_fk]
user: Mapped[“User”] = relationship(back_populates=”addresses”)</p>
</div></blockquote>
</dd>
</dl>
<p>上面的代码展示了用 <code class="docutils literal notranslate"><span class="pre">Mapped[str50]</span></code>, <code class="docutils literal notranslate"><span class="pre">Mapped[intpk]</span></code>
或者是 <code class="docutils literal notranslate"><span class="pre">Mapped[user_fk]</span></code> 创建的列是如何从
<code class="xref py py-paramref docutils literal notranslate"><span class="pre">registry.type_annotation_map</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 构建中构建出来的，这样就可以重用预先建立的映射和列配置了。</p>
<p>我们可以将映射类转换成 <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a>, 这样
一个重要的优势之一就是我们可以构建一个严格强类型的 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 方法，
其中包括了显式位置参数，使用关键字参数以及默认参数，更不必说我们还可以获得
许多本身就处于 dataclass 中的其他方法如 <code class="docutils literal notranslate"><span class="pre">__str__()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code>
。dataclasses 也提供了序列化方法，例如
<a class="reference external" href="https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict">dataclasses.asdict()</a> 和
<a class="reference external" href="https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple">dataclasses.astuple()</a>,
这些方法对于构建具有双向关系的映射所用，并不是特别适用。Python 类目前无法支持循环引用的解决方案。下一个章节 <a class="reference internal" href="#whatsnew-20-dataclasses"><span class="std std-ref">原生支持作为 ORM 模型封装的 dataclasses</span></a> 更详细地阐述了修改示例模型。</p>
<p>在上述示例中，从第三步开始的任何示例都将包含模型属性，并且将填充到:func:<cite>_sql.select</cite>, <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>, 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> 对象中:：</p>
<blockquote>
<div><p># (variable) stmt: Select[Tuple[int, str]]
stmt = select(User.id, User.name)</p>
<dl>
<dt>with Session(e) as sess:</dt><dd><dl class="simple">
<dt>for row in sess.execute(stmt):</dt><dd><p># (variable) row: Row[Tuple[int, str]]
print(row)</p>
</dd>
</dl>
<p># (variable) users: Sequence[User]
users = sess.scalars(select(User)).all()</p>
<p># (variable) users_legacy: List[User]
users_legacy = sess.query(User).all()</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">orm_declarative_table</span> - Declarative generation and mapping of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> columns.</p>
</div>
<p id="whatsnew-20-mypy-legacy-models">使用</p>
<hr class="docutils" />
<p>使用</p>
<p>。。。</p>
<section id="orm-dataclasses">
<span id="whatsnew-20-dataclasses"></span><h3>原生支持作为 ORM 模型封装的 dataclasses<a class="headerlink" href="#orm-dataclasses" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 1.4 引入了新特性，此特性将 <span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> 中的 “Annotated” 与基础列结合使用，可以用来通过类型注解创建映射。我们可以进一步将映射转换为 <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a>，其中一个重要优势是，我们可以构建一个严格强类型的 <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 方法，其中包括了显式位置参数，使用关键字参数以及默认参数，不必记住</p>
<p>我们还可以获得 dataclass 内置的方法，例如 <code class="docutils literal notranslate"><span class="pre">__str__()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code>。</p>
<p>dataclass 序列化方法，例如`dataclasses.asdict() &lt;<a class="reference external" href="https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict">https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict</a>&gt;`_ 和 <a class="reference external" href="https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple">dataclasses.astuple()</a>，此方法可以使用，但不能处理自引用结构，因此不适用于具有双向关系的映射。</p>
<p>SQLAlchemy 的当前集成方法将用户定义的类转换为**真实的 dataclass**，以为运行时的操作提供帮助；使用这个特性，实现使用 <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a> 来识别</p>
<p>dataclass 兼容的类，或已通过替代 API 声明的完全 dataclass 的类。提供了这个特性，是因为当前版本允许转换「dataclass」类型使其具备 SQLAlchemy 1.4 中所引入的现有 dataclass 特性，产生等价的运行时映射，并支持一种完全集成的配置样式，比上一个版本更完全地实现了类型。</p>
<p>为了使用 dataclasses 满足 <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>，ORM 构建如 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 在其注释中接受额外的 <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a> 参数 <code class="docutils literal notranslate"><span class="pre">init</span></code>，<code class="docutils literal notranslate"><span class="pre">default</span></code>，和 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>，这些参数将传递到数据类创建过程中。这些参数当前必须存在于右侧的显式指令中，就像在 <code class="docutils literal notranslate"><span class="pre">dataclasses.field()</span></code> 中使用的方式一样；它们当前不能作为左侧“Annotated”构造中的局部变量。为了支持使用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 的方便性同时又支持数据类配置，<code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 可以将最小化的右侧参数与位于左侧的现有 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 构建中的参数进行合并，以便保持大部分简洁性，这个后面的示例可以看到。</p>
<p>要在继承类中启用数据类，我们使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">MappedAsDataclass</span></code> 混入类，可以直接应用于每个类，也可以应用于“Base”类，如下例所示，我们从 “步骤 5” of <a class="reference internal" href="#whatsnew-20-orm-declarative-typing"><span class="std std-ref">ORM Declarative Models</span></a> 开始修改示例映射：</p>
<blockquote>
<div><p>from typing_extensions import Annotated</p>
<p>from typing import List</p>
<p>from typing import Optional</p>
<p>from sqlalchemy import ForeignKey</p>
<p>from sqlalchemy import String</p>
<p>from sqlalchemy.orm import DeclarativeBase</p>
<p>from sqlalchemy.orm import Mapped</p>
<p>from sqlalchemy.orm import MappedAsDataclass</p>
<p>from sqlalchemy.orm import mapped_column</p>
<p>from sqlalchemy.orm import relationship</p>
<p>class Base(MappedAsDataclass, DeclarativeBase):</p>
<blockquote>
<div><p>“””子类将被转换为 dataclasses”””</p>
</div></blockquote>
<p>intpk = Annotated[int, mapped_column(primary_key=True)]</p>
<p>str30 = Annotated[str, mapped_column(String(30))]</p>
<p>user_fk = Annotated[int, mapped_column(ForeignKey(“user_account.id”))]</p>
<p>class User(Base):</p>
<blockquote>
<div><p>__tablename__ = “user_account”</p>
<p>id: Mapped[intpk] = mapped_column(init=False)</p>
<p>name: Mapped[str30]</p>
<p>fullname: Mapped[Optional[str]] = mapped_column(default=None)</p>
<p>addresses: Mapped[List[“Address”]] = relationship(</p>
<blockquote>
<div><p>back_populates=”user”, default_factory=list</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>class Address(Base):</p>
<blockquote>
<div><p>__tablename__ = “address”</p>
<p>id: Mapped[intpk] = mapped_column(init=False)</p>
<p>email_address: Mapped[str]</p>
<p>user_id: Mapped[user_fk] = mapped_column(init=False)</p>
<p>user: Mapped[“User”] = relationship(back_populates=”addresses”, default=None)</p>
</div></blockquote>
</div></blockquote>
<p>与前例类似，该映射使用了直接应用 <code class="docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code> 装饰器，同时声明了映射的声明性映射。这个装饰器会自动安装每个 <code class="docutils literal notranslate"><span class="pre">dataclasses.field()</span></code> 指示。 <a href="#id9"><span class="problematic" id="id10">``</span></a>用户’’/<a href="#id11"><span class="problematic" id="id12">``</span></a>地址’’结构可以使用如下配置基于位置参数进行创建：</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s2">&quot;username&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;full name&quot;</span><span class="p">,</span> <span class="n">addresses</span><span class="o">=</span><span class="p">[</span><span class="n">Address</span><span class="p">(</span><span class="s2">&quot;email@address&quot;</span><span class="p">)])</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span></pre></div>
</div>
<p>User(id=None, name=’username’, fullname=’full name’, addresses=[Address(id=None, <a class="reference external" href="mailto:email_address='email&#37;&#52;&#48;address">email_address=’email<span>&#64;</span>address</a>’, user_id=None, user=…)])</p>
</div></blockquote>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteOnlyCollection`还与新的:ref:`ORM批量dml&lt;change_8360&gt;`功能集成，包括批量INSERT、UPDATE/DELETE和WHERE条件，都包括RETURNING支持。请参见完整文档：:ref:`write_only_relationship</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/large_collections.html#write-only-relationship"><span class="std std-ref">只写关系</span></a></p>
</div>
</section>
<section id="python3-7">
<h3>Python3.7 /类型批注动态关系支持<a class="headerlink" href="#python3-7" title="Permalink to this heading">¶</a></h3>
<p>虽然“动态”关系在2.0中是遗留下来的，但是由于这些模式被认为具有长寿命，
因此在“动态”关系中添加了:ref:<cite>类型批注映射&lt;whatsnew_20_orm_declarative_typing&gt;`支持
与新的``lazy=”write_only”`</cite>，使用:class:<cite>_orm.DynamicMapped</cite> 注释：</p>
<blockquote>
<div><p>from sqlalchemy.orm import DynamicMapped</p>
<dl>
<dt>class Base(DeclarativeBase):</dt><dd><p>pass</p>
</dd>
<dt>class Account(Base):</dt><dd><p>__tablename__ = “account”
id: Mapped[int] = mapped_column(primary_key=True)
identifier: Mapped[str]
account_transactions: DynamicMapped[“AccountTransaction”] = relationship(</p>
<blockquote>
<div><p>cascade=”all, delete-orphan”,
passive_deletes=True,
order_by=”AccountTransaction.timestamp”,</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class AccountTransaction(Base):</dt><dd><p>__tablename__ = “account_transaction”
id: Mapped[int] = mapped_column(primary_key=True)
account_id: Mapped[int] = mapped_column(</p>
<blockquote>
<div><p>ForeignKey(“account.id”, ondelete=”cascade”)</p>
</div></blockquote>
<p>)
description: Mapped[str]
amount: Mapped[Decimal]
timestamp: Mapped[datetime] = mapped_column(default=func.now())</p>
</dd>
</dl>
</div></blockquote>
<p>上面的映射提供了一个``Account.account_transactions``集合，该
集合通过类型标记为返回:class:<cite>_orm.AppenderQuery`集合类型，
包括其元素类型，例如``AppenderQuery[AccountTransaction]`</cite>。
这样，迭代和查询将产生打上了``AccountTransaction``类型标记的对象。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/large_collections.html#dynamic-relationship"><span class="std std-ref">动态关系加载器</span></a></p>
</div>
<p><a href="#id13"><span class="problematic" id="id14">:ticket:`7123`</span></a></p>
</section>
</section>
<section id="pep-517">
<span id="change-7311"></span><h2>安装现在完全支持pep-517<a class="headerlink" href="#pep-517" title="Permalink to this heading">¶</a></h2>
<p>源分发现在包含一个``pyproject.toml``文件，允许完全支持:pep:<cite>517</cite>。
特别是，这允许使用``pip``对本地源构建进行自动安装
使用Cython_可选依赖项。</p>
<p><a href="#id15"><span class="problematic" id="id16">:ticket:`7311`</span></a></p>
</section>
<section id="ccython">
<span id="change-7256"></span><h2>C扩展现已移植到Cython<a class="headerlink" href="#ccython" title="Permalink to this heading">¶</a></h2>
<p>SQLAlchemy C扩展现已被全部采用用Cython_编写。虽然在2010年C扩展诞生之初就曾经评估过Cython，但是C扩展的性质和重点现在与当时相比发生了很大变化。与此同时，Cython显然也有了很大的发展，Python编译/分发工具链也有了显著的进步，这使得我们可以重新考虑它的使用。</p>
<p>转换到Cython提供了显着的新优势，但没有明显的劣势：
* 用来替代特定C扩展的Cython扩展的所有基准测试都比SQLAlchemy先前包括的几乎所有C代码**更快**，有时略微，但有时明显。虽然这似乎令人惊讶，但它似乎是Cython实现中的非明显优化的产物，如果是Python到C直接处理函数的直接传输，即包括C扩展中添加的许多自定义集合类型的情况，否则实现中就不存在这些优化，这正如许多C扩展中的情况。
* Cython扩展比原始C代码更容易编写、维护和调试，而且在大多数情况下与Python代码是一一对应的。
* Cython非常成熟和广泛使用，包括作为SQLAlchemy支持的一些知名数据库驱动程序的基础，包括“asyncpg”、“psycopg3”和“asyncmy”。</p>
<p>与前一个C扩展一样，Cython扩展在SQLAlchemy的轮分发中预先构建，可从PyPi的“pip”自动获取。除了Cython要求之外，手动构建说明也没有改变。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../intro.html#c-extensions"><span class="std std-ref">构建Cython扩展</span></a></p>
</div>
<p><a href="#id17"><span class="problematic" id="id18">:ticket:`7256`</span></a></p>
</section>
<section id="api">
<span id="change-4379"></span><h2>数据库反射的主要架构、性能和API增强<a class="headerlink" href="#api" title="Permalink to this heading">¶</a></h2>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Table`对象及其组件反映的内部系统已完全重构，</span>
<span class="pre">允许参与的方言一次性反射数千个表，获得很高的性能。</span>
<span class="pre">目前，**PostgreSQL**和**Oracle**方言参与了新架构，</span>
<span class="pre">其中PostgreSQL方言现在可以几乎三倍快地反射大量的:class:</span></code>.Table`
对象，而Oracle方言现在可以十倍快地反射大量的:class:<cite>.Table</cite>
对象。</p>
<p>重新架构最直接适用于使用SELECT查询对系统目录表进行表反射的方言，
并且剩下的方言可以从此方法中受益。”,
包括”views” 和 “materialized views” 里的处理分离出来了，
因为在现实世界的案例中，这两个构造使用了不同的CREATE和DROP DDL，
这包括现在有单独的:meth:<cite>.Inspector.get_view_names</cite> 和:meth:<a href="#id19"><span class="problematic" id="id20">`</span></a>.Inspector.get_materialized_view_names`方法。</p>
<p>新的API与以前的系统向后兼容，并且不应该要求第三方方言进行任何更改，以保持兼容性。 第三方方言也可以选择加入新系统，通过实现批处理查询以进行模式反射。</p>
<p>随着这种变化，:class:<a href="#id21"><span class="problematic" id="id22">`</span></a>.Inspector`对象的API和行为得到了改进和增强，具有更一致的跨方言行为和更多的方法以及新的性能特性。</p>
<section id="id23">
<h3>性能概述<a class="headerlink" href="#id23" title="Permalink to this heading">¶</a></h3>
<p>源分发包括一个脚本 <code class="docutils literal notranslate"><span class="pre">test/perf/many_table_reflection.py</span></code>，它对新旧反射功能进行基准测试。
一组较老版本的测试可能会在旧版本上运行，这里我们用它来说明在本
篇文档中，我们将``metadata.reflect()``应用于250个:class:<a href="#id24"><span class="problematic" id="id25">`</span></a>.Table`对象时两个SQLA版本之间性能差异的情况：</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Dialect</p></td>
<td><p>Operation</p></td>
<td><p>SQLA 1.4 Time (secs)</p></td>
<td><p>SQLA 2.0 Time (secs)</p></td>
</tr>
<tr class="row-even"><td><p>postgresql+psycopg2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">metadata.reflect()</span></code>, 250 tables</p></td>
<td><p>8.2</p></td>
<td><p>3.3</p></td>
</tr>
<tr class="row-odd"><td><p>oracle+cx_oracle</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">metadata.reflect()</span></code>, 250 tables</p></td>
<td><p>60.4</p></td>
<td><p>6.8</p></td>
</tr>
</tbody>
</table>
</section>
<section id="inspector">
<h3><a href="#id26"><span class="problematic" id="id27">``</span></a>Inspector()``的行为变化<a class="headerlink" href="#inspector" title="Permalink to this heading">¶</a></h3>
<p>针对包含在SQLAlchemy的方言SQLite、PostgreSQL、MySQL/MariaDB、Oracle和SQL Server中的:meth:<cite>.Inspector
.has_table</cite>、<a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence" title="sqlalchemy.engine.reflection.Inspector.has_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.has_sequence()</span></code></a>、<a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index" title="sqlalchemy.engine.reflection.Inspector.has_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.has_index()</span></code></a>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector</span>
<span class="pre">.get_table_names`和:meth:()</span></code>.Inspector.get_sequence_names`现在均具有一致的缓存行为：它们在首次针对特定的:class:<cite>.Inspector`对象调用后，完全缓存它们的结果。当在调用相同的:class:</cite>.Inspector`对象时创建或删除表/序列时，将不会收到更新的状态。当执行DDL更改时应该使用:meth:<cite>.Inspector.clear_cache`或新的:class:</cite>.Inspector`。之前:meth:<cite>.Inspector.has_table</cite>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.has_sequence`方法既未实现缓存，也未对</span>
<span class="pre">:meth:()</span></code>.Inspector.get_table_names`和:meth:<a href="#id28"><span class="problematic" id="id29">`</span></a>.Inspector.get_sequence_names`方法支持缓存，导致两种类型的方法之间结果的不一致。</p>
<p>对于第三方方言，行为取决于它们是否实现了dialect级的“反射缓存”装饰器的方法实现。</p>
</section>
<section id="id30">
<h3>新方法和Inspector()的改进<a class="headerlink" href="#id30" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>添加一个:meth:<cite>.Inspector.has_schema</cite> 方法，返回目标数据库中是否存在模式</p></li>
<li><p>添加一个:meth:<a href="#id31"><span class="problematic" id="id32">`</span></a>.Inspector.has_index`方法，返回表部分是否具有特定的索引。</p></li>
<li><p>如:meth:<a href="#id33"><span class="problematic" id="id34">`</span></a>.Inspector.get_columns`单表操作的检查约束方法，现在治愈了DDL更改时受影响的表或视图不存在的情况。这个变化是特定针对方言的，所以当前第三方方言的处理可能还不一样。</p></li>
<li><p>将处理“视图”和“材质化视图”的方式分离，因为在实际使用中，这两个构造使用CREATE和DROP时使用不同的DDL；这包括现在有单独的:meth:<cite>.Inspector.get_view_names`和:meth:</cite>.Inspector.get_materialized_view_names`方法。</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">:ticket:`4379`</span></a></p>
</section>
<section id="psycopg-3-psycopg">
<span id="ticket-6842"></span><h3>方言支持psycopg 3（也称“psycopg”）<a class="headerlink" href="#psycopg-3-psycopg" title="Permalink to this heading">¶</a></h3>
<p>新增了对`psycopg 3 &lt;<a class="reference external" href="https://pypi.org/project/psycopg/">https://pypi.org/project/psycopg/</a>&gt;`_ DBAPI的方言支持，尽管其编号为“3”，但现在已更名为“psycopg” ，取代了此前的“psycopg2”，对于现在仍然是SQLAlchemy的“默认”驱动程序的“postgresql”方言。 <a href="#id37"><span class="problematic" id="id38">``</span></a>psycopg``是一个针对PostgreSQL的完全重写和现代化的数据库适配器，支持预处理语句以及Python asyncio等概念。</p>
<p><a href="#id39"><span class="problematic" id="id40">``</span></a>psycopg``是SQLAlchemy提供的第一个既提供pep-249同步API，又提供asyncio驱动程序的DBAPI。 <a href="#id41"><span class="problematic" id="id42">``</span></a>psycopg``数据库URL可用于:func:<a href="#id43"><span class="problematic" id="id44">`</span></a>_sa.</p>
<p>create_engine`和:func:<a href="#id45"><span class="problematic" id="id46">`</span></a>_asyncio.create_async_engine`引擎创建函数，并自动选择相应键入的方言或并发dialect。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-psycopg"><span class="std std-ref">psycopg</span></a></p>
</div>
</section>
</section>
<section id="dialect-support-for-oracledb">
<span id="ticket-8054"></span><h2>Dialect support for oracledb<a class="headerlink" href="#dialect-support-for-oracledb" title="Permalink to this heading">¶</a></h2>
<p>新增了针对`oracledb &lt;<a class="reference external" href="https://pypi.org/project/oracledb/">https://pypi.org/project/oracledb/</a>&gt;`_ DBAPI的方言支持，这是流行的cx_Oracle驱动程序的重命名、新的主要发布版本。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">oracledb</span></p>
</div>
</section>
<section id="ddl">
<span id="ticket-7631"></span><h2>新的约束和索引条件DDL<a class="headerlink" href="#ddl" title="Permalink to this heading">¶</a></h2>
<p>新方法:meth:<cite>_schema.Constraint.ddl_if`和:meth:`_schema.Index.ddl_if`允许根据快速查询所接受的条件，对:class:`_schema.CheckConstraint</cite>、:class:<a href="#id47"><span class="problematic" id="id48">`</span></a>_schema.UniqueConstraint`和:class:<a href="#id49"><span class="problematic" id="id50">`</span></a>_schema.Index`等对象进行条件性布局。在下面的示例中，CHECK约束和索引只有在PostgreSQL后端下才会产生：</p>
<blockquote>
<div><p>meta = MetaData()</p>
<dl class="simple">
<dt>my_table = Table(</dt><dd><p>“my_table”,
meta,
Column(“id”, Integer, primary_key=True),
Column(“num”, Integer),
Column(“data”, String),
Index(“my_pg_index”, “data”).ddl_if(dialect=”postgresql”),
CheckConstraint(“num &gt; 5”).ddl_if(dialect=”postgresql”),</p>
</dd>
</dl>
<p>)</p>
<p>e1 = create_engine(“sqlite://”, echo=True)
meta.create_all(e1)  # 将不会生成CHECK和INDEX</p>
<p>e2 = create_engine(“postgresql://scott:tiger&#64;localhost/test”, echo=True)
meta.create_all(e2)  # 将生成CHECK和INDEX</p>
</div></blockquote>
<p>在上述情况下，:class:<a href="#id51"><span class="problematic" id="id52">`</span></a>_orm.Session`根本不应该影响现有的事务状态，应当自己创建保存点(nested transaction)。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">schema_ddl_ddl_if</span></p>
</div>
</section>
<section id="date-time-datetime">
<span id="change-5052"></span><h2>DATE，TIME，DATETIME数据类型现在在所有后端都支持文本呈现<a class="headerlink" href="#date-time-datetime" title="Permalink to this heading">¶</a></h2>
<p>现在，使用后端特定编译，包括PostgreSQL和Oracle，实现了日期和时间类型的文字呈现：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">DATETIME</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">literal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">oracle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">date_literal</span> <span class="o">=</span> <span class="n">literal</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="n">DATETIME</span><span class="p">)</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">date_literal</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">(),</span> <span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;literal_binds&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}&#39;2022-12-17 11:02:13.575789&#39;{stop}</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">date_literal</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">dialect</span><span class="o">=</span><span class="n">oracle</span><span class="o">.</span><span class="n">dialect</span><span class="p">(),</span> <span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;literal_binds&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}TO_TIMESTAMP(&#39;2022-12-17 11:02:13.575789&#39;, &#39;YYYY-MM-DD HH24:MI:SS.FF&#39;){stop}</span></pre></div>
</div>
<p>以前，当使用与dialect特定类型无关的字符串调用“文字呈现”时，会支持这样的文本呈现，但当使用dialect-specific type时，除非特定相关类型伪造字符串格式的实现，否则会引发```NotImplementedError```，从1.4.45开始成为:class:<cite>.CompileError`的一部分(:ticket:`8800</cite>)。</p>
<p>使用使用句柄字面值。 这里是字符串化的带有明文密码的URL，使用:meth:<cite>_url.URL.render_as_string</cite> 方法。</p>
<p>跨端口连接以及其他情况如下：</p>
<blockquote>
<div><p># to see sql with unobfuscated passwords for unittests,
# convert url to string first and pass the hide_password=False
# parameter to the render_as_string method call.
&gt;&gt;&gt; str(engine.url).replace(”<a href="#id53"><span class="problematic" id="id54">**</span></a><a href="#id55"><span class="problematic" id="id56">*</span></a>”, “password”)
‘postgresql://user:password&#64;localhost:5432/dbname’</p>
</div></blockquote>
<p><a href="#id57"><span class="problematic" id="id58">:ticket:`8567`</span></a></p>
</section>
<section id="result-asyncresult">
<span id="change-8710"></span><h2><code class="docutils literal notranslate"><span class="pre">Result</span></code>, <a href="#id59"><span class="problematic" id="id60">``</span></a>AsyncResult``现在支持上下文管理器<a class="headerlink" href="#result-asyncresult" title="Permalink to this heading">¶</a></h2>
<p>:class:<a href="#id61"><span class="problematic" id="id62">`</span></a>.Result`对象现在支持上下文管理器使用，这将确保在块的结束时关闭对象及其底层游标。这在使用服务器端游标时特别有用，在这种情况下，重要的是，即使发生用户定义的异常，未经提交的更改（未关闭的游标）也会在操作结束时得到关闭:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">yield_per</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">text</span><span class="p">(</span><span class="s2">&quot;select * from table&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></pre></div>
</div>
<p>使用异步的情况下，<code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult`和:class:</span></code>.AsyncConnection`已更改，以提供可选的异步上下文管理器使用，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">with</span> <span class="n">async_engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">yield_per</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">text</span><span class="p">(</span><span class="s2">&quot;select * from table&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></pre></div>
</div>
<p><a href="#id63"><span class="problematic" id="id64">:ticket:`8710`</span></a></p>
</section>
<section id="id65">
<h2>行为变化<a class="headerlink" href="#id65" title="Permalink to this heading">¶</a></h2>
<p>此节介绍了SQLAlchemy 2.0中的行为变化，这些变化不在主要的1.4-&gt;2.0迁移路径中，这些变化不应该对向后兼容性产生重大影响。</p>
<section id="session">
<span id="change-9015"></span><h3>新的事务加入模式 <code class="docutils literal notranslate"><span class="pre">Session</span></code><a class="headerlink" href="#session" title="Permalink to this heading">¶</a></h3>
<p>“将外部事务加入到Session`中的行为已被修改和改进，允许明确控制:class:<cite>_orm.Session`会如何适应已经具有事务和可能已经建立保存点的:class:`_engine.Connection</cite>。新的参数 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.join_transaction_mode`包括一系列选项值，它们可以以几种方式容纳现有的:class:`_engine.Connection</span></code>。最重要的是，它允许：class:<a href="#id66"><span class="problematic" id="id67">`</span></a>_orm.Session`仅使用保存点开始全事务处理运输，而不将外部启动的事务提交或回滚。</p>
<p>这主要优化的改进是已经在文档 <a class="reference internal" href="../orm/session_transaction.html#session-external-transaction"><span class="std std-ref">将会话加入外部事务中（例如用于测试套件）</span></a> 中进行了详细记录，其中还包括了从SQLAlchemy1.3到1.4的变化它现在已经简化为不再需要明确使用事件处理程序或任何提到过的显式保存点（savepoint）; 通过使用``join_transaction_mode=”create_savepoint”<a href="#id68"><span class="problematic" id="id69">``</span></a>，:class:<a href="#id70"><span class="problematic" id="id71">`</span></a>_orm.Session`永远不会影响现有事务的状态，而将始终自己创建保存点（savepoint）。</p>
<p>以下是给出了示例，它在 :ref:<a href="#id72"><span class="problematic" id="id73">`</span></a>session_external_transaction`中给出了；参见该节以获取完整示例。</p>
<blockquote>
<div><dl>
<dt>class SomeTest(TestCase):</dt><dd><dl>
<dt>def setUp(self):</dt><dd><p># connect to the database
self.connection = engine.connect()</p>
<p># begin a non-ORM transaction
self.trans = self.connection.begin()</p>
<p># bind an individual Session to the connection, selecting
# “create_savepoint” join_transaction_mode
self.session = Session(</p>
<blockquote>
<div><p>bind=self.connection, join_transaction_mode=”create_savepoint”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>def tearDown(self):</dt><dd><p>self.session.close()</p>
<p># rollback non-ORM transaction
self.trans.rollback()</p>
<p># return connection to the Engine
self.connection.close()</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>默认情况下选择的:paramref:<cite>_orm.Session.join_transaction_mode`是 `</cite>”conditional_savepoint”<code class="docutils literal notranslate"><span class="pre">模式，如果给定的:class:`_engine.Connection`：class:`_engine.Engine`已经在保存点上，会使用</span></code>”create_savepoint”<a href="#id74"><span class="problematic" id="id75">``</span></a>行为。如果给定的:class:<a href="#id76"><span class="problematic" id="id77">`</span></a>_engine.Connection`处于已经存在的事务而不是保存点，则:class:<a href="#id78"><span class="problematic" id="id79">`</span></a>_orm.Session`将传播“rollback”呼叫，但不会传播“commit”呼叫，但是不会启动自己的保存点。这种行为被默认选定，因为它最大限度地兼容旧版SQLAlchemy的兼容性，且它会在当前给定驱动程序可以使用SAVEPOINT的情况下开始新SAVEPOINT ，因为对SAVEPOINT的支持不仅在特定后端和驱动程序，还在特定配置中变化。</p>
<p>加入在事务中已经启动的:class:<a href="#id80"><span class="problematic" id="id81">`</span></a>_engine.Connection`的新代码应显式选择 :paramref:<a href="#id82"><span class="problematic" id="id83">`</span></a>_orm.Session.join_transaction_mode`参数，以便显式定义所需的行为。</p>
<p><a href="#id84"><span class="problematic" id="id85">:ticket:`9015`</span></a></p>
</section>
<section id="str-engine-url">
<span id="change-8567"></span><h3><code class="docutils literal notranslate"><span class="pre">str(engine.url)</span></code> 默认情况下会隐藏密码<a class="headerlink" href="#str-engine-url" title="Permalink to this heading">¶</a></h3>
<p>为了避免数据库密码泄漏，在:class:<cite>.URL`上调用``str()`</cite>
现将默认启用密码隐藏功能。以前，这种隐藏会在``__repr__()``调用上启用，但在``__str__()``时不会启用。这对于企图使用另一个引擎的字符串化URL来调用:func:<a href="#id86"><span class="problematic" id="id87">`</span></a>_sa.create_engine`的应用程序和测试套件可能会产生影响，例如：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">str</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">url</span><span class="p">))</span></pre></div>
</div>
<p>上述代码中，引擎``e2``不会包含正确的密码字符串，它将包含替换成``”<a href="#id88"><span class="problematic" id="id89">**</span></a><a href="#id90"><span class="problematic" id="id91">*</span></a>”<a href="#id92"><span class="problematic" id="id93">``</span></a>的字符串。</p>
<p>上述模式的首选方法是直接传递:class`URL`对象，没有必要将其转换为字符串:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">e1</span><span class="o">.</span><span class="n">url</span><span class="p">)</span></pre></div>
</div>
<p>否则，对于带有明文密码的字符串URL，可以使用:meth:<cite>_url.URL.render_as_string`方法，并传递参数:paramref:`_url.URL.render_as_string.hide_password`为``False`</cite>， 如下所示：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url_string</span> <span class="o">=</span> <span class="n">e1</span><span class="o">.</span><span class="n">url</span><span class="o">.</span><span class="n">render_as_string</span><span class="p">(</span><span class="n">hide_password</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">url_string</span><span class="p">)</span></pre></div>
</div>
<p><a href="#id94"><span class="problematic" id="id95">:ticket:`8567`</span></a></p>
</section>
<section id="table">
<span id="change-8925"></span><h3>以相同名称、键的列替换Table对象严格规则<a class="headerlink" href="#table" title="Permalink to this heading">¶</a></h3>
<p>严格规则已经制定来做到以下几点：</p>
<ul class="simple">
<li><p>毫无疑问，<code class="xref py py-class docutils literal notranslate"><span class="pre">Table`对象永远不应该有两个或多个相同名称的</span> <span class="pre">:class:</span></code>.Column`对象，无论它们有什么 .key。已经识别和修复了一种可能出现这种情况的边缘情况。</p></li>
<li><p>添加与现有的:class:<cite>.Column`有相同名称或键值的:class:</cite>.Column`会始终引发:class:<cite>.DuplicateColumnError</cite>，除非存在其他参数; <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing" title="sqlalchemy.schema.Table.append_column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.append_column.replace_existing</span></code></a> 用于:meth:<cite>.Table.append_column</cite>，以及用于构造名字相同的:class:<a href="#id96"><span class="problematic" id="id97">`</span></a>.Table`作为一个现有的，带或不带反射都可以。此前这是一个弃用警告。</p></li>
<li><p>如果一个:class:<cite>.Table`只有一个名为’name’的列，而且它被另一个没有任何显式键支持的传入 :class:</cite>.Column`  全部替换，则会发出警告，这意味着操作不是用户想要的。尤其是在二次反射阶段下，比如  <code class="docutils literal notranslate"><span class="pre">metadata.reflect(extend_existing=True)</span></code>。警告建议将 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace`参数设置为``False`" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.autoload_replace`参数设置为``False`</span></code></a>，以防止这种情况的出现。在1.4及以前的版本中，在此情况下，传入的列仅会**另外**添加到现有列中。这是一个2.0中的bug，从2.0.0b4开始是行为上的变化，因为在此情况下，旧的key将**不再在**列集合中存在。</p></li>
</ul>
<p><a href="#id98"><span class="problematic" id="id99">:ticket:`8925`</span></a></p>
</section>
<section id="orm-sort-order">
<span id="change-9297"></span><h3>ORM映射的列顺序有所不同;使用``sort_order``控制行为<a class="headerlink" href="#orm-sort-order" title="Permalink to this heading">¶</a></h3>
<p>Declarative已更改了未同实际申明类的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 排序方式，以及这些的映射列作为从declare类本身派生的mixin或抽象基类中的列的方式，以将来自申明类自身的列放在前面，然后是自mixin列。以下映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">col1</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">col3</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Bar</span><span class="p">:</span>
    <span class="n">col2</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">col4</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">):</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;model&quot;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>在1.4上提供的CREATE TABLE为：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">col1</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col3</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col2</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col4</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>但是在2.0上，则是：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">col1</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col3</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col2</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col4</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>对于上面的特殊情况，可以看作是改进，因为”Model”上 pri众键列现在位于你通常会首选的位置。然而，这不能让申declare模型较早的应用了这个功能的程序获得安慰：</p>
<blockquote>
<div><dl class="simple">
<dt>class Foo:</dt><dd><p>id = mapped_column(Integer, primary_key=True)
col1 = mapped_column(Integer)
col3 = mapped_column(Integer)</p>
</dd>
<dt>class Model(Foo, Base):</dt><dd><p>col2 = mapped_column(Integer)
col4 = mapped_column(Integer)
__tablename__ = “model”</p>
</dd>
</dl>
</div></blockquote>
<p>现在的CREATE TABLE输出如下：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">col2</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col4</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">col1</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col3</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>为了解决此问题，SQLAlchemy 2.0.4引入了对:func:<cite>_orm.mapped_column</cite>
的新参数 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.sort_order</span></code>，这是一个整数值，缺省为``0``，可以设置为正值或负值，这样可以将列置于其他列之前或之后，例如下面的示例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort_order</span><span class="o">=-</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">col1</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">sort_order</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">col3</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">col2</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">col4</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;model&quot;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述模型在所有列之前放置“id”，在“id”之后放置“col1”：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="n">col1</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col2</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col4</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="n">col3</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>在将来的SQLAlchemy版本中，可以选择为:class:<a href="#id100"><span class="problematic" id="id101">`</span></a>_orm.mapped_column`构造提供显式排序提示，因为这种排序只针对ORM。</p>
</section>
<section id="sequence-sql-server">
<span id="change-7211"></span><h3><a href="#id102"><span class="problematic" id="id103">``</span></a>Sequence``构造现在默认不具有任何显式的默认“开始”值；影响到SQL Server<a class="headerlink" href="#sequence-sql-server" title="Permalink to this heading">¶</a></h3>
<p>在SQLAlchemy1.4之前，如果未指定其他参数，则:class:<a href="#id104"><span class="problematic" id="id105">`</span></a>.Sequence`构造函数只会发出简单的``CREATE SEQUENCE``DDL：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="s2">&quot;my_sequence&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">CreateSequence</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">default</span><span class="p">))</span>
<span class="go">CREATE SEQUENCE my_sequence START 1 INCREMENT BY 1 MAXVALUE 9223372036854775807</span>
<span class="go">MINVALUE -9223372036854775808 CYCLE CACHE 1 NO CYCLE</span></pre></div>
</div>
<p>但是，对于SQL Server方言，<code class="docutils literal notranslate"><span class="pre">START``关键字是一个必须的参数。为避免问题，:class:`.Sequence`现在不再在SQL</span> <span class="pre">Server及任何其他方言中默认指定这个值，并且如果未指定，会引发``TypeError</span></code>，但是可以将 <a href="#id106"><span class="problematic" id="id107">``</span></a>start=1``传递给构造函数来解决这个问题，如下所示：</p>
<blockquote>
<div><p>my_sequence = Sequence(“my_sequence”, start=1)</p>
</div></blockquote>
<p>对于其他方言，使用默认值仍然可以正常工作。</p>
<p>这是一个从1.4.9起的行为变化。</p>
<dl>
<dt><a href="#id108"><span class="problematic" id="id109">:ticket:`7211`</span></a>    &gt;&gt;&gt; # SQLAlchemy 1.3 (and 2.0)</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.schema</span> <span class="kn">import</span> <span class="n">CreateSequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">CreateSequence</span><span class="p">(</span><span class="n">Sequence</span><span class="p">(</span><span class="s2">&quot;my_seq&quot;</span><span class="p">)))</span>
<span class="go">{printsql}CREATE SEQUENCE my_seq</span></pre></div>
</div>
</dd>
</dl>
<p>然而，随着增加了对MS SQL Server的:class:<cite>.Sequence`支持，其中默认起始值设置为`</cite>-2**63``，因此，版本1.4决定，如果没有提供:paramref:<cite>.Sequence.start</cite>，则将DDL默认发出起始值为1：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># SQLAlchemy 1.4 (only)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.schema</span> <span class="kn">import</span> <span class="n">CreateSequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">CreateSequence</span><span class="p">(</span><span class="n">Sequence</span><span class="p">(</span><span class="s2">&quot;my_seq&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">CREATE</span><span class="w"> </span><span class="n">SEQUENCE</span><span class="w"> </span><span class="n">my_seq</span><span class="w"> </span><span class="k">START</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="mi">1</span>
</div></pre></div>
</div>
<p>这个变化引入了其他复杂性，其中包括当包括:paramref:<cite>.Sequence.min_value`参数时，这个默认值``1``实际上应该默认为:paramref:</cite>.Sequence.min_value`所指定的值，否则，小于起始值的min_value可能会被视为相互矛盾。首先，查看这个问题开始成为其他各种边缘情况的一个兔子洞，所以我们决定取消这个变化并恢复:class:<a href="#id110"><span class="problematic" id="id111">`</span></a>.Sequence`的原始行为，即没有意见，只发出CREATE SEQUENCE，让数据库本身决定``SEQUENCE``的各个参数应如何相互作用。</p>
<p>因此，为确保起始值在所有后端都是1，<strong>必须明确指出起始值1</strong>，如下所示：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># All SQLAlchemy versions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.schema</span> <span class="kn">import</span> <span class="n">CreateSequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">CreateSequence</span><span class="p">(</span><span class="n">Sequence</span><span class="p">(</span><span class="s2">&quot;my_seq&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">CREATE</span><span class="w"> </span><span class="n">SEQUENCE</span><span class="w"> </span><span class="n">my_seq</span><span class="w"> </span><span class="k">START</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="mi">1</span>
</div></pre></div>
</div>
<p>除此之外，在现代后端（包括PostgreSQL、Oracle、SQL Server）上自动生成整数主键的情况下，应优先使用:class:<a href="#id112"><span class="problematic" id="id113">`</span></a>.Identity`构造，它在1.4和2.0中工作方式相同，行为没有任何变化。</p>
<p><a href="#id114"><span class="problematic" id="id115">:ticket:`7211`</span></a></p>
</section>
<section id="with-variant-typeengine">
<span id="change-6980"></span><h3><a href="#id116"><span class="problematic" id="id117">``</span></a>with_variant()``方法克隆原始的TypeEngine而不是更改类型<a class="headerlink" href="#with-variant-typeengine" title="Permalink to this heading">¶</a></h3>
<p>:meth:<a href="#id118"><span class="problematic" id="id119">`</span></a>_sqltypes.TypeEngine.with_variant`方法用于为特定类型应用替代的数据库行为，现在会返回原始的:class:<a href="#id120"><span class="problematic" id="id121">`</span></a>_sqltypes.TypeEngine`对象的副本，并在其中存储变量信息，而不是将其包装在``Variant``类中。</p>
<p>虽然以前的``Variant``方法能够使用动态属性getter维护所有在Python中的行为，但这里的改进是，当调用一个变量时，返回的类型仍然是原始类型的实例，这在类型检测器（如mypy和pylance）中更加流畅。如下程序所示：</p>
<blockquote>
<div><p>import typing</p>
<p>from sqlalchemy import String
from sqlalchemy.dialects.mysql import VARCHAR</p>
<p><a href="#id199"><span class="problematic" id="id200">type_</span></a> = String(255).with_variant(VARCHAR(255, charset=”utf8mb4”), “mysql”, “mariadb”)</p>
<dl class="simple">
<dt>if typing.TYPE_CHECKING:</dt><dd><p>reveal_type(<a href="#id201"><span class="problematic" id="id202">type_</span></a>)</p>
</dd>
</dl>
</div></blockquote>
<p>像pyright这样的类型检测器现在将报告类型为：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>info: Type of &quot;type_&quot; is &quot;String&quot;</pre></div>
</div>
<p>此外，对于单个类型可以通过传递多个方言名称来提高可读性和可维护性，这在使用与``”mysql”<code class="docutils literal notranslate"><span class="pre">和</span></code>”mariadb”<a href="#id122"><span class="problematic" id="id123">``</span></a>方言不一样时最为有效。此时，在1.4和2.0中，多个方言名称可以用于相同的类型名称。</p>
<p><a href="#id124"><span class="problematic" id="id125">:ticket:`6980`</span></a></p>
</section>
<section id="python">
<span id="change-4926"></span><h3>Python除法操作符在所有后端上执行真除法；增加整数除法<a class="headerlink" href="#python" title="Permalink to this heading">¶</a></h3>
<p>Core表达式语言现在支持“真除法”（即``/<code class="docutils literal notranslate"><span class="pre">Python操作符）和“地板除法”（即</span></code>//<a href="#id126"><span class="problematic" id="id127">``</span></a>Python操作符），包括后端特定的行为，以规范化在这方面不同的数据库。</p>
<p>给定针对两个整数值的“真除法”操作：</p>
<blockquote>
<div><p>expr = literal(5, Integer) / literal(10, Integer)</p>
</div></blockquote>
<p>例如，在PostgreSQL上，正常情况下，SQL除法运算符在针对整数使用时的作用是“地板除法”，这意味着上述结果将返回整数“0”。对于这些和类似的后端，SQLAlchemy现在使用了一个等价于以下形式的表单来呈现SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="p">(</span><span class="n">param_1</span><span class="p">)</span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">param_2</span><span class="p">)</span><span class="n">s</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">NUMERIC</span><span class="p">)</span></pre></div>
</div>
<p>其中，<code class="docutils literal notranslate"><span class="pre">param_1=5</span></code>，<code class="docutils literal notranslate"><span class="pre">param_2=10</span></code>，所以返回表达式将是NUMERIC类型，通常作为Python值``decimal.Decimal(“0.5”)``。</p>
<p>在给定两个整数值的“地板除法”操作时：</p>
<blockquote>
<div><p>expr = literal(5, Integer) // literal(10, Integer)</p>
</div></blockquote>
<p>例如，对于MySQL和Oracle等后端，使用对整数的“真除法”，这意味着上述结果将返回浮点值 “0.5”。对于这些和类似的后端，SQLAlchemy现在使用了一个等价于以下形式的表单来呈现SQL：</p>
<p>… code-block</p>
<blockquote>
<div><p>FLOOR(%(param_1)s / %(param_2)s)</p>
</div></blockquote>
<p>其中param_1=5，param_2=10，因此返回表达式将是INTEGER类型，作为Python值``0``。</p>
<p>这里的向后不兼容的更改是，如果一个应用程序在PostgreSQL、SQL Server或SQLite上，依赖Python“true div”操作符在所有情况下返回整数值的情况下失败。如果应用程序依赖此行为，则对于这些操作应该使用Python“floor division”运算符``//<a href="#id128"><span class="problematic" id="id129">``</span></a>或向前兼容性，使用之前的SQLAlchemy版本时使用floor函数：</p>
<blockquote>
<div><p>expr = func.floor(literal(5, Integer) / literal(10, Integer))</p>
</div></blockquote>
<p>在SQLAlchemy 2.0之前的任何版本中，上述形式都需要使支持后端自适应地完成地板除法。</p>
<p><a href="#id130"><span class="problematic" id="id131">:ticket:`4926`</span></a></p>
</section>
<section id="change-7433">
<span id="id132"></span><h3>Session提示检测到非法并发或可重入访问时引发<a class="headerlink" href="#change-7433" title="Permalink to this heading">¶</a></h3>
<p>现在，:class:<a href="#id133"><span class="problematic" id="id134">`</span></a>_orm.Session`可以捕获更多的与多线程或其他并发情况中的非法并发状态更改和执行意外状态更改的事件挂钩相关的错误。</p>
<p>当同时在多个线程中使用:class:<cite>_orm.Session`时，已知会发生一种错误是
``AttributeError: ‘NoneType’ object has no attribute ‘twophase’`</cite>，这是完全神秘的。当一个线程调用:meth:<a href="#id135"><span class="problematic" id="id136">`</span></a>_orm.Session.commit`时，它内部调用:meth:<a href="#id137"><span class="problematic" id="id138">`</span></a>_orm.SessionTransaction.close`方法来结束事务上下文，同时另一个线程正在运行一个查询，如:meth:<a href="#id139"><span class="problematic" id="id140">`</span></a>_orm.Session.execute`中的查询，而:meth:<a href="#id141"><span class="problematic" id="id142">`</span></a>_orm.Session.execute`会使用当前事务获取数据库连接的内部方法开头，首先assert该会话为“active”，但是这个断言通过后，同时调用:meth:<a href="#id143"><span class="problematic" id="id144">`</span></a>_orm.Session.close`调用干扰了这个状态，导致上述未定义的条件。</p>
<p>该更改对围绕:class:<a href="#id145"><span class="problematic" id="id146">`</span></a>_orm.SessionTransaction`对象的所有更改状态的方法周围的状态更改应用保护，以便在上述情况下，:meth:<a href="#id147"><span class="problematic" id="id148">`</span></a>_orm.Session.commit`方法将无法更改状态，而是寻求改变状态为：正在为当前连接获取数据库查询的方法已在进程中进行，从而导致一个不允许的状态。</p>
<p>对于asyncio，需要注意，如果将特定的:class:<a href="#id149"><span class="problematic" id="id150">`</span></a>_orm.Session`共享到多个asyncio任务中，则此更改也适用。</p>
<p><a href="#id151"><span class="problematic" id="id152">:ticket:`7433`</span></a></p>
</section>
<section id="sqlitequeuepool">
<span id="change-7490"></span><h3>SQLite方言对基于文件的数据库使用QueuePool<a class="headerlink" href="#sqlitequeuepool" title="Permalink to this heading">¶</a></h3>
<p>当使用基于文件的数据库时，SQLite方言现在默认使用:class:<cite>_pool.QueuePool</cite>。它与设置``check_same_thread=False``一起使用。发现默认使用:class:<a href="#id153"><span class="problematic" id="id154">`</span></a>_pool.NullPool`会在释放后不保留数据库连接，但实际上具有明显的性能负面影响。除此之外，可通过使用:paramref:<a href="#id155"><span class="problematic" id="id156">`</span></a>_sa.create_engine.poolclass`参数来自定义池类。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/sqlite.html#pysqlite-threading-pooling"><span class="std std-ref">Threading/Pooling Behavior</span></a></p>
</div>
<p><a href="#id157"><span class="problematic" id="id158">:ticket:`7490`</span></a></p>
</section>
<section id="oracle-float">
<span id="change-5465-oracle"></span><h3>新的带二进制精度的Oracle FLOAT类型；不直接接受十进制精度<a class="headerlink" href="#oracle-float" title="Permalink to this heading">¶</a></h3>
<p>Oracle方言添加了一种新的数据类型:class:<cite>_oracle.FLOAT</cite>，配合添加的:class:<cite>_sqltypes.Double`和特定于数据库的:class:`_sqltypes.DOUBLE</cite>、:class:<a href="#id159"><span class="problematic" id="id160">`</span></a>_sqltypes.DOUBLE_PRECISION`和:class:<a href="#id161"><span class="problematic" id="id162">`</span></a>_sqltypes.REAL`数据类型。Oracle的“FLOAT”接受所谓的“二进制精度”参数，根据Oracle文档，这大致相当于将“精度”值除以0.3103：</p>
<blockquote>
<div><p>from sqlalchemy.dialects import oracle</p>
<p>Table(“some_table”, metadata, Column(“value”, oracle.FLOAT(126)))</p>
</div></blockquote>
<p>具有二进制精度值126等同于使用:class:<a href="#id163"><span class="problematic" id="id164">`</span></a>_sqltypes.DOUBLE_PRECISION`数据类型，值63等同于使用:class:<a href="#id165"><span class="problematic" id="id166">`</span></a>_sqltypes.REAL`数据类型。其他精度值是具体的:class:<a href="#id167"><span class="problematic" id="id168">`</span></a>_oracle.FLOAT`类型。</p>
<p>SQLAlchemy的:class:<cite>_sqltypes.Float`数据类型也接受“精度”参数，但这是Oracle不接受的十进制精度。为了避免尝试猜测转换，如果对Oracle后端使用:class:`_sqltypes.Float</cite>，则Oracle方言现在会引发一个信息性错误。要使用显示精度值指定:class:<a href="#id169"><span class="problematic" id="id170">`</span></a>_sqltypes.Float`数据类型以支持后端支持，同时又要支持其他后端，使用:meth:<a href="#id171"><span class="problematic" id="id172">`</span></a>_types.TypeEngine.with_variant`方法：</p>
<blockquote>
<div><p>from sqlalchemy.types import Float
from sqlalchemy.dialects import oracle</p>
<dl class="simple">
<dt>Table(</dt><dd><p>“some_table”,
metadata,
Column(“value”, Float(5).with_variant(oracle.FLOAT(16), “oracle”)),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</section>
<section id="range-multirangepostgresql">
<span id="change-7156"></span><h3>新的RANGE/MULTIRANGE支持和PostgreSQL后端的更改<a class="headerlink" href="#range-multirangepostgresql" title="Permalink to this heading">¶</a></h3>
<p>已完全为psycopg2、psycopg3和asyncpg方言实现RANGE/MULTIRANGE支持。新支持使用新的SQLAlchemy特定的:class:<a href="#id173"><span class="problematic" id="id174">`</span></a>_postgresql.Range`对象，
该对象不依赖于不同的后端，也不需要使用后端特定的导入或扩展步骤。对于多范围支持，使用:class:<a href="#id175"><span class="problematic" id="id176">`</span></a>_postgresql.Range`对象的列表。</p>
<p>使用以前的psycopg2特定类型的代码应修改为使用:class:<cite>_postgresql.Range</cite>，这样可以呈现兼容的接口。</p>
<p>:class:<a href="#id177"><span class="problematic" id="id178">`</span></a>_postgresql.Range`对象还具有与PostgreSQL相同的比较支持。到目前为止已经实现的是:meth:<a href="#id179"><span class="problematic" id="id180">`</span></a>_postgresql.Range.contains`和:meth:<a href="#id181"><span class="problematic" id="id182">`</span></a>_postgresql.Range.contained_by`方法，其工作方式与PostgreSQL的“&#64;&gt;”和“&lt;&#64;”相同。将来可以添加其他操作符支持。</p>
<p>请参阅:ref:<a href="#id183"><span class="problematic" id="id184">`</span></a>postgresql_ranges`中的文档，了解使用新特性的背景情况。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">postgresql_ranges</span></p>
</div>
<p><a href="#id185"><span class="problematic" id="id186">:ticket:`7156`</span></a>
<a href="#id187"><span class="problematic" id="id188">:ticket:`8706`</span></a></p>
</section>
<section id="postgresql-match-plainto-tsquery-to-tsquery">
<span id="change-7086"></span><h3>PostgreSQL上的``match()``操作符使用``plainto_tsquery()``而不是``to_tsquery()``<a class="headerlink" href="#postgresql-match-plainto-tsquery-to-tsquery" title="Permalink to this heading">¶</a></h3>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.match`函数现在使用PostgreSQL的``plainto_tsquery(expr)`()</span></code>，而不是``to_tsquery()``。<a href="#id189"><span class="problematic" id="id190">``</span></a>plainto_tsquery()``接受纯文本，而``to_tsquery()``接受专门的查询符号，因此与其他后端比较，具有更低的跨兼容性。</p>
<p>通过使用:data:<cite>.func`生成PostgreSQL特定函数和:meth:</cite>.Operators.bool_op`（<code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op`的布尔类型版本）来生成任意操作符，在:meth:()</span></code>.Operators.match`中使用所有PostgreSQL搜索函数和操作符，从而在以前版本中的方式下可用，如同使用相关的示例：<a class="reference internal" href="../dialects/postgresql.html#postgresql-match"><span class="std std-ref">Full Text Search</span></a>。</p>
<p>现有的SQLAlchemy项目使用:meth:<cite>.Operators.match`中的PG特定指令，应直接使用``func.to_tsquery()`</cite>。要在SQLAlchemy 1.4中呈现的SQL与1.4中存在的一样，请参见版本说明:ref:<cite>postgresql_simple_match</cite>。</p>
<p><a href="#id191"><span class="problematic" id="id192">:ticket:`7086`</span></a></p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="migration_20.html" title="previous chapter">SQLAlchemy 2.0 - 主要迁移指南</a>
        Next:
        <a href="changelog_20.html" title="next chapter">2.0 变更日志</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:19:42

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


