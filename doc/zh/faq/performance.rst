.. _faq_performance:

性能
===========

.. contents::
    :local:
     :class: faq
    :backlinks: none

.. _faq_new_caching:

为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？
--------------------------------------------------------------

从1.4版本开始，SQLAlchemy包括一个
  :ref:`SQL 编译缓存机制 <sql_caching>` ，该机制将允许
Core和ORM SQL构造缓存其字符串形式以及其他结构信息，用于从语句中获取结果，从而
在下一次使用另一个结构等效构造时，跳过比较昂贵的字符串编译过程。这个系统
依赖于所有SQL构造的可实现的功能，包括
对象，例如  :class:`_schema.Column` ,
  :func:`_sql.select` ，和 :class:` _types.TypeEngine`对象，以生成一个
**缓存密钥**，它完全表示它们的状态，以影响它们的程度
SQL编译过程。

缓存系统允许SQLAlchemy 1.4及以上版本比
SQLAlchemy 1.3转换SQL构造为字符串的时间要更短
反复。但是，这仅在为该特定SQL dialect和SQL构造启用缓存时才有效；
否则，字符串编译通常类似于SQLAlchemy 1.3，某些情况下速度略有下降。

然而，有一种情况，即如果SQLAlchemy的新缓存系统已被禁用（由于以下原因），则ORM的性能实际上可能
比1.3或其他先前版本的性能显着更差，这是由于在ORM懒惰加载器和对象刷新查询中缺少缓存
在1.3和早期版本中使用了现在过时的“BakedQuery”系统。如果
应用程序在切换到1.4时看到了显着的（30％或更高）性能降级
（以完成操作所需的时间为度量），那么这是问题的可能原因，下面是减轻步骤。

.. seealso::

      :ref:`sql_caching`  - 缓存系统概述

      :ref:`caching_caveats`  - 有关未启用缓存的元素产生的警告的其他信息。

第一步-打开SQL记录并确认是否正在工作的缓存
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在这里，我们要使用在
 :ref:`引擎日志记录<sql_caching_logging>` 中介绍的技术，查找具有该语句的语句
“[no key]”标识符或者甚至是“[dialect does not support caching]”。
当语句第一次调用时，“[generated in Xs]”会指示
对于每个语句，接下来的大多数语句则为“[cached since Xs ago]”。如果
“[no key]”普遍存在特别是对于SELECT语句，或者
如果由于“[dialect does not support caching]”，缓存被完全禁用
这可能是严重性能下降的原因。

.. seealso::

      :ref:`sql_caching_logging` 

第二步-确定什么结构阻止了启用缓存
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

假设语句没有被缓存，则应发出警告
应用程序的日志（仅限SQLAlchemy 1.4.28及以上版本）指示方言， :class:`.TypeEngine` 对象以及不是SQL
不参与缓存的构造。

对于像那些从 :class:`_types.TypeDecorator` 扩展的自定义类型而言，
和  :class:`_types.UserDefinedType` ，警告将如下所示：

.. sourcecode:: text

    sqlalchemy.ext.SAWarning: MyType will not produce a cache key because the
    "cache_ok" attribute is not set to True. This can have significant
    performance implications including some performance degradations in
    comparison to prior SQLAlchemy versions. Set this attribute to True if this
    type object's state is safe to use in a cache key, or False to disable this
    warning.

对于自定义和第三方SQL元素，例如使用
在 :ref:`sqlalchemy.ext.compiler_toplevel` 中描述的技术，这些警告将如下所示：

.. sourcecode:: text

    sqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL
    compilation caching as it does not set the 'inherit_cache' attribute to
    ``True``. This can have significant performance implications including some
    performance degradations in comparison to prior SQLAlchemy versions. Set
    this attribute to True if this object can make use of the cache key
    generated by the superclass. Alternatively, this attribute may be set to
    False which will disable this warning.

对于使用 :class:`.Dialect` 类层次结构的自定义和第三方方言，警告将如下所示：

.. sourcecode:: text

    sqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL
    compilation caching as it does not set the 'supports_statement_cache'
    attribute to ``True``. This can have significant performance implications
    including some performance degradations in comparison to prior SQLAlchemy
    versions. Dialect maintainers should seek to set this attribute to True
    after appropriate development and testing for SQLAlchemy 1.4 caching
    support. Alternatively, this attribute may be set to False which will
    disable this warning.

第三步-为给定对象启用缓存和/或寻求替代方案
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

缓解缓存不足的步骤包括：

*检查并设置  :class:`.ExternalType.cache_ok` ，
   :class:`_types.UserDefinedType` 扩展，以及这些类型的子类，例如
    :class:`_types.PickleType` 。此设置只需在自定义类型不包括影响其如何呈现SQL的任何附加状态属性时使用::

        class MyCustomType(TypeDecorator):
            cache_ok = True
            impl = String

  如果使用的类型来自于第三方库，请与该库的维护者联系，以便进行相应的调整并发布。

  .. seealso::

     :attr:`.ExternalType.cache_ok`  - 背景要求使自定义数据类型启用
    缓存。

* 确保第三方方言将：attr:`.Dialect.supports_statement_cache`
  设置为``True``。这表示第三方方言的维护者已经确定它们的方言是否与SQLAlchemy 1.4或更高版本一起使用，
  并且它们的方言不包含会影响缓存的任何编译功能。由于确实存在一些常见的编译模式，
  可能会干扰缓存，因此方言维护者检查并仔细测试这一点非常重要，调整任何旧版
  不适用缓存的模式。

  .. seealso::

        :ref:`engine_thirdparty_caching`  - 参与SQL语句缓存的第三
      方方言的背景和示例。

* 21自定义SQL类，包括使用 :ref:`sqlalchemy.ext.compiler_toplevel` 创建的所有DQL / DML构造，
  以及  :class:`_schema.Column` .HasCacheKey.inherit_cache` 属性
  可以用于没有包含任何的显式子类特定状态信息的微不足道的子类。影响SQL编译。

  .. seealso::

      :ref:`compilerext_caching`  - 应用  :attr:` .HasCacheKey.inherit_cache`  属性的指南。


.. seealso::

      :ref:`sql_caching`  - 缓存系统概述

      :ref:`caching_caveats`  - 有关未启用特定构造和/或方言的缓存时发出的警告的背景信息。


.. _faq_how_to_profile:

如何为SQLAlchemy提供动态性能分析？
---------------------------------------------------

查找性能问题通常包括两种策略。一
是查询分析, 另一个是代码分析。

查询分析
^^^^^^^^^^^^^^^

有时仅仅是普通的SQL记录（通过python的日志模块启用
或通过 :func:`_sa.create_engine` 的echo=True参数）可以给一个
对花费的时间有一个概念。例如，如果您记录了某些东西
在SQL操作之后，您会在您的中看到这样的东西
日志：

.. sourcecode:: text

    17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...
    17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {<params>}
    17:37:48,660 DEBUG [myapp.somemessage]

如果您在操作之后记录“myapp.somemessage”，您就会知道
它花费了334ms来完成SQL部分的事情。

记录SQL也将说明是否正在发出几十个/几百个查询
可以更好地组织成远少于查询的查询。使用SQLAlchemy ORM时，提供了“热加载”
功能，用于部分（  :func:`.contains_eager()` )或完全
(  :func:`_orm.joinedload()` ,   :func:` .subqueryload()` )
自动化此操作，但是在
ORM“热加载”通常意味着使用连接，以便可以一次加载多个结果集
在添加更多深度（即“r + r * r2 + r * r2 * r3”…）时，而不是增加查询的数量

对于查询的长期性能分析，或者要实现应用程序方面的“慢查询”监视器，可以使用事件拦截游标执行，
使用以下示例中的配方：

    from sqlalchemy import event
    from sqlalchemy.engine import Engine
    import time
    import logging

    logging.basicConfig()
    logger = logging.getLogger("myapp.sqltime")
    logger.setLevel(logging.DEBUG)


    @event.listens_for(Engine, "before_cursor_execute")
    def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
        conn.info.setdefault("query_start_time", []).append(time.time())
        logger.debug("Start Query: %s", statement)


    @event.listens_for(Engine, "after_cursor_execute")
    def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
        total = time.time() - conn.info["query_start_time"].pop(-1)
        logger.debug("Query Complete!")
        logger.debug("Total Time: %f", total)

在上面的示例中，我们使用  :meth:`_events.ConnectionEvents.before_cursor_execute`  和
  :meth:`_events.ConnectionEvents.after_cursor_execute`  事件，以在语句执行时建立拦截点。
我们使用 :class:`._ConnectionRecord.info` 字典在连接上附加一个定时器；
我们在这里使用一个堆栈，因为游标执行事件可能会嵌套。

.. _faq_code_profiling:

代码分析
^^^^^^^^^^^^^^

如果logging显示单个查询需要太长时间，您将
需要一个内部将时间花费在处理查询的数据库内的细分
它可以提供有关花费多长时间在数据库中，发送结果，正在处理的信息
由  :term:`DBAPI`  处理，最后由SQLAlchemy的结果集或ORM层处理的信息。
每个阶段都可以根据规则自己的瓶颈。

为此，您需要使用
`Python Profiling Module <https://docs.python.org/2/library/profile.html>`_。
以下是一个将分析工作流集成到上下文管理器中的简单示例：

    import cProfile
    import io
    import pstats
    import contextlib


    @contextlib.contextmanager
    def profiled():
        pr = cProfile.Profile()
        pr.enable()
        yield
        pr.disable()
        s = io.StringIO()
        ps = pstats.Stats(pr, stream=s).sort_stats("cumulative")
        ps.print_stats()
        # uncomment this to see who's calling what
        # ps.print_callers()
        print(s.getvalue())

要分析一段代码：

    with profiled():
        session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()

分析的输出可用于指示花费时间的地方。一段分析输出如下所示：

.. sourcecode:: text

    13726 function calls (13042 primitive calls) in 0.014 seconds

    Ordered by: cumulative time

    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)
    220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)
    220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)
       20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)
       20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)
        1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)
       21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(<genexpr>)
        2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)

    ...

在上面的示例中，我们可以看到“instance()”SQLAlchemy函数被调用了222次
（递归，外部调用时21次），所有调用加起来总共需要0.011秒。

执行缓慢
^^^^^^^^^^^^^^^^^^

这些调用的细节可以告诉我们时间花费在哪里。
例如，如果您看到时间花费在“cursor.execute()”中，
例如，对DBAPI：

.. sourcecode:: text

    2    0.102    0.102    0.204    0.102 {method 'execute' of 'sqlite3.Cursor' objects}

这意味着数据库花费了很长时间才开始返回结果，
它意味着您的查询应该进行优化，无论是添加索引
还是重新构造查询和/或底层架构。为此任务，
应该使用查询计划分析，使用数据库后端提供的系统，例如EXPLAIN，
SHOW PLAN等。

结果获取缓慢-Core
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

另一方面，如果看到许多千次的调用与获取行有关，
或者很多延迟的调用到“fetchall()”，它可能
意味着查询返回的行比预期多，或者获取
行本身很慢。ORM自身通常使用“fetchall()”来获取
（或者使用  :meth:`_query.Query.yield_per`  选项时使用“fetchmany()”）。
结果。太多的行将显示在DBAPI级别上很慢调用“fetchAll()”：

.. sourcecode:: text

    2    0.300    0.600    0.300    0.600 {method 'fetchall' of 'sqlite3.Cursor' objects}

即使结果看似没有很多行，但行数意外地多，可能是笛卡尔积的结果-当多个查询集合在一起时，
在没有适当连接表的情况下。如果使用SQLAlchemy Core或ORM查询时使用了错误的 :class:`_schema.Column` 对象，
这可能很容易出现此行为，这将拉出预期之外的额外FROM子句。

另一方面，在DBAPI级别快速调用“fetchAll()”，但是然后在SQLAlchemy的
调用类  :meth:`_engine.CursorResult.fetchall()`  时变慢，
可能表示数据类型处理等处理速度较慢：

.. sourcecode:: text

    # the DBAPI cursor is fast...
    2    0.020    0.040    0.020    0.040 {method 'fetchall' of 'sqlite3.Cursor' objects}

    ...

    #但是SQLAlchemy的结果代理缓慢，这是类型级别处理
    2    0.100    0.200    0.100    0.200 lib/sqlalchemy/engine/result.py:778(fetchall)

在某些情况下，后端可能会执行不必要的类型级别处理。
更具体地说，看到“type_api”中的调用速度慢是更好的指标。
系统，例如Unicode转换等：

.. sourcecode:: text

      200    0.001    0.000    0.237    0.001 lib/sqlalchemy/sql/type_api.py:911(process)
      200    0.001    0.000    0.236    0.001 test.py:28(process_result_value)
      200    0.235    0.001    0.235    0.001 {time.sleep}

也请务必检查  :ref:`Dialect documentation <dialect_toplevel>` 
在这个级别上已知的性能调优建议，特别是对于像Oracle这样的数据库。
可能存在确保数字精度或字符串处理的系统可能不在所有情况下都需要。

还可能存在更底层的行提取性能问题；例如，如果花费的时间似乎集中于类似于“socket.receive()”的调用，
这可能表明每件事都很快，除了实际的网络连接，数据在网络上传输的时间过长。

由ORM提取缓慢结果
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

要在ORM提取行的性能上检测缓慢，如下所示，调用“populate_state()”和“_instance()”将
说明单个ORM对象的填充：

.. sourcecode:: text

    # ORM每次看到ORM-loaded row都为_instance()函数调用一次，
    # 并对每一个在对象属性中结果的ORM-loaded row进行populate_state()函数调用
    220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)
    220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)

ORM将行转换为ORM映射对象的缓慢是此操作的复杂性与CPython的开销的结果。
缓解这种情况的常见策略包括：

* 每次仅获取列而不获取完整的实体，也就是：

      select(User.id, User.name)

  而不是：

      select(User)

* 使用 :class:`.Bundle` 对象组织基于列的结果：

      u_b = Bundle("user", User.id, User.name)
      a_b = Bundle("address", Address.id, Address.email)

      for user, address in session.execute(select(u_b, a_b).join(User.addresses)):
          ...

* 使用结果缓存-请参阅  :ref:`examples_caching` ，了解详细的示例
  如何进行缓存。

* 考虑更快的解释器，例如PyPy。

分析的输出可能有点令人生畏，但是经过一些练习，
它们非常容易阅读。

.. seealso::

      :ref:`examples_performance`  - 带有捆绑的性能演示
    剖析能力。

我正在使用ORM插入400,000行，但速度非常慢！
-------------------------------------------------------------

ORM插入的性质已更改，因为包括大多数内置驱动程序都使用了带有  :ref:`官方API的RETURNING <engine_insertmanyvalues>` 
支持的插入manyvalue为SQLAlchemy 2.0。有关详细信息，请参见 :ref:`change_6047` 部分。

总体而言，除了MySQL的SQLAlchemy内置驱动程序外，现在应该
提供非常快的ORM批量插入性能。

第三方驱动程序还可以选择使用新的批量基础设施，前提是它们的后端支持所需的语法。
SQLAlchemy开发人员将鼓励第三方方言的用户，以便他们可以为问题的这些驱动程序发布问题。
让SQLAlchemy开发人员提供帮助。