.. _faq_performance:

性能
===

.. contents::
    :local:
    :class:`faq`
    :backlinks: none

.. _faq_new_caching:

为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？
---------------------------------------------------------

从版本 1.4 开始，SQLAlchemy 包括一个 :ref:`SQL 编译缓存工具 <sql_caching>`，可以让 Core 和 ORM SQL 结构缓存其序列化形式，以及其他用于从语句抓取结果的结构信息，当下一次使用一个具有相同结构的Construct 时，可以跳过相对昂贵的字符串编译过程。这个系统依赖于所有 SQL 构造的功能实现，包括对象如 :class:`_schema.Column`、:func:`_sql.select` 和:class:`_types.TypeEngine`，以产生一个 **缓存键**（cache key），其完全代表这些构造的状态，以影响 SQL 编译过程。

缓存系统充许 SQLAlchemy 1.4 及以上版本比 SQLAlchemy 1.3 更具备处理转换 SQL 构造的时间效率，但在使用方言和 SQL 构造时，这仅适用于开启缓存的情况; 如果没有开启，字符串编译通常与SQLAlchemy 1.3相似，在某些情况下有轻微的速度降低。

然而，在一种情况下，如果 SQLAlchemy 的新缓存系统已被禁用（由于以下原因），此时 ORM 的性能可能实际上比 1.3 或其他先前版本显著降低，原因是 ORM 延迟加载器和对象刷新查询中缺少缓存，在 1.3 和早期版本中使用了现已遗留的 ``BakedQuery`` 系统。如果应用在切换到1.4时看到显著性能降级（测量完成操作所需的时间规模30%或更高），则这可能是问题的根本原因，如下面要采取的措施。

.. seealso::

    :ref:`sql_caching` - 缓存系统概述

    :ref:`caching_caveats` - 关于不启用缓存的元素生成警告的额外信息。

第一步-打开 SQL 日志并确认是否启用了缓存
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在此，我们要使用描述在 :ref:`engine logging <sql_caching_logging>` 中的技术，查找具有 ``[no key]`` 指示器或甚至是 ``[dialect does not support caching]`` 的语句。当语句首次调用时，我们所看到的指示器将表明“[generated in Xs]”，其后对于绝大多数语句将表明“[cached since Xs ago]”。如果``[no key]`` 对于 SELECT 语句普遍存在，或者如果由于``[dialect does not support caching]`` 而完全禁用了缓存，则这可能是显著性能降低的原因。

.. seealso::

    :ref:`sql_caching_logging`

第二步-识别阻止启用缓存的构造的对象
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

假设没有缓存语句，应用程序日志中会很早地发出警告（仅适用于SQLAlchemy 1.4.28及以上版本），指出不参与缓存的方言、:class:`.TypeEngine` 对象和 SQL 构造。

对于扩展 :class:`_types.TypeDecorator` 和:class:`_types.UserDefinedType` 的所有自定义数据类型，以及 :class:`_types.PickleType` 等的子类，警告将如下所示：

.. sourcecode:: text

    sqlalchemy.ext.SAWarning: MyType will not produce a cache key because the
    ``cache_ok`` attribute is not set to True. This can have significant
    performance implications including some performance degradations in
    comparison to prior SQLAlchemy versions. Set this attribute to True if this
    type object's state is safe to use in a cache key, or False to disable this
    warning.

对于自定义和第三方 SQL 元素，例如使用在 :ref:`sqlalchemy.ext.compiler_toplevel` 中描述的技术构建的元素，这些警告将如下所示：

.. sourcecode:: text

    sqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL
    compilation caching as it does not set the 'inherit_cache' attribute to
    ``True``. This can have significant performance implications including some
    performance degradations in comparison to prior SQLAlchemy versions. Set
    this attribute to True if this object can make use of the cache key
    generated by the superclass. Alternatively, this attribute may be set to
    False which will disable this warning.

对于使用 :class:`.dialect` 类层次结构的自定义和第三方方言，警告将如下所示：

.. sourcecode:: text

    sqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL
    compilation caching as it does not set the 'supports_statement_cache'
    attribute to ``True``. This can have significant performance implications
    including some performance degradations in comparison to prior SQLAlchemy
    versions. Dialect maintainers should seek to set this attribute to True
    after appropriate development and testing for SQLAlchemy 1.4 caching
    support. Alternatively, this attribute may be set to False which will
    disable this warning.

第三步-针对给定的对象启用缓存和/或寻找替代方案
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

缓解缓存不足的措施包括：

* 查看并设置 :attr:`.ExternalType.cache_ok`，对于所有扩展 :class:`_types.TypeDecorator`、:class:`_types.UserDefinedType`，以及 :class:`_types.PickleType` 或其子类的自定义类型。仅在自定义类型不包含影响其如何呈现 SQL 的任何其他状态属性的情况下设置这个属性::

        class MyCustomType(TypeDecorator):
            cache_ok = True
            impl = String

  如果使用的类型来自第三方库，请咨询该库的维护人员，以便进行调整和发布。

  .. seealso::

    :attr:`.ExternalType.cache_ok` - 激活缓存以用于自定义数据类型的要求背景。

* 确保第三方方言将 :attr:`.Dialect.supports_statement_cache` 设为 ``True``。这表示第三方方言的维护者已确保他们自己的方言能够与 SQLAlchemy 1.4 或更高版本一起使用，并且他们的方言不包括可能妨碍缓存的编译功能。由于有一些常见的编译模式可能会影响缓存，因此方言维护者检查并仔细测试，调整遗留未工作的模式是非常重要的。

  .. seealso::

      :ref:`engine_thirdparty_caching` - 在 SQL 语句缓存中参与第三方方言的背景和例子。

* 自定义 SQL 类，包括使用 :ref:`sqlalchemy.ext.compiler_toplevel` 创建的所有 DQL / DML 构造，以及 :class:`_schema.Column` 或 :class:`_schema.Table` 对象的零散子类。对于仅承载缓存键的次要子类，可以将 :attr:`.HasCacheKey.inherit_cache` 设为 ``True``。

  .. seealso::

    :ref:`compilerext_caching` - 应用 :attr:`.HasCacheKey.inherit_cache` 属性的指南。


.. seealso::

    :ref:`sql_caching` - 缓存系统概述

    :ref:`caching_caveats` - 关于特定构造和/或方言未启用缓存时发出的警告的背景信息。


.. _faq_how_to_profile:

如何对由 SQLAlchemy 驱动的应用进行性能分析？
----------------------------------------------------

查找性能问题通常涉及两种策略。一个是查询分析，另一个是代码分析。

查询分析
^^^^^^^^^^^^^^^^

有时仅通过 SQL 日志记录（使用 Python 的 logging 模块或通过 :func:`_sa.create_engine` 的 ``echo=True`` 参数启用）就可以了解操作花费的时间多久。例如，如果在 SQL 操作之后记录了一些内容，您将在日志中看到：

.. sourcecode:: text

    17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...
    17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {<params>}
    17:37:48,660 DEBUG [myapp.somemessage]

如果在操作之后记录了 ``myapp.somemessage``，则知道在 SQL 部分完成了耗时为 334ms 的操作。

日志记录 SQL 还将说明是否正在发出几十个/数百个查询，这些查询可以更好地组织成更少的查询。当使用 SQLAlchemy ORM 时，“急加载”功能部分地 (:func:`.contains_eager()`) 或完全地 (:func:`_orm.joinedload()`, :func:`.subqueryload()`) 自动执行此操作，但是没有 ORM 的“急加载”往往意味着使用联接，以便在加载多个表的结果时可以在一个结果集中加载，而不是增加更多深度的查询（即 ``r + r*r2 + r*r2*r3`` ...）。

对于更长期的查询分析，或实现应用程序端“缓慢查询”监视器，可以使用事件拦截光标执行，使用以下脚本：

    from sqlalchemy import event
    from sqlalchemy.engine import Engine
    import time
    import logging

    logging.basicConfig()
    logger = logging.getLogger("myapp.sqltime")
    logger.setLevel(logging.DEBUG)


    @event.listens_for(Engine, "before_cursor_execute")
    def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
        conn.info.setdefault("query_start_time", []).append(time.time())
        logger.debug("Start Query: %s", statement)


    @event.listens_for(Engine, "after_cursor_execute")
    def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
        total = time.time() - conn.info["query_start_time"].pop(-1)
        logger.debug("Query Complete!")
        logger.debug("Total Time: %f", total)

上面，我们使用 :meth:`_events.ConnectionEvents.before_cursor_execute` 和 :meth:`_events.ConnectionEvents.after_cursor_execute` 事件在语句执行时建立拦截点。我们使用 :class:`._ConnectionRecord.info` 字典为连接附加一个计时器；我们在这里使用一个堆栈，以便极少数情况下光标执行事件可能会嵌套。

.. _faq_code_profiling:

代码分析
^^^^^^^^^^^^^^^^

如果记录显示个别查询花费的时间过长，则需了解在数据库内部处理查询、通过网络发送结果、由 :term:`DBAPI` 处理以及最终由 SQLAlchemy 的结果集和/或 ORM 层处理时花费的时间量，每个阶段都可以根据具体情况产生自己的个别瓶颈。

为此，您需要使用“Python 分析模块”。下面是一个简单的配方，可将性能分析嵌入上下文管理器中：

    import cProfile
    import io
    import pstats
    import contextlib


    @contextlib.contextmanager
    def profiled():
        pr = cProfile.Profile()
        pr.enable()
        yield
        pr.disable()
        s = io.StringIO()
        ps = pstats.Stats(pr, stream=s).sort_stats("cumulative")
        ps.print_stats()
        # unc
        # omment this to see who's calling what
        # ps.print_callers()
        print(s.getvalue())

要对代码部分进行性能分析：

    with profiled():
        session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()

分析输出可用于了解时间花在哪里。下面是分析输出的一部分：

.. sourcecode:: text

    13726 function calls (13042 primitive calls) in 0.014 seconds

    Ordered by: cumulative time

    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)
    220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)
    220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)
       20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)
       20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)
        1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)
       21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(<genexpr>)
        2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)
        2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)

…

    在上面，我们看到 ``instances()`` SQLAlchemy 函数被调用了 222 次（递归调用，外部有 21 次），在所有调用中花费了 .011 秒的时间。

执行缓慢
^^^^^^^^^^^^^^^^

其所具体调用的底层部分可以告诉我们时间花费在哪里。例如，如果您看到时间花费在 ``cursor.execute()`` 上，例如针对 DBAPI：

.. sourcecode:: text

    2    0.102    0.102    0.204    0.102 {method 'execute' of 'sqlite3.Cursor' objects}

这表明数据库花费了很长时间来开始返回结果，这意味着您的查询应以添加索引或重组查询和/或基础架构的方式进行优化。为此，应使用查询计划等系统，如 EXPLAIN、SHOW PLAN 等提供的系统。

结果获取速度缓慢-Core
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

另一方面，如果您看到数千次与提取行相关的调用，或者对 ``fetchall()`` 有非常长的调用，这可能意味着查询返回的行数比预期的多，或者在获取行本身方面很慢。 ORM 本身通常使用 ``fetchall()`` 提取行（或者如果使用了 :meth:`_query.Query.yield_per` 选项，则使用 ``fetchmany()``）。

大量行的存在会通过 DBAPI 级别的非常缓慢的调用 ``fetchall()`` 表示出来：

.. sourcecode:: text

    2    0.300    0.600    0.300    0.600 {method 'fetchall' of 'sqlite3.Cursor' objects}

即使结果看起来没有很多行，如果返回的行数出乎意料地大，则可能是由于多个行集组合在一起，而没有适当地将表连接在一起引起的。使用 SQLAlchemy Core 或 ORM 查询，在复杂查询中使用错误的 :class:`_schema.Column` 对象将会导入预期之外的额外 FROM 子句。

另一方面，在 DBAPI 级别的快速调用 ``fetchall()`` 之后，当 SQLAlchemy 的 :class:`_engine.CursorResult` 被要求进行 ``fetchall()`` 时，表明处理数据类型（例如 Unicode 转换等）的速度缓慢。

在这种情况下，确保查看已知性能调整建议的 :ref:`方言文档 <dialect_toplevel>`，尤其是对于像 Oracle 这样的数据库。可能存在与确保数值精度或字符串处理相关的系统，这些系统在所有情况下可能都不受需要。

在提取行合成性能的更低级别点中可能还存在更多的问题；例如，如果花费的时间似乎集中在像 ``socket.receive()`` 这样的调用中，这可能表明除网络连接之外的一切都很快，花费过多的时间是在数据移动过程中。

结果获取速度缓慢-ORM
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

为检测 ORM 获取行的速度缓慢（这是最常见的性能问题），可以类似下面的例子，为每个 ORM 加载的行调用 ``populate_state()`` 和 ``_instance()`` 函数以说明：

.. sourcecode:: text

    # ORM 在看到每个 ORM 加载的行时会调用 _instance，
    # 对于 ORM 加载的行结果导致对象属性的填充，会调用 populate_state。
    220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)
    220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)

ORM 将行转换为 ORM 映射对象的缓慢，是由于此操作的复杂性与 cPython 的开销共同作用的结果。减轻这种情况的常见策略包括：

* 仅获取单个列，而不是完整实体，即：

      select(User.id, User.name)

  而不是：

      select(User)

* 使用 :class:`.Bundle` 对象组织基于列的结果：

      u_b = Bundle("user", User.id, User.name)
      a_b = Bundle("address", Address.id, Address.email)

      for user, address in session.execute(select(u_b, a_b).join(User.addresses)):
          ...

* 使用结果缓存-有关此功能的全面示例，请参阅 :ref:`例子缓存`。

* 考虑使用像 PyPy 这样更快的解释器。

分析的输出可能有些令人生畏，但经过一些练习后，它们很容易阅读。

.. seealso::

    :ref:`examples_performance` -一套带有捆绑的性能演示和性能分析能力。

我正在使用 ORM 插入 400,000 行，这很慢！
--------------------------------------------

由 ORM 插入的性质已更改，因为随着SQLAlchemy 2.0 的发布，除 MySQL 外的大多数内置驱动程序都支持具有 :ref:`insertmanyvalues <engine_insertmanyvalues>` 支持的 RETURNING 语句。有关详细信息，请参见 :ref:`change_6047` 部分。

整体而言，除 MySQL 外的 SQLAlchemy 内置驱动程序现在应该提供非常快的 ORM 大块插入性能。

第三方驱动程序可以通过进行一些小的代码更改来选择新的大块基础架构，假设它们的后端支持必要的语法。SQLAlchemy 开发人员鼓励第三方方言的用户发布这些驱动程序的问题，以便他们可以联系 SQLAlchemy 开发人员寻求帮助。