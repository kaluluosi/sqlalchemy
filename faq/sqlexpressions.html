<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    SQL表达式
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="常见问题解答" href="index.html" />
        <link rel="next" title="ORM配置" href="ormconfiguration.html" />
        <link rel="prev" title="元数据/模式" href="metadata_schema.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="常见问题解答">常见问题解答</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="installation.html">安装</a></span></li>
<li><span class="link-container"><a class="reference external" href="connections.html">连接/引擎</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata_schema.html">元数据/模式</a></span></li>
<li class="selected"><span class="link-container"><strong>SQL表达式</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#faq-sql-expression-string">如何将SQL表达式呈现为字符串，可能带有内联的绑定参数？</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id2">特定数据库的字符串呈现</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id3">内联绑定参数呈现</a></span></li>
<li><span class="link-container"><a class="reference external" href="#postcompile">将 “POSTCOMPILE” 参数呈现为绑定参数</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#faq-sql-expression-percent-signs">为什么字符串化SQL语句时百分号会被双倍？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#op">我正在使用 op() 生成自定义操作符，但是我的括号没有正确显示</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id15">为什么括号规则是这样的？</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="ormconfiguration.html">ORM配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="performance.html">性能</a></span></li>
<li><span class="link-container"><a class="reference external" href="sessions.html">会话/查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="thirdparty.html">第三方集成问题</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="metadata_schema.html" title="previous chapter">元数据/模式</a></li>
                <li><b>Next:</b>
                <a href="ormconfiguration.html" title="next chapter">ORM配置</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="常见问题解答">常见问题解答</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#sql">SQL表达式</a><ul>
<li><a class="reference internal" href="#faq-sql-expression-string">如何将SQL表达式呈现为字符串，可能带有内联的绑定参数？</a><ul>
<li><a class="reference internal" href="#id2">特定数据库的字符串呈现</a></li>
<li><a class="reference internal" href="#id3">内联绑定参数呈现</a></li>
<li><a class="reference internal" href="#postcompile">将 “POSTCOMPILE” 参数呈现为绑定参数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#faq-sql-expression-percent-signs">为什么字符串化SQL语句时百分号会被双倍？</a></li>
<li><a class="reference internal" href="#op">我正在使用 op() 生成自定义操作符，但是我的括号没有正确显示</a><ul>
<li><a class="reference internal" href="#id15">为什么括号规则是这样的？</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar faq-sqlexpressions" >
        
<section id="sql">
<h1>SQL表达式<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h1>
<section id="faq-sql-expression-string">
<span id="id1"></span><h2>如何将SQL表达式呈现为字符串，可能带有内联的绑定参数？<a class="headerlink" href="#faq-sql-expression-string" title="Permalink to this heading">¶</a></h2>
<p>在大多数简单情况下，将SQLAlchemy核心语句对象或ORM的“stringification”  <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> 对象或
表达式片段和其他任何表达式片段呈现为字符串的方法是非常简单的，只需使用``str()``内置函数即可，
例如当使用它与 <code class="docutils literal notranslate"><span class="pre">print</span></code> 函数（请注意，如果不显示调用 <cite>str()</cite>，Python的`print`函数也会自动调用它）：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statement</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">str</span><span class="p">(</span><span class="n">statement</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="n">x</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span>
</div></pre></div>
</div>
<p>对于ORM的  <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> ，  :func:` _expression.insert`等）
以及任何表达式片段，都可以调用``str()``内置函数或等效函数：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;some value&quot;</span><span class="p">)</span>
<div class='show_sql_print'><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">x_1</span>
</div></pre></div>
</div>
<section id="id2">
<h3>特定数据库的字符串呈现<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>当要将要呈现为字符串的语句包含具有特定于数据库的字符串格式的元素时，
或者当包含元素仅在某一种类型的数据库中才可用时，就会产生问题。
在这些情况下，我们可能会得到一个字符串化的语句，该语句不符合我们目标的数据库的正确语法，
或者该操作可能会引发  <a class="reference internal" href="../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError" title="sqlalchemy.exc.UnsupportedCompilationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnsupportedCompilationError</span></code></a> 异常。在这些情况下，我们需要使用</p>
<blockquote>
<div><p><a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile" title="sqlalchemy.sql.expression.ClauseElement.compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.compile()</span></code></a>  方法将语句字符串化，同时传递一个代表目标数据库的
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> .Dialect` 对象。例如，如果我们有一个MySQL数据库引擎，</p>
</div></blockquote>
<p>我们可以使用以下方法将语句字符串化为MySQL方言:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql+pymysql://scott:tiger@localhost/test&quot;</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="n">statement</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span></pre></div>
</div>
<p>可以直接使用 <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> 对象，如下例所示，我们使用PostgreSQL方言:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span>

<span class="n">print</span><span class="p">(</span><span class="n">statement</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span></pre></div>
</div>
<p>请注意，任何方言都可以使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code>  本身来组装，
使用虚拟URL，然后访问 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Engine.dialect</span></code> 属性，例如，
如果我们想要一个psycopg2的方言对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://&quot;</span><span class="p">)</span>
<span class="n">psycopg2_dialect</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">dialect</span></pre></div>
</div>
<p>当给定ORM的  <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> ，要访问  :meth:` _expression.ClauseElement.compile`
方法，我们只需要首先访问 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Query.statement</span></code> 访问器：</p>
<blockquote>
<div><p>statement = query.statement
print(statement.compile(someengine))</p>
</div></blockquote>
</section>
<section id="id3">
<h3>内联绑定参数呈现<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a href="#id4"><span class="problematic" id="id5">**</span></a>决不要**在不可信的输入（例如来自Web表单或其他用户输入应用程序的字符串内容）中使用这些技术。</p>
</div>
<p>SQLAlchemy的将Python值转换为直接SQL字符串值的工具对来自不可信输入的数据 <strong>不安全且不验证传递的数据类型</strong>。在与关系数据库
编程调用非DDL SQL语句时，始终使用绑定参数。</p>
<p>上面的形式将呈现SQL语句传递给Python <span class="xref std std-term">DBAPI</span> 时，包括未呈现内联的绑定参数。
SQLAlchemy通常不会将绑定参数字符串化，这由Python DBAPI适当处理，更不用说绕过绑定参数可能是现代Web应用程序中最常被利用的安全漏洞。
在检查DDL发射的情况下，SQLAlchemy具有以下所述的这种字符串化功能的有限能力。为了访问此功能，可以使用传递给``compile_kwargs``的
<a href="#id6"><span class="problematic" id="id7">``</span></a>literal_binds``标志：</p>
<blockquote>
<div><p>from sqlalchemy.sql import table, column, select</p>
<p>t = table(“t”, column(“x”))</p>
<p>s = select(t).where(t.c.x == 5)</p>
<p># <strong>不要在受信任的输入之外使用</strong>！
print(s.compile(compile_kwargs={“literal_binds”: True}))</p>
<p># 为特定方言呈现
print(s.compile(dialect=dialect, compile_kwargs={“literal_binds”: True}))</p>
<p># 或者，如果您有一个Engine，请作为第一个参数传递
print(s.compile(some_engine, compile_kwargs={“literal_binds”: True}))</p>
</div></blockquote>
<p>此功能主要用于记录或调试的目的，获取查询的原始SQL字符串可能证明有用。</p>
<p>上述方法的注意事项是它仅支持基本类型，例如整数和字符串，而且如果直接使用   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a>  而没有预设值，也无法将其字符串化。
无条件地字符串化所有参数的方法如下所述。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>SQLAlchemy不支持完全字符串序列化所有数据类型的原因归结为以下三点：</p>
<ol class="arabic simple">
<li><p>当正常使用DBAPI时，该DBAPI已经支持此功能。SQLAlchemy项目不能负责为每种后端复制所有数据类型的重复性工作，并且这是多余的工作，还会
带来显着的测试和持续支持开销。</p></li>
<li><p>呈现特定数据库的绑定的完全字符串化暗示了一种用法，即实际将这些完全字符串化的语句传递到数据库进行执行。这是不必要和不安全的，
SQLAlchemy不希望以任何方式鼓励此使用方式。</p></li>
<li><p>文字值呈现领域最可能发现安全问题。SQLAlchemy尽量使安全的参数字符串化领域尽可能成为DBAPI驱动程序的问题，其中每个DBAPI的具体信息可以得到适当和安全的处理。</p></li>
</ol>
</div>
<p>由于意图不支持完全字符串化文字值，因此在特定调试场景下执行此操作的技术包括以下内容。以PostgreSQL   <code class="xref py py-class docutils literal notranslate"><span class="pre">UUID</span></code>  数据类型为例：</p>
<blockquote>
<div><p>import uuid</p>
<p>from sqlalchemy import Column
from sqlalchemy import create_engine
from sqlalchemy import Integer
from sqlalchemy import select
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_base</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)
data = Column(UUID)</p>
</dd>
</dl>
<p>stmt = select(A).where(A.data == uuid.uuid4())</p>
</div></blockquote>
<p>在上面的模型和语句中，将列与单个UUID值进行比较，包含内联值的SQL语句呈现选项包括：</p>
<ul>
<li><p>一些DBAPI（例如psycopg2）支持像 <a href="#id16"><span class="problematic" id="id17">`mogrify()&lt;https://www.psycopg.org/docs/cursor.html#cursor.mogrify&gt;`_</span></a> 这样的辅助函数，
提供了在它们的文字网格填充中使用的字面量渲染功能。要使用此类功能，请渲染SQL字符串而不使用
<code class="docutils literal notranslate"><span class="pre">literal_binds</span></code>，并通过 <a class="reference internal" href="../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params" title="sqlalchemy.sql.compiler.SQLCompiler.params"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SQLCompiler.params</span></code></a> 访问参数本身:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">e</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">compiled</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="n">print</span><span class="p">(</span><span class="n">cursor</span><span class="o">.</span><span class="n">mogrify</span><span class="p">(</span><span class="n">str</span><span class="p">(</span><span class="n">compiled</span><span class="p">),</span> <span class="n">compiled</span><span class="o">.</span><span class="n">params</span><span class="p">))</span></pre></div>
</div>
<p>上述代码将产生psycopg2的原始字节串：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="ss">&quot;SELECT a.id, a.data \nFROM a \nWHERE a.data = &#39;a511b0fc-76da-4c47-a4b4-716a8189b7ac&#39;::uuid&quot;</span></pre></div>
</div>
</li>
<li><p>Render the  <a class="reference internal" href="../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params" title="sqlalchemy.sql.compiler.SQLCompiler.params"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SQLCompiler.params</span></code></a>  直接插入语句中，使用目标DBAPI的与` paramstyle &lt;<a class="reference external" href="https://www.python.org/dev/peps/pep-0249/#paramstyle">https://www.python.org/dev/peps/pep-0249/#paramstyle</a>&gt;`_相对应的
样式。例如，psycopg2 DBAPI使用命名的 <code class="docutils literal notranslate"><span class="pre">pyformat</span></code> 样式。<a href="#id8"><span class="problematic" id="id9">``</span></a>render_postcompile``的含义将在下一部分中讨论。<strong>警告**此时**不安全，不要使用不可信、无限制的输入</strong>：</p>
<blockquote>
<div><p>e = create_engine(“postgresql+psycopg2://”)</p>
<p># Will use pyformat style, i.e. %(paramname)s for param.
compiled = stmt.compile(e, compile_kwargs={“render_postcompile”: True})</p>
<p>print(str(compiled) % compiled.params)</p>
</div></blockquote>
<p>这将生成一个不工作的字符串，尽管适合调试：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="n">eec1209</span><span class="o">-</span><span class="mi">50</span><span class="n">b4</span><span class="o">-</span><span class="mi">4253</span><span class="o">-</span><span class="n">b74b</span><span class="o">-</span><span class="n">f82461ed80c1</span></pre></div>
</div>
<p>另一个例子是使用qmark之类的位置参数样式，我们可以通过还使用  <code class="xref py py-attr docutils literal notranslate"><span class="pre">SQLCompiler.lineterminator</span></code>  、  :attr:` .SQLCompiler.positional`  ，以便组合渲染线上参数到一个字符串（线上参数是  <a class="reference internal" href="../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup" title="sqlalchemy.sql.compiler.SQLCompiler.positiontup"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SQLCompiler.positiontup</span></code></a>  集合， 处理时默认是呈现为未绑定参数，这样它们在生成的SQL字符串中将不会得到引用）。示例适用于使用SQLite的情况：</p>
<blockquote>
<div><p>import re</p>
<p>e = create_engine(“sqlite+pysqlite://”)</p>
<p># 接受qmark style, i.e. ? for param
compiled = stmt.compile(e, compile_kwargs={“render_postcompile”: True})</p>
<p># 确定语句的绑定参数的项的位置
params = (repr(compiled.params[name]) for name in compiled.positiontup)</p>
<p>print(re.sub(r”?”, lambda m: next(params), str(compiled)))</p>
</div></blockquote>
<p>上述片段打印：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UUID</span><span class="p">(</span><span class="s1">&#39;1bd70375-db17-4d8c-94f1-fc2ef3aada26&#39;</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p>使用   <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span>  扩展在具有自定义计算时呈现   :class:` _sql.BindParameter`  对象的方式在用户定义的标志存在时，来自编译器的自定义方式。该标志通过类似于其他标志的编译器_kwargs字典发送：</p>
<blockquote>
<div><p>from sqlalchemy.ext.compiler import compiles
from sqlalchemy.sql.expression import BindParameter</p>
<p>&#64;compiles(BindParameter)
def _render_literal_bindparam(element, compiler, use_my_literal_recipe=False, <a href="#id10"><span class="problematic" id="id11">**</span></a>kw):</p>
<blockquote>
<div><dl class="simple">
<dt>if not use_my_literal_recipe:</dt><dd><p># 使用正常的bindparam处理
return compiler.visit_bindparam(element, <a href="#id12"><span class="problematic" id="id13">**</span></a>kw)</p>
</dd>
</dl>
<p># 如果在compiler_kwargs中传递了use_my_literal_recipe，将值直接渲染出来
return repr(element.value)</p>
</div></blockquote>
<p>e = create_engine(“postgresql+psycopg2://”)
print(stmt.compile(e, compile_kwargs={“use_my_literal_recipe”: True}))</p>
</div></blockquote>
</li>
</ul>
<p>上面的配方将打印：</p>
<blockquote>
<div><div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UUID</span><span class="p">(</span><span class="s1">&#39;47b154cd-36b2-42ae-9718-888629ab9857&#39;</span><span class="p">)</span></pre></div>
</div>
</div></blockquote>
<ul>
<li><p>对于内建到模型或语句中的类型特定字符串化，可以使用   <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>  类提供  :meth:` .TypeDecorator.process_literal_param`  方法自定义任何数据类型的字符串化方式。</p>
<p>示例数据类型需要在模型中显式使用，或者在语句中使用   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a>  本地模拟，例如：</p>
<blockquote>
<div><p>from sqlalchemy import type_coerce</p>
<p>stmt = select(A).where(type_coerce(A.data, UUIDStringify) == uuid.uuid4())</p>
<p>print(stmt.compile(e, compile_kwargs={“literal_binds”: True}))</p>
</div></blockquote>
<p>会再次打印同样的表达式：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UUID</span><span class="p">(</span><span class="s1">&#39;47b154cd-36b2-42ae-9718-888629ab9857&#39;</span><span class="p">)</span></pre></div>
</div>
</li>
</ul>
</section>
<section id="postcompile">
<h3>将 “POSTCOMPILE” 参数呈现为绑定参数<a class="headerlink" href="#postcompile" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy包括一种变体的绑定参数，称为  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">BindParameter.expanding</span></code></a> ，它是一种“延迟评估”的参数，当SQL构造被编译时，它呈现在中间状态，
然后在语句执行时进一步处理已知的实际值。类似这种结构的”id in […]”使用可以在SQL字符串在实际列表值无关的情况下安全地缓存：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">in_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span></pre></div>
</div>
<p>要将IN子句呈现为实际的绑定参数符号，请使用 <code class="docutils literal notranslate"><span class="pre">render_postcompile=True</span></code> 标志与  <a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile" title="sqlalchemy.sql.expression.ClauseElement.compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ClauseElement.compile()</span></code></a> ：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;render_postcompile&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">id_1_1</span><span class="p">)</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">id_1_2</span><span class="p">)</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">id_1_3</span><span class="p">)</span><span class="n">s</span><span class="p">)</span>
</div></pre></div>
</div>
<p>在前面呈现绑定参数的形式的示例中，<code class="docutils literal notranslate"><span class="pre">literal_binds``标志（描述呈现绑定参数的形式）会自动将</span> <span class="pre">``render_postcompile</span></code> 标志设置为True，这样对于只有简单的整数/字符串数的语句，可以直接呈现它们：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go"># render_postcompile是文字绑定的意味着</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;literal_binds&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="p">:</span><span class="n">attr</span><span class="p">:</span><span class="o">`</span><span class="p">.</span><span class="n">SQLCompiler</span><span class="p">.</span><span class="n">params</span><span class="o">`</span><span class="w">   </span><span class="err">和</span><span class="w">  </span><span class="p">:</span><span class="n">attr</span><span class="p">:</span><span class="o">`</span><span class="w"> </span><span class="p">.</span><span class="n">SQLCompiler</span><span class="p">.</span><span class="n">positiontup</span><span class="o">`</span><span class="w">  </span><span class="err">也可以与</span><span class="w"> </span><span class="o">``</span><span class="n">render_postcompile</span><span class="o">``</span><span class="err">兼容，因此在这里呈现内联绑定参数的先前配方，就以同样的方式起作用，例如在</span><span class="n">SQLite的位置形式</span><span class="err">：</span>
</div></pre></div>
</div>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">(),</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">(),</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">u3</span><span class="p">]))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite+pysqlite://&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compiled</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;render_postcompile&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">repr</span><span class="p">(</span><span class="n">compiled</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">compiled</span><span class="o">.</span><span class="n">positiontup</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\?&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">next</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">compiled</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="n">UUID</span><span class="p">(</span><span class="s1">&#39;aa1944d6-9a5a-45d5-b8da-0ba1ef0a4f38&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">UUID</span><span class="p">(</span><span class="s1">&#39;a81920e6-15e2-4392-8a3c-d775ffa9ccd2&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">UUID</span><span class="p">(</span><span class="s1">&#39;b5574cdb-ff9b-49a3-be52-dbc89f087bfa&#39;</span><span class="p">))</span>
</div></pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>记住，上述所有字面量值字符串化的代码配方，是在**仅用于**以下情况：</p>
<ol class="arabic simple">
<li><p>使用了 <strong>仅供调试</strong> 的目的</p></li>
<li><p>字符串 <strong>不会被传递到生产数据库</strong></p></li>
<li><p>只用于 <strong>本地、信任的输入</strong></p></li>
</ol>
<p>上述呈现字面值的配方为**任何情况**都不安全，绝不应在生产数据库上使用。</p>
</div>
</section>
</section>
<section id="faq-sql-expression-percent-signs">
<span id="id14"></span><h2>为什么字符串化SQL语句时百分号会被双倍？<a class="headerlink" href="#faq-sql-expression-percent-signs" title="Permalink to this heading">¶</a></h2>
<p>许多DBAPI实现使用 <code class="docutils literal notranslate"><span class="pre">pyformat</span></code> 或 <code class="docutils literal notranslate"><span class="pre">format</span></code> <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/#paramstyle">paramstyle</a> ，这些实现必然涉及到其语法中的百分号。
大多数在工作中使用此功能的DBAPI期望在使用有其他含义的百分号时将百分号加倍（即转义），例如：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">%</span><span class="n">s</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">%</span><span class="n">s</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="n">modulus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span></pre></div>
</div>
<p>当SQLAlchemy将语句传递给底层DBAPI时，绑定参数的替换方式与Python字符串插值操作符``%``相同，在许多情况下，实际上DBAPI直接使用此运算符。
在前面的示例中，绑定参数的替换如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">sourcecode</span><span class="p">::</span> <span class="n">sql</span></pre></div>
</div>
<blockquote>
<div><p>SELECT a, b FROM some_table WHERE a = 5 AND c = 10 AND num % modulus = 0</p>
</div></blockquote>
<p>如PostgreSQL（默认DBAPI是psycopg2）和MySQL（默认DBAPI是mysqlclient）这样的数据库的默认编译器遵循此百分号转义行为：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;value </span><span class="si">% o</span><span class="s2">ne&quot;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;value % two&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="ss">&quot;value %% one&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="ss">&quot;value %% two&quot;</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span>
</div></pre></div>
</div>
<p>在使用这种方言时，如果希望获取不包含绑定参数符号的非-DBAPI语句，其中一个快速的方法是使用Python的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 操作符将其替换为空参数集：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strstmt</span> <span class="o">=</span> <span class="n">str</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">strstmt</span> <span class="o">%</span> <span class="p">())</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="ss">&quot;value % one&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="ss">&quot;value % two&quot;</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span>
</div></pre></div>
</div>
<p>另一个选择是在正在编译的方言中设置不同的参数样式；所有   <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a>  实现都支持一个参数
<code class="docutils literal notranslate"><span class="pre">paramstyle</span></code> ，它将导致该 dialect 的编译器使用给定的参数样式。例如，设置PostgreSQL dialet中使用广泛的``named``参数样式（$paramname）的dialect：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">(</span><span class="n">paramstyle</span><span class="o">=</span><span class="s2">&quot;named&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="ss">&quot;value % one&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_table</span><span class="p">.</span><span class="ss">&quot;value % two&quot;</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span>
</div></pre></div>
</div>
</section>
<section id="op">
<span id="faq-sql-expression-op-parenthesis"></span><h2>我正在使用 op() 生成自定义操作符，但是我的括号没有正确显示<a class="headerlink" href="#op" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op" title="sqlalchemy.sql.expression.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a>   方法允许创建 SQLAlchemy 不知道的自定义数据库操作符：</p>
</div></blockquote>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="n">q</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">p</span>
</div></pre></div>
</div>
<p>然而，当在复合表达式的右侧使用它时，它不会产生我们期望的括号：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">((</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q1&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;q2&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="n">q1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">p</span>
</div></pre></div>
</div>
<p>在上面的例子中，我们可能希望得到 <code class="docutils literal notranslate"><span class="pre">(q1</span> <span class="pre">+</span> <span class="pre">q2)</span> <span class="pre">-&gt;</span> <span class="pre">p</span></code>。</p>
<p>这种情况的解决方案是，使用  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence" title="sqlalchemy.sql.expression.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.precedence</span></code></a>  参数，将操作符的优先级设置为较高的数字，其中100是最大值，
SQLAlchemy当前使用任何操作符中的最高数字为15：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">((</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q1&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;q2&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">precedence</span><span class="o">=</span><span class="mi">100</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="p">(</span><span class="n">q1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">p</span>
</div></pre></div>
</div>
<p>通常，我们也可以使用  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.self_group" title="sqlalchemy.sql.expression.ColumnElement.self_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.self_group()</span></code></a>  方法强制将二进制表达式(例如拥有左/右操作数和运算符的表达式)括在括号内:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">((</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q1&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;q2&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="p">(</span><span class="n">q1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">p</span>
</div></pre></div>
</div>
<section id="id15">
<h3>为什么括号规则是这样的？<a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<p>许多数据库在存在过多括号或括号位于不寻常的位置时都会失败，
因此 SQLAlchemy 不基于分组生成括号，它使用运算符优先级和如果运算符已知是可结合的，
也会生成最少量的括号。 否则，在表达式如下的情况下，留给数据库的表达式将会更易混淆或者至少会影响可读性：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go">column(&quot;a&quot;) &amp; column(&quot;b&quot;) &amp; column(&quot;c&quot;) &amp; column(&quot;d&quot;)</span></pre></div>
</div>
<p>在其他情况下，会导致更有可能混淆数据库或至少使读取困难，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">))[</span><span class="mi">5</span><span class="p">][</span><span class="mi">6</span><span class="p">]</span></pre></div>
</div>
<p>会给生成的SQL语句加更多的括号，如(:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">])[</span><span class="mi">6</span><span class="p">])</span></pre></div>
</div>
<p>还有一些边缘情况，其中我们得到像“（x）=7”这样的语句，数据库也不会真正喜欢。因此，
括号不使用组合深度，而是使用运算符优先级和关联性来确定分组关系。</p>
<p>对于  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op" title="sqlalchemy.sql.expression.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a> ，优先级的值默认为零。</p>
<p>如果我们将  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence" title="sqlalchemy.sql.expression.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.precedence</span></code></a>  的值默认为100，即最高值，例如：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">((</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">precedence</span><span class="o">=</span><span class="mi">100</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">((</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="n">q</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span>
</div></pre></div>
</div>
<p>但这两个不会：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">precedence</span><span class="o">=</span><span class="mi">100</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="n">q</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="n">q</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
</div></pre></div>
</div>
<p>到目前为止，似乎不确定是否有一种方法格外括号化自动生成的操作符来自动处理通用操作符的情况，在没有给出优先级的情况下，
同时对于在其他情况下仍重要的现有运算符也可能需要更具体的括号罗辑。这种变化可能可以在某个时候完成，
但是在当前，保持括号化规则的内部一致性似乎是更安全的方法。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="metadata_schema.html" title="previous chapter">元数据/模式</a>
        Next:
        <a href="ormconfiguration.html" title="next chapter">ORM配置</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:58:53

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


