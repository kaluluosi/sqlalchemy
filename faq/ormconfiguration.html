<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    ORM配置
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="常见问题解答" href="index.html" />
        <link rel="next" title="性能" href="performance.html" />
        <link rel="prev" title="SQL表达式" href="sqlexpressions.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="常见问题解答">常见问题解答</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="installation.html">安装</a></span></li>
<li><span class="link-container"><a class="reference external" href="connections.html">连接/引擎</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata_schema.html">元数据/模式</a></span></li>
<li><span class="link-container"><a class="reference external" href="sqlexpressions.html">SQL表达式</a></span></li>
<li class="selected"><span class="link-container"><strong>ORM配置</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#faq-mapper-primary-key">如何映射没有主键的表？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python">如何配置为 Python 保留字或类似的列？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id3">如何获取给定映射类的所有列，关系，映射属性等的列表？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#x-y">我收到有关“隐式组合列 X 在属性 Y 下”的警告或错误消息</a></span></li>
<li><span class="link-container"><a class="reference external" href="#limit-subqueryload-order-by">为什么建议使用带有“LIMIT”（特别是使用“subqueryload()”）的“ORDER BY”？</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="performance.html">性能</a></span></li>
<li><span class="link-container"><a class="reference external" href="sessions.html">会话/查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="thirdparty.html">第三方集成问题</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="sqlexpressions.html" title="previous chapter">SQL表达式</a></li>
                <li><b>Next:</b>
                <a href="performance.html" title="next chapter">性能</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="常见问题解答">常见问题解答</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#orm">ORM配置</a><ul>
<li><a class="reference internal" href="#faq-mapper-primary-key">如何映射没有主键的表？</a></li>
<li><a class="reference internal" href="#python">如何配置为 Python 保留字或类似的列？</a></li>
<li><a class="reference internal" href="#id3">如何获取给定映射类的所有列，关系，映射属性等的列表？</a></li>
<li><a class="reference internal" href="#x-y">我收到有关“隐式组合列 X 在属性 Y 下”的警告或错误消息</a></li>
<li><a class="reference internal" href="#limit-subqueryload-order-by">为什么建议使用带有“LIMIT”（特别是使用“subqueryload()”）的“ORDER BY”？</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar faq-ormconfiguration" >
        
<section id="orm">
<h1>ORM配置<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h1>
<section id="faq-mapper-primary-key">
<span id="id1"></span><h2>如何映射没有主键的表？<a class="headerlink" href="#faq-mapper-primary-key" title="Permalink to this heading">¶</a></h2>
<p>为了映射到特定的表，SQLAlchemy ORM 至少需要有一个标为主键的列；
多列即复合主键当然也是可行的。这些列不必实际上被数据库识别为主键列，
不过最好是这样。 唯一需要的是这些列的行为与主键相同，
例如它们应该是行的唯一标识符并且不可以为空。</p>
<p>大多数 ORM 需要定义某种主键，因为内存中的对象必须对应于唯一标识的数据库表的行；
至少，这允许只影响该对象的行的 UPDATE 和 DELETE 语句。 然而，主键的重要性
远远超出此。在 SQLAlchemy 中，所有 ORM 映射的对象始终通过一个称为</p>
<blockquote>
<div><p><span class="xref std std-term">identity map</span>   的模式与其特定数据库行唯一链接在一起，</p>
</div></blockquote>
<p>这是 SQLAlchemy 使用的工作单元系统的核心模式，也是 ORM 用法的最常见（和不常见的）模式之一。</p>
<p>几乎所有情况下，表都有所谓的  <span class="xref std std-term">候选键</span> ，这是唯一标识行的一列或多列。
如果表确实没有这个，而且具有实际上完全重复的行，则表不符合 <a class="reference external" href="https://en.wikipedia.org/wiki/First_normal_form">第一正规化</a>
并且无法映射。 否则，组成最佳候选键的任何列都可以应用于映射器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">some_table_with_no_pk</span>
        <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;primary_key&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">some_table_with_no_pk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">some_table_with_no_pk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">bar</span><span class="p">]</span>
    <span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>更好地使用完全声明的表元数据时，在这些列上使用 <code class="docutils literal notranslate"><span class="pre">primary_key=True</span></code> 标记：</p>
<blockquote>
<div><dl>
<dt>class SomeClass(Base):</dt><dd><p>__tablename__ = “some_table_with_no_pk”</p>
<p>uid = Column(Integer, primary_key=True)
bar = Column(String, primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
<p>关系数据库中的所有表都应该具有主键。即使是多对多的关联表，
主键也将是两个关联列的组合：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">my_association</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">user_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
<span class="w">  </span><span class="n">account_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">account</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">account_id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
</section>
<section id="python">
<h2>如何配置为 Python 保留字或类似的列？<a class="headerlink" href="#python" title="Permalink to this heading">¶</a></h2>
<p>映射时基于列的属性可以被赋予任何所需的名称。请参见   <span class="xref std std-ref">mapper_column_distinct_names</span> 。</p>
</section>
<section id="id3">
<h2>如何获取给定映射类的所有列，关系，映射属性等的列表？<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>所有这些信息都可以从   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>  对象中获得。</p>
<p>要获取特定映射类的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code> ，请在其上调用   <a class="reference internal" href="../core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a>  函数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">inspect</span>

<span class="n">mapper</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span></pre></div>
</div>
<p>从那里，可以通过属性访问有关类的所有信息，例如：</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.attrs</span></code>  - 所有映射属性的名称空间。属性本身是   <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.MapperProperty" title="sqlalchemy.orm.MapperProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">MapperProperty</span></code></a>  的实例，如果适用，</p></li>
</ul>
<blockquote>
<div><p>它们包含可导致映射的 SQL 表达式或列的其他属性。</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.column_attrs</span></code>  - 映射属性名称空间</p></li>
</ul>
<p>涵盖列和SQL 表达式属性。您可能希望使用  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.columns</span></code>  直接获取   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象。</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.relationships</span></code>  - 所有关系属性的名称空间。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.all_orm_descriptors</span></code>  - 所有映射属性的名称空间，以及使用诸如   <a class="reference internal" href="../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property" title="sqlalchemy.ext.hybrid.hybrid_property"><code class="xref py py-class docutils literal notranslate"><span class="pre">hybrid_property</span></code></a> 、</p></li>
</ul>
<blockquote>
<div><p><a class="reference internal" href="../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy" title="sqlalchemy.ext.associationproxy.AssociationProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">AssociationProxy</span></code></a>  等系统定义的用户定义属性。</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.columns</span></code>  - 用于映射的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象和其他命名 SQL 表达式的名称空间。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.mapped_table</span></code>  - 此映射器所映射到的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  或其他可选择项。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.local_table</span></code>  - 与此映射器“本地”的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> ;</p></li>
</ul>
<blockquote>
<div><p>在使用继承将映射器映射到复合可选择项的情况下，这与  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.mapped_table</span></code>  不同。</p>
</div></blockquote>
</section>
<section id="x-y">
<span id="faq-combining-columns"></span><h2>我收到有关“隐式组合列 X 在属性 Y 下”的警告或错误消息<a class="headerlink" href="#x-y" title="Permalink to this heading">¶</a></h2>
<p>当映射包含两个由于名称而被映射到同一属性名称的列，并且没有表明这是有意的，
则出现该情况。由于映射类需要显式为存储独立值的每个属性指定名称；
当两个列具有相同的名称并且未加区别时，它们将落入同一属性下，
其效果是该属性从一个列复制值到另一个列，基于先将哪个列分配给属性的原则。</p>
<p>此行为通常是可取的，并且在使用外键关系将两个列链接在继承映射中的情况下，
可以无需警告地执行操作。 当发生警告或异常时，可以通过将这些列分配给具有不同名称的属性来解决问题，
或者如果希望将它们组合在一起，则使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code>  明确说明这一点。</p>
<p>给出如下示例：</p>
<blockquote>
<div><p>from sqlalchemy import Integer, Column, ForeignKey
from sqlalchemy.ext.declarative import declarative_base</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(A):</dt><dd><p>__tablename__ = “b”</p>
<p>id = Column(Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>截至 SQLAlchemy 版本 0.9.5，上述条件被检测到，并且将警告表示“id”列（即 A 和 B 中的 id）正在组合在同名属性“id”下，
这是一个严重的问题，因为它意味着“B”对象的主键将始终与其“a”的主键镜像。</p>
<p>解决此问题的映射如下：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(A):</dt><dd><p>__tablename__ = “b”</p>
<p>b_id = Column(“id”, Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>假设我们确实希望“ A.id ”和“ B.id ”相互映射，尽管 “B.a_id” 是 “A.id” 相关的。我们可以
使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code>  将它们组合在一起：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(A):</dt><dd><p>__tablename__ = “b”</p>
<p># probably not what you want, but this is a demonstration
id = column_property(Column(Integer, primary_key=True), A.id)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>我正在使用 Declarative，并使用 <code class="docutils literal notranslate"><span class="pre">and_()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">or_()</span></code> 设置 primaryjoin/secondaryjoin，
为此我收到有关外键的错误消息。
————————————————————————————————–</p>
<p>您这样做了吗？</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># ….</p>
<dl class="simple">
<dt>foo = relationship(</dt><dd><p>“Dest”, primaryjoin=and_(“MyClass.id==Dest.foo_id”, “MyClass.foo==Dest.bar”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>这是两个字符串表达式的 <code class="docutils literal notranslate"><span class="pre">and_()</span></code>，SQLAlchemy 不能将其应用于任何映射。Declarative 允许将   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>
参数指定为字符串，这些字符串使用 <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 转换为表达式对象。但这不会在 <code class="docutils literal notranslate"><span class="pre">and_()</span></code> 表达式内发生 -
这是 Declarative 仅应用于字符串作为一个整体的特殊操作：  <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 。</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># ….</p>
<dl class="simple">
<dt>foo = relationship(</dt><dd><p>“Dest”, primaryjoin=”and_(MyClass.id==Dest.foo_id, MyClass.foo==Dest.bar)”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>或者，如果您需要的对象已经可用，则可以跳过字符串：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># ….</p>
<dl class="simple">
<dt>foo = relationship(</dt><dd><p>Dest, primaryjoin=and_(MyClass.id == Dest.foo_id, MyClass.foo == Dest.bar)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>相同的思想适用于所有其他参数，如 <code class="docutils literal notranslate"><span class="pre">foreign_keys</span></code>：</p>
<blockquote>
<div><p># 不正确！
foo = relationship(Dest, foreign_keys=[“Dest.foo_id”, “Dest.bar_id”])</p>
<p># 正确！
foo = relationship(Dest, foreign_keys=”[Dest.foo_id, Dest.bar_id]”)</p>
<p># 还是正确的！
foo = relationship(Dest, foreign_keys=[Dest.foo_id, Dest.bar_id])</p>
<p># 如果您正在使用来自所在类的列，请使用列对象！
class MyClass(Base):</p>
<blockquote>
<div><p>foo_id = Column(…)
bar_id = Column(…)
# …</p>
<p>foo = relationship(Dest, foreign_keys=[foo_id, bar_id])</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="limit-subqueryload-order-by">
<span id="faq-subqueryload-limit-sort"></span><h2>为什么建议使用带有“LIMIT”（特别是使用“subqueryload()”）的“ORDER BY”？<a class="headerlink" href="#limit-subqueryload-order-by" title="Permalink to this heading">¶</a></h2>
<p>当未使用 ORDER BY 返回行时，关系数据库可自由以任何任意顺序返回匹配的行。
尽管此排序通常对应于表中的自然行顺序，但这并不适用于所有数据库和所有查询。
这意味着对使用 LIMIT 或 OFFSET 限制行或仅选择结果的查询而言，
如果匹配的行不止一行，则查询结果在某种程度上是不确定的。</p>
<p>尽管我们在通常返回自然排序行的数据库上可能不注意到这一点，
但如果我们还使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code>  加载相关集合，则可能会更成为问题。
这可能不会按预期加载集合。</p>
<p>SQLAlchemy 通过发出单独的查询来实现   <code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code> ，其结果与第一次查询的结果保持匹配。</p>
<p>我们看到如下的两个发出查询：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'><span class="c1">-- 主要查询</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
</div><div class='show_sql'><span class="c1">-- subqueryload 发出的“加载”查询</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_user_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1_users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">addresses</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span>
</div></pre></div>
</div>
<p>第二个查询将第一个查询作为行源嵌入其中。
当内部查询使用 OFFSET 和/或 LIMIT 而不进行排序时，
两个查询可能不会看到相同的结果：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span>
<span class="go">...     select(User).options(subqueryload(User.addresses)).limit(1)</span>
<span class="go">... ).first()</span>
<div class='show_sql'><span class="c1">-- 主要查询</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
<span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">1</span>
</div><div class='show_sql'><span class="c1">-- subqueryload 发出的“加载”查询</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_user_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1_users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">addresses</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span>
</div></pre></div>
</div>
<p>根据数据库具体情况，我们可能会为这两个查询获取以下结果：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>-- 查询 #1
+--------+
|users_id|
+--------+
|       1|
+--------+

-- 查询 #2
+------------+-----------------+---------------+
|addresses_id|addresses_user_id|anon_1_users_id|
+------------+-----------------+---------------+
|           3|                2|              2|
+------------+-----------------+---------------+
|           4|                2|              2|
+------------+-----------------+---------------+</pre></div>
</div>
<p>上述示例中，我们收到了 “帐户” 的两个行，其 “user.id” 均为 2，但没有获得 1 的行。
我们浪费了两行并未正确加载集合。这是一个隐蔽的错误，因为如果不查看 SQL 和结果，
则 ORM 将不会显示任何问题；如果我们访问我们拥有的“ addresses ”，
它将为集合发出惰性加载，并且我们将看不出实际上发生了什么错误。</p>
<p>解决此问题的方法是始终指定确定性排序顺序，
以便主查询始终返回相同的行集。这通常意味着您应该  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a>
表上的唯一列。主键是此目的的一个好选择:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></pre></div>
</div>
<p>请注意，  <code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code>  极端加载程序策略不受此问题的影响，
因为仅发出了一个查询，因此加载查询无法与主查询不同。
类似地，  <code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code>  也不会出现此问题，因为它将其集合加载直接链接到刚加载的主键值。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#subquery-eager-loading"><span class="std std-ref">子查询急加载</span></a></p>
</div>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="sqlexpressions.html" title="previous chapter">SQL表达式</a>
        Next:
        <a href="performance.html" title="next chapter">性能</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:43:52

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


