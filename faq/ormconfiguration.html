<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    ORM配置
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="常见问题解答" href="index.html" />
        <link rel="next" title="为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？" href="performance.html" />
        <link rel="prev" title="SQL表达式" href="sqlexpressions.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="常见问题解答">常见问题解答</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="installation.html">安装</a></span></li>
<li><span class="link-container"><a class="reference external" href="connections.html">连接/引擎</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata_schema.html">元数据 / 模式</a></span></li>
<li><span class="link-container"><a class="reference external" href="sqlexpressions.html">SQL表达式</a></span></li>
<li class="selected"><span class="link-container"><strong>ORM配置</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#faq-mapper-primary-key">如何映射一个没有主键的表？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python">如何配置一个Python保留字或类似的列？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id4">如何获得一个映射类的所有列、关系、映射属性等的列表？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#xy">我收到有关“隐式组合列X的属性Y”的警告或错误消息</a></span></li>
<li><span class="link-container"><a class="reference external" href="#declarativeand-or-primaryjoin-secondaryjoin">我正在使用Declarative并使用“and_()”或“or_()”设置primaryjoin / secondaryjoin，我收到有关外键的错误消息。</a></span></li>
<li><span class="link-container"><a class="reference external" href="#limitorder-by-subqueryload">为什么推荐使用“LIMIT”与“ORDER BY”（特别是与“subqueryload()”一起）？</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="performance.html">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</a></span></li>
<li><span class="link-container"><a class="reference external" href="performance.html#sqlalchemy">如何对由 SQLAlchemy 驱动的应用进行性能分析？</a></span></li>
<li><span class="link-container"><a class="reference external" href="performance.html#orm-400-000">我正在使用 ORM 插入 400,000 行，这很慢！</a></span></li>
<li><span class="link-container"><a class="reference external" href="sessions.html">Sessions / Queries</a></span></li>
<li><span class="link-container"><a class="reference external" href="thirdparty.html">第三方集成问题</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="sqlexpressions.html" title="previous chapter">SQL表达式</a></li>
                <li><b>Next:</b>
                <a href="performance.html" title="next chapter">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="常见问题解答">常见问题解答</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#orm">ORM配置</a><ul>
<li><a class="reference internal" href="#faq-mapper-primary-key">如何映射一个没有主键的表？</a></li>
<li><a class="reference internal" href="#python">如何配置一个Python保留字或类似的列？</a></li>
<li><a class="reference internal" href="#id4">如何获得一个映射类的所有列、关系、映射属性等的列表？</a></li>
<li><a class="reference internal" href="#xy">我收到有关“隐式组合列X的属性Y”的警告或错误消息</a></li>
<li><a class="reference internal" href="#declarativeand-or-primaryjoin-secondaryjoin">我正在使用Declarative并使用“and_()”或“or_()”设置primaryjoin / secondaryjoin，我收到有关外键的错误消息。</a></li>
<li><a class="reference internal" href="#limitorder-by-subqueryload">为什么推荐使用“LIMIT”与“ORDER BY”（特别是与“subqueryload()”一起）？</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar faq-ormconfiguration" >
        
<section id="orm">
<h1>ORM配置<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h1>
<nav class="contents faq local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#faq-mapper-primary-key" id="id35">如何映射一个没有主键的表？</a></p></li>
<li><p><a class="reference internal" href="#python" id="id36">如何配置一个Python保留字或类似的列？</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id37">如何获得一个映射类的所有列、关系、映射属性等的列表？</a></p></li>
<li><p><a class="reference internal" href="#xy" id="id38">我收到有关“隐式组合列X的属性Y”的警告或错误消息</a></p></li>
<li><p><a class="reference internal" href="#declarativeand-or-primaryjoin-secondaryjoin" id="id39">我正在使用Declarative并使用“and_()”或“or_()”设置primaryjoin / secondaryjoin，我收到有关外键的错误消息。</a></p></li>
<li><p><a class="reference internal" href="#limitorder-by-subqueryload" id="id40">为什么推荐使用“LIMIT”与“ORDER BY”（特别是与“subqueryload()”一起）？</a></p></li>
</ul>
</nav>
<section id="faq-mapper-primary-key">
<span id="id1"></span><h2>如何映射一个没有主键的表？<a class="headerlink" href="#faq-mapper-primary-key" title="Permalink to this heading">¶</a></h2>
<p>SQLAlchemy ORM要映射到特定的表，需要至少有一列标识为主键列；多列的复合主键当然也是可行的。 但这些列不需要实际上被数据库知道为主键列，虽然最好是。重要的是列的行为要像主键一样，例如对于一个行是一个唯一且不可为空的标识符。</p>
<p>大多数ORM都要求对象定义了一些主键，因为内存中的对象必须对应于数据库表中的唯一可识别的行；至少，这允许将对象定位为仅影响该对象行而不影响其他行的UPDATE和DELETE语句。 但是，主键的重要性远远超出了这一点。 在SQLAlchemy中，所有ORM映射的对象始终链接到其特定的数据库行，使用的模式称为：term：<cite>identity map</cite>，它是SQLAlchemy使用的工作单元系统的中心模式，也是最常见的模式（以及不太常见的）ORM使用。</p>
<p>几乎所有情况下，表格都有名为term：<a href="#id2"><span class="problematic" id="id3">`</span></a>candidate key`的东西，它是唯一标识行的一列或一系列列。
如果表格确实没有这种情况，并且拥有真正重复的行，则该表格不对应于
“第一范式”于关系型数据库，不能映射。否则，组成最佳候选键的列可以直接应用于映射器：</p>
<blockquote>
<div><dl>
<dt>class SomeClass(Base):</dt><dd><p>__table__ = some_table_with_no_pk
__mapper_args__ = {</p>
<blockquote>
<div><p>“primary_key”: [some_table_with_no_pk.c.uid, some_table_with_no_pk.c.bar]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>最好的方法是在使用完全声明的表元数据时，在这些列上使用primary_key=True标志：</p>
<blockquote>
<div><dl>
<dt>class SomeClass(Base):</dt><dd><p>__tablename__ = “some_table_with_no_pk”</p>
<p>uid = Column(Integer, primary_key=True)
bar = Column(String, primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
<p>关系型数据库中的所有表都应该有主键。甚至一个多对多的关联表 - 主键是两个关联列的复合：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">my_association</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="n">user_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
<span class="w">  </span><span class="n">account_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">account</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
<span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">account_id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
</section>
<section id="python">
<h2>如何配置一个Python保留字或类似的列？<a class="headerlink" href="#python" title="Permalink to this heading">¶</a></h2>
<p>在映射中，基于列的属性可以被赋予任何所需的名称。参见
<span class="xref std std-ref">mapper_column_distinct_names</span>。</p>
</section>
<section id="id4">
<h2>如何获得一个映射类的所有列、关系、映射属性等的列表？<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>此信息都可以从:class:<a href="#id5"><span class="problematic" id="id6">`</span></a>_orm.Mapper`对象中获取。</p>
<p>要获取特定映射类的:attr:<cite>_orm.Mapper</cite>，请对其调用:func:<a href="#id7"><span class="problematic" id="id8">`</span></a>_sa.inspect`函数：</p>
<blockquote>
<div><p>from sqlalchemy import inspect</p>
<p>mapper = inspect(MyClass)</p>
</div></blockquote>
<p>从那里，可以通过以下属性访问有关类的所有信息：</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.attrs</span></code> - 所有映射属性的名称空间。这些属性
本身是:class:<a href="#id9"><span class="problematic" id="id10">`</span></a>.MapperProperty`的实例，其中包含其他属性，如果适用，则可以导致映射的SQL表达式或列。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.column_attrs</span></code> - 仅列和SQL表达式属性的映射属性名称空间。
您可能希望使用:attr:<a href="#id11"><span class="problematic" id="id12">`</span></a>_orm.Mapper.columns`来直接获取:class:<a href="#id13"><span class="problematic" id="id14">`</span></a>_schema.Column`对象。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.relationships</span></code> - 所有:class:<a href="#id15"><span class="problematic" id="id16">`</span></a>.RelationshipProperty`属性的名称空间。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.all_orm_descriptors</span></code> - 所有映射属性的名称空间，以及使用系统定义的用户定义属性，例如：class:<cite>.hybrid_property</cite>、:class:<a href="#id17"><span class="problematic" id="id18">`</span></a>.AssociationProxy`等。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.columns</span></code> - 一个:class:<a href="#id19"><span class="problematic" id="id20">`</span></a>_schema.Column`对象和与映射相关的其他命名SQL表达式的名称空间。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.mapped_table</span></code> - 这个映射程序映射到的:class:<a href="#id21"><span class="problematic" id="id22">`</span></a>_schema.Table`或其他可选择的表。</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.local_table</span></code> - “本地”表格是该映射程序的:class:<cite>_schema.Table</cite>；
对于使用继承映射到组合可选择性的映射程序，这与: attr:<a href="#id23"><span class="problematic" id="id24">`</span></a>_orm.Mapper.mapped_table`不同。</p></li>
</ul>
</section>
<section id="xy">
<span id="faq-combining-columns"></span><h2>我收到有关“隐式组合列X的属性Y”的警告或错误消息<a class="headerlink" href="#xy" title="Permalink to this heading">¶</a></h2>
<p>这种情况指的是当映射包含两个由于名称而被映射到相同属性名称的列时，
但没有迹象表明这是有意的。映射类需要对每个将存储独立值的属性指定显式名称；
当两个列具有相同的名称并且未被消除歧义时，它们将落在同一属性下
效果是从一个列复制到另一个列，基于哪个列首先被分配到属性中。</p>
<p>这种行为通常是可取的，并且仅在由具有外键关系链接在一起的两个列时，
使用继承映射。当警告或异常发生时，可以通过将列分配给不同命名的属性来解决问题，或者如果希望将它们组合在一起，则使用:func:<a href="#id25"><span class="problematic" id="id26">`</span></a>.column_property`使这种情况明确。</p>
<p>例如：</p>
<blockquote>
<div><p>from sqlalchemy import Integer, Column, ForeignKey
from sqlalchemy.ext.declarative import declarative_base</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(A):</dt><dd><p>__tablename__ = “b”</p>
<p>id = Column(Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>在SQLAlchemy版本0.9.5中，检测到上述条件，并警告“将“A”和“B”的”id“列”组合起来“，这是一个严重的问题，因为这意味着“B”对象的主键将始终镜像其“A”的主键。</p>
<p>可以解决缺陷的映射如下：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(A):</dt><dd><p>__tablename__ = “b”</p>
<p>b_id = Column(“id”, Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>假设我们确实希望“A.id”和“B.id”相互镜像，尽管“B.a_id”是与“A.id”相关的。我们可以使用：func:<a href="#id27"><span class="problematic" id="id28">`</span></a>.column_property`组合它们在一起：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(A):</dt><dd><p>__tablename__ = “b”</p>
<p># probably not what you want, but this is a demonstration
id = column_property(Column(Integer, primary_key=True), A.id)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="declarativeand-or-primaryjoin-secondaryjoin">
<h2>我正在使用Declarative并使用“and_()”或“or_()”设置primaryjoin / secondaryjoin，我收到有关外键的错误消息。<a class="headerlink" href="#declarativeand-or-primaryjoin-secondaryjoin" title="Permalink to this heading">¶</a></h2>
<p>您是否在做这个？：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># ….</p>
<dl class="simple">
<dt>foo = relationship(</dt><dd><p>“Dest”, primaryjoin=and_(“MyClass.id==Dest.foo_id”, “MyClass.foo==Dest.bar”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>那是两个字符串表达式的“and_()”，SQLAlchemy无法应用任何映射。Declarative允许将：func:<a href="#id29"><span class="problematic" id="id30">`</span></a>_orm.relationship`参数指定为字符串，这些字符串使用“eval()”转换为表达式对象。但这不会在“and_()”表达式内发生 - 这是declarative仅适用于*作为字符串传递给primaryjoin或其他参数的整体性*的特殊操作：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># ….</p>
<dl class="simple">
<dt>foo = relationship(</dt><dd><p>“Dest”, primaryjoin=”and_(MyClass.id==Dest.foo_id, MyClass.foo==Dest.bar)”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>或者，如果您已经拥有所需的对象，则跳过字符串：</p>
<blockquote>
<div><dl>
<dt>class MyClass(Base):</dt><dd><p># ….</p>
<dl class="simple">
<dt>foo = relationship(</dt><dd><p>Dest, primaryjoin=and_(MyClass.id == Dest.foo_id, MyClass.foo == Dest.bar)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>同样的想法适用于所有其他参数，例如“foreign_keys”：</p>
<blockquote>
<div><p># wrong !
foo = relationship(Dest, foreign_keys=[“Dest.foo_id”, “Dest.bar_id”])</p>
<p># correct !
foo = relationship(Dest, foreign_keys=”[Dest.foo_id, Dest.bar_id]”)</p>
<p># also correct !
foo = relationship(Dest, foreign_keys=[Dest.foo_id, Dest.bar_id])</p>
<p># if you’re using columns from the class that you’re inside of, just use the column objects !
class MyClass(Base):</p>
<blockquote>
<div><p>foo_id = Column(…)
bar_id = Column(…)
# …</p>
<p>foo = relationship(Dest, foreign_keys=[foo_id, bar_id])</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="limitorder-by-subqueryload">
<span id="faq-subqueryload-limit-sort"></span><h2>为什么推荐使用“LIMIT”与“ORDER BY”（特别是与“subqueryload()”一起）？<a class="headerlink" href="#limitorder-by-subqueryload" title="Permalink to this heading">¶</a></h2>
<p>当不为返回行的SELECT语句使用ORDER BY时，关系型数据库可以自由地以任意顺序返回匹配的行。虽然此排序很多时候对应于表格中行的自然顺序，但并非对于所有数据库和所有查询都是如此。这意味着即使有多行符合查询的标准，
使用“LIMIT”或“OFFSET”的任何查询，或者仅选择结果的第一行，舍弃其余部分，
在返回什么结果行方面是不确定的，假设存在多个匹配的行与查询的标准。
虽然我们对通常返回将行按自然顺序排列的数据库上的简单查询可能不会注意到这一点，但如果我们还使用：func:<a href="#id31"><span class="problematic" id="id32">`</span></a>_orm.subqueryload`将相关集合加载，则这将成为更大的问题，并且我们可能不会
正在按预期加载集合。</p>
<p>SQLAlchemy通过发出单独的查询来实现：func:<cite>_orm.subqueryload</cite>，其结果与第一个查询匹配。
我们看到如下两个发出的查询：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'><span class="c1">-- the &quot;main&quot; query</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
</div><div class='show_sql'><span class="c1">-- the &quot;load&quot; query issued by subqueryload</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_user_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1_users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">addresses</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span>
</div></pre></div>
</div>
<p>第二个查询将第一个查询作为行的来源嵌入其中。当内部查询使用“OFFSET”和/或“LIMIT”而没有排序时，
这两个查询可能不会看到相同的结果：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span>
<span class="go">...     select(User).options(subqueryload(User.addresses)).limit(1)</span>
<span class="go">... ).first()</span>
<div class='show_sql'><span class="c1">-- the &quot;main&quot; query</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
<span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">1</span>
</div><div class='show_sql'><span class="c1">-- the &quot;load&quot; query issued by subqueryload</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">addresses_user_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1_users_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">users_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">addresses</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addresses</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">users_id</span>
</div></pre></div>
</div>
<p>取决于数据库的具体情况，我们可能会得到以下结果的结果两个查询：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>-- query #1
+--------+
|users_id|
+--------+
|       1|
+--------+

-- query #2
+------------+-----------------+---------------+
|addresses_id|addresses_user_id|anon_1_users_id|
+------------+-----------------+---------------+
|           3|                2|              2|
+------------+-----------------+---------------+
|           4|                2|              2|
+------------+-----------------+---------------+</pre></div>
</div>
<p>上面，我们接收了两个与“user.id”为2相对应的“addresses”行，并且没有任何行与1相对应。
我们浪费了两行并未实际加载集合。这是一个隐蔽的错误，因为除非查看SQL和结果，否则ORM不会显示任何问题；如果我们访问对于我们已经有的“User”的“addresses”，它将向懒加载发出集合查询
和我们看不出实际上出了什么问题。</p>
<p>解决此问题的方法是始终指定确定性排序，以便主查询始终返回相同的行集。这通常
意味着您应该:meth:<a href="#id33"><span class="problematic" id="id34">`</span></a>_sql.Select.order_by`在表上选择一个唯一的列。
主键对此是一个不错的选择：</p>
<blockquote>
<div><dl class="simple">
<dt>session.scalars(</dt><dd><p>select(User).options(subqueryload(User.addresses)).order_by(User.id).limit(1)</p>
</dd>
</dl>
<p>).first()</p>
</div></blockquote>
<p>请注意：func:<cite>_orm.joinedload`贪婪加载器策略不会遇到相同的问题，因为只发出一个查询，因此加载查询
不能与主查询不同。类似地，：func:</cite>.selectinload`贪婪加载策略也没有此问题，因为它将其集合加载直接链接到已加载的主键值。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">subquery_eager_loading</span></p>
</div>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="sqlexpressions.html" title="previous chapter">SQL表达式</a>
        Next:
        <a href="performance.html" title="next chapter">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:31:09

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


