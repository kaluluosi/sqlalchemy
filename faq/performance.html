<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    性能
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="常见问题解答" href="index.html" />
        <link rel="next" title="会话/查询" href="sessions.html" />
        <link rel="prev" title="ORM配置" href="ormconfiguration.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="常见问题解答">常见问题解答</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="installation.html">安装</a></span></li>
<li><span class="link-container"><a class="reference external" href="connections.html">连接/引擎</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata_schema.html">元数据/模式</a></span></li>
<li><span class="link-container"><a class="reference external" href="sqlexpressions.html">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="ormconfiguration.html">ORM配置</a></span></li>
<li class="selected"><span class="link-container"><strong>性能</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#x">为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sql">第一步-打开SQL记录并确认是否正在工作的缓存</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id2">第二步-确定什么结构阻止了启用缓存</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id3">第三步-为给定对象启用缓存和/或寻求替代方案</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy">如何为SQLAlchemy提供动态性能分析？</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id6">查询分析</a></span></li>
<li><span class="link-container"><a class="reference external" href="#faq-code-profiling">代码分析</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id8">执行缓慢</a></span></li>
<li><span class="link-container"><a class="reference external" href="#core">结果获取缓慢-Core</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm">由ORM提取缓慢结果</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm400-000">我正在使用ORM插入400,000行，但速度非常慢！</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="sessions.html">会话/查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="thirdparty.html">第三方集成问题</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="ormconfiguration.html" title="previous chapter">ORM配置</a></li>
                <li><b>Next:</b>
                <a href="sessions.html" title="next chapter">会话/查询</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="常见问题解答">常见问题解答</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#faq-performance">性能</a><ul>
<li><a class="reference internal" href="#x">为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？</a><ul>
<li><a class="reference internal" href="#sql">第一步-打开SQL记录并确认是否正在工作的缓存</a></li>
<li><a class="reference internal" href="#id2">第二步-确定什么结构阻止了启用缓存</a></li>
<li><a class="reference internal" href="#id3">第三步-为给定对象启用缓存和/或寻求替代方案</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sqlalchemy">如何为SQLAlchemy提供动态性能分析？</a><ul>
<li><a class="reference internal" href="#id6">查询分析</a></li>
<li><a class="reference internal" href="#faq-code-profiling">代码分析</a></li>
<li><a class="reference internal" href="#id8">执行缓慢</a></li>
<li><a class="reference internal" href="#core">结果获取缓慢-Core</a></li>
<li><a class="reference internal" href="#orm">由ORM提取缓慢结果</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm400-000">我正在使用ORM插入400,000行，但速度非常慢！</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar faq-performance" >
        
<section id="faq-performance">
<span id="id1"></span><h1>性能<a class="headerlink" href="#faq-performance" title="Permalink to this heading">¶</a></h1>
<section id="x">
<span id="faq-new-caching"></span><h2>为什么在升级到1.4和/或2.x之后，我的应用程序变得很慢？<a class="headerlink" href="#x" title="Permalink to this heading">¶</a></h2>
<dl class="simple">
<dt>从1.4版本开始，SQLAlchemy包括一个</dt><dd><p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL 编译缓存机制</span></a> ，该机制将允许</p>
</dd>
</dl>
<p>Core和ORM SQL构造缓存其字符串形式以及其他结构信息，用于从语句中获取结果，从而
在下一次使用另一个结构等效构造时，跳过比较昂贵的字符串编译过程。这个系统
依赖于所有SQL构造的可实现的功能，包括
对象，例如  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> ,</p>
<blockquote>
<div><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> ，和 :class:` _types.TypeEngine`对象，以生成一个</p>
</div></blockquote>
<p><strong>缓存密钥</strong>，它完全表示它们的状态，以影响它们的程度
SQL编译过程。</p>
<p>缓存系统允许SQLAlchemy 1.4及以上版本比
SQLAlchemy 1.3转换SQL构造为字符串的时间要更短
反复。但是，这仅在为该特定SQL dialect和SQL构造启用缓存时才有效；
否则，字符串编译通常类似于SQLAlchemy 1.3，某些情况下速度略有下降。</p>
<p>然而，有一种情况，即如果SQLAlchemy的新缓存系统已被禁用（由于以下原因），则ORM的性能实际上可能
比1.3或其他先前版本的性能显着更差，这是由于在ORM懒惰加载器和对象刷新查询中缺少缓存
在1.3和早期版本中使用了现在过时的“BakedQuery”系统。如果
应用程序在切换到1.4时看到了显着的（30％或更高）性能降级
（以完成操作所需的时间为度量），那么这是问题的可能原因，下面是减轻步骤。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL 编译缓存</span></a>  - 缓存系统概述</p>
<p><a class="reference internal" href="../errors.html#caching-caveats"><span class="std std-ref">对象不会生成缓存键，性能影响</span></a>  - 有关未启用缓存的元素产生的警告的其他信息。</p>
</div>
<section id="sql">
<h3>第一步-打开SQL记录并确认是否正在工作的缓存<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>在这里，我们要使用在</dt><dd><p><a class="reference internal" href="../core/connections.html#sql-caching-logging"><span class="std std-ref">引擎日志记录</span></a> 中介绍的技术，查找具有该语句的语句</p>
</dd>
</dl>
<p>“[no key]”标识符或者甚至是“[dialect does not support caching]”。
当语句第一次调用时，“[generated in Xs]”会指示
对于每个语句，接下来的大多数语句则为“[cached since Xs ago]”。如果
“[no key]”普遍存在特别是对于SELECT语句，或者
如果由于“[dialect does not support caching]”，缓存被完全禁用
这可能是严重性能下降的原因。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching-logging"><span class="std std-ref">使用日志记录估计缓存性能</span></a></p>
</div>
</section>
<section id="id2">
<h3>第二步-确定什么结构阻止了启用缓存<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>假设语句没有被缓存，则应发出警告
应用程序的日志（仅限SQLAlchemy 1.4.28及以上版本）指示方言， <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 对象以及不是SQL
不参与缓存的构造。</p>
<p>对于像那些从 <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> 扩展的自定义类型而言，
和  <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.UserDefinedType" title="sqlalchemy.types.UserDefinedType"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedType</span></code></a> ，警告将如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.ext.SAWarning: MyType will not produce a cache key because the
&quot;cache_ok&quot; attribute is not set to True. This can have significant
performance implications including some performance degradations in
comparison to prior SQLAlchemy versions. Set this attribute to True if this
type object&#39;s state is safe to use in a cache key, or False to disable this
warning.</pre></div>
</div>
<p>对于自定义和第三方SQL元素，例如使用
在 <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span> 中描述的技术，这些警告将如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL
compilation caching as it does not set the &#39;inherit_cache&#39; attribute to
``True``. This can have significant performance implications including some
performance degradations in comparison to prior SQLAlchemy versions. Set
this attribute to True if this object can make use of the cache key
generated by the superclass. Alternatively, this attribute may be set to
False which will disable this warning.</pre></div>
</div>
<p>对于使用 <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect" title="sqlalchemy.engine.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a> 类层次结构的自定义和第三方方言，警告将如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL
compilation caching as it does not set the &#39;supports_statement_cache&#39;
attribute to ``True``. This can have significant performance implications
including some performance degradations in comparison to prior SQLAlchemy
versions. Dialect maintainers should seek to set this attribute to True
after appropriate development and testing for SQLAlchemy 1.4 caching
support. Alternatively, this attribute may be set to False which will
disable this warning.</pre></div>
</div>
</section>
<section id="id3">
<h3>第三步-为给定对象启用缓存和/或寻求替代方案<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>缓解缓存不足的步骤包括：</p>
<dl>
<dt><a href="#id4"><span class="problematic" id="id5">*</span></a>检查并设置  <code class="xref py py-class docutils literal notranslate"><span class="pre">cache_ok</span></code> ，</dt><dd><blockquote>
<div><dl>
<dt><a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.UserDefinedType" title="sqlalchemy.types.UserDefinedType"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedType</span></code></a> 扩展，以及这些类型的子类，例如</dt><dd><p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.PickleType" title="sqlalchemy.types.PickleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleType</span></code></a> 。此设置只需在自定义类型不包括影响其如何呈现SQL的任何附加状态属性时使用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyCustomType</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="n">cache_ok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">impl</span> <span class="o">=</span> <span class="n">String</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</dd>
</dl>
</div></blockquote>
<p>如果使用的类型来自于第三方库，请与该库的维护者联系，以便进行相应的调整并发布。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok" title="sqlalchemy.types.ExternalType.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ExternalType.cache_ok</span></code></a>  - 背景要求使自定义数据类型启用</p>
</div></blockquote>
<p>缓存。</p>
</div>
</dd>
</dl>
<ul>
<li><p>确保第三方方言将：attr:<cite>.Dialect.supports_statement_cache</cite>
设置为``True``。这表示第三方方言的维护者已经确定它们的方言是否与SQLAlchemy 1.4或更高版本一起使用，
并且它们的方言不包含会影响缓存的任何编译功能。由于确实存在一些常见的编译模式，
可能会干扰缓存，因此方言维护者检查并仔细测试这一点非常重要，调整任何旧版
不适用缓存的模式。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../core/connections.html#engine-thirdparty-caching"><span class="std std-ref">第三方方言的缓存</span></a>  - 参与SQL语句缓存的第三</p>
</div></blockquote>
<p>方方言的背景和示例。</p>
</div>
</li>
<li><p>21自定义SQL类，包括使用 <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span> 创建的所有DQL / DML构造，
以及  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> .HasCacheKey.inherit_cache` 属性
可以用于没有包含任何的显式子类特定状态信息的微不足道的子类。影响SQL编译。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/compiler.html#compilerext-caching"><span class="std std-ref">Enabling Caching Support for Custom Constructs</span></a>  - 应用  :attr:` .HasCacheKey.inherit_cache`  属性的指南。</p>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL 编译缓存</span></a>  - 缓存系统概述</p>
<p><a class="reference internal" href="../errors.html#caching-caveats"><span class="std std-ref">对象不会生成缓存键，性能影响</span></a>  - 有关未启用特定构造和/或方言的缓存时发出的警告的背景信息。</p>
</div>
</section>
</section>
<section id="sqlalchemy">
<span id="faq-how-to-profile"></span><h2>如何为SQLAlchemy提供动态性能分析？<a class="headerlink" href="#sqlalchemy" title="Permalink to this heading">¶</a></h2>
<p>查找性能问题通常包括两种策略。一
是查询分析, 另一个是代码分析。</p>
<section id="id6">
<h3>查询分析<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<p>有时仅仅是普通的SQL记录（通过python的日志模块启用
或通过 <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code> 的echo=True参数）可以给一个
对花费的时间有一个概念。例如，如果您记录了某些东西
在SQL操作之后，您会在您的中看到这样的东西
日志：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...
17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {&lt;params&gt;}
17:37:48,660 DEBUG [myapp.somemessage]</pre></div>
</div>
<p>如果您在操作之后记录“myapp.somemessage”，您就会知道
它花费了334ms来完成SQL部分的事情。</p>
<p>记录SQL也将说明是否正在发出几十个/几百个查询
可以更好地组织成远少于查询的查询。使用SQLAlchemy ORM时，提供了“热加载”
功能，用于部分（  <code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code> )或完全
(  <code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code> ,   :func:` .subqueryload()` )
自动化此操作，但是在
ORM“热加载”通常意味着使用连接，以便可以一次加载多个结果集
在添加更多深度（即“r + r * r2 + r * r2 * r3”…）时，而不是增加查询的数量</p>
<p>对于查询的长期性能分析，或者要实现应用程序方面的“慢查询”监视器，可以使用事件拦截游标执行，
使用以下示例中的配方：</p>
<blockquote>
<div><p>from sqlalchemy import event
from sqlalchemy.engine import Engine
import time
import logging</p>
<p>logging.basicConfig()
logger = logging.getLogger(“myapp.sqltime”)
logger.setLevel(logging.DEBUG)</p>
<p>&#64;event.listens_for(Engine, “before_cursor_execute”)
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):</p>
<blockquote>
<div><p>conn.info.setdefault(“query_start_time”, []).append(time.time())
logger.debug(“Start Query: %s”, statement)</p>
</div></blockquote>
<p>&#64;event.listens_for(Engine, “after_cursor_execute”)
def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):</p>
<blockquote>
<div><p>total = time.time() - conn.info[“query_start_time”].pop(-1)
logger.debug(“Query Complete!”)
logger.debug(“Total Time: %f”, total)</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>在上面的示例中，我们使用  <a class="reference internal" href="../core/events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute" title="sqlalchemy.events.ConnectionEvents.before_cursor_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionEvents.before_cursor_execute()</span></code></a>  和</dt><dd><p><a class="reference internal" href="../core/events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute" title="sqlalchemy.events.ConnectionEvents.after_cursor_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionEvents.after_cursor_execute()</span></code></a>  事件，以在语句执行时建立拦截点。</p>
</dd>
</dl>
<p>我们使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">info</span></code> 字典在连接上附加一个定时器；
我们在这里使用一个堆栈，因为游标执行事件可能会嵌套。</p>
</section>
<section id="faq-code-profiling">
<span id="id7"></span><h3>代码分析<a class="headerlink" href="#faq-code-profiling" title="Permalink to this heading">¶</a></h3>
<p>如果logging显示单个查询需要太长时间，您将
需要一个内部将时间花费在处理查询的数据库内的细分
它可以提供有关花费多长时间在数据库中，发送结果，正在处理的信息
由  <span class="xref std std-term">DBAPI</span>  处理，最后由SQLAlchemy的结果集或ORM层处理的信息。
每个阶段都可以根据规则自己的瓶颈。</p>
<p>为此，您需要使用
<a class="reference external" href="https://docs.python.org/2/library/profile.html">Python Profiling Module</a>。
以下是一个将分析工作流集成到上下文管理器中的简单示例：</p>
<blockquote>
<div><p>import cProfile
import io
import pstats
import contextlib</p>
<p>&#64;contextlib.contextmanager
def profiled():</p>
<blockquote>
<div><p>pr = cProfile.Profile()
pr.enable()
yield
pr.disable()
s = io.StringIO()
ps = pstats.Stats(pr, stream=s).sort_stats(“cumulative”)
ps.print_stats()
# uncomment this to see who’s calling what
# ps.print_callers()
print(s.getvalue())</p>
</div></blockquote>
</div></blockquote>
<p>要分析一段代码：</p>
<blockquote>
<div><dl class="simple">
<dt>with profiled():</dt><dd><p>session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()</p>
</dd>
</dl>
</div></blockquote>
<p>分析的输出可用于指示花费时间的地方。一段分析输出如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>13726 function calls (13042 primitive calls) in 0.014 seconds

Ordered by: cumulative time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)
220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)
220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)
   20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)
   20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)
    1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)
   21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(&lt;genexpr&gt;)
    2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)

...</pre></div>
</div>
<p>在上面的示例中，我们可以看到“instance()”SQLAlchemy函数被调用了222次
（递归，外部调用时21次），所有调用加起来总共需要0.011秒。</p>
</section>
<section id="id8">
<h3>执行缓慢<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<p>这些调用的细节可以告诉我们时间花费在哪里。
例如，如果您看到时间花费在“cursor.execute()”中，
例如，对DBAPI：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2    0.102    0.102    0.204    0.102 {method &#39;execute&#39; of &#39;sqlite3.Cursor&#39; objects}</pre></div>
</div>
<p>这意味着数据库花费了很长时间才开始返回结果，
它意味着您的查询应该进行优化，无论是添加索引
还是重新构造查询和/或底层架构。为此任务，
应该使用查询计划分析，使用数据库后端提供的系统，例如EXPLAIN，
SHOW PLAN等。</p>
</section>
<section id="core">
<h3>结果获取缓慢-Core<a class="headerlink" href="#core" title="Permalink to this heading">¶</a></h3>
<p>另一方面，如果看到许多千次的调用与获取行有关，
或者很多延迟的调用到“fetchall()”，它可能
意味着查询返回的行比预期多，或者获取
行本身很慢。ORM自身通常使用“fetchall()”来获取
（或者使用  <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per" title="sqlalchemy.orm.Query.yield_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.yield_per()</span></code></a>  选项时使用“fetchmany()”）。
结果。太多的行将显示在DBAPI级别上很慢调用“fetchAll()”：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2    0.300    0.600    0.300    0.600 {method &#39;fetchall&#39; of &#39;sqlite3.Cursor&#39; objects}</pre></div>
</div>
<p>即使结果看似没有很多行，但行数意外地多，可能是笛卡尔积的结果-当多个查询集合在一起时，
在没有适当连接表的情况下。如果使用SQLAlchemy Core或ORM查询时使用了错误的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象，
这可能很容易出现此行为，这将拉出预期之外的额外FROM子句。</p>
<p>另一方面，在DBAPI级别快速调用“fetchAll()”，但是然后在SQLAlchemy的
调用类  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.CursorResult.fetchall" title="sqlalchemy.engine.CursorResult.fetchall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CursorResult.fetchall()</span></code></a>  时变慢，
可能表示数据类型处理等处理速度较慢：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># the DBAPI cursor is fast...
2    0.020    0.040    0.020    0.040 {method &#39;fetchall&#39; of &#39;sqlite3.Cursor&#39; objects}

...

#但是SQLAlchemy的结果代理缓慢，这是类型级别处理
2    0.100    0.200    0.100    0.200 lib/sqlalchemy/engine/result.py:778(fetchall)</pre></div>
</div>
<p>在某些情况下，后端可能会执行不必要的类型级别处理。
更具体地说，看到“type_api”中的调用速度慢是更好的指标。
系统，例如Unicode转换等：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>200    0.001    0.000    0.237    0.001 lib/sqlalchemy/sql/type_api.py:911(process)
200    0.001    0.000    0.236    0.001 test.py:28(process_result_value)
200    0.235    0.001    0.235    0.001 {time.sleep}</pre></div>
</div>
<p>也请务必检查  <a class="reference internal" href="../dialects/index.html"><span class="std std-ref">Dialect documentation</span></a>
在这个级别上已知的性能调优建议，特别是对于像Oracle这样的数据库。
可能存在确保数字精度或字符串处理的系统可能不在所有情况下都需要。</p>
<p>还可能存在更底层的行提取性能问题；例如，如果花费的时间似乎集中于类似于“socket.receive()”的调用，
这可能表明每件事都很快，除了实际的网络连接，数据在网络上传输的时间过长。</p>
</section>
<section id="orm">
<h3>由ORM提取缓慢结果<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h3>
<p>要在ORM提取行的性能上检测缓慢，如下所示，调用“populate_state()”和“_instance()”将
说明单个ORM对象的填充：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># ORM每次看到ORM-loaded row都为_instance()函数调用一次，
# 并对每一个在对象属性中结果的ORM-loaded row进行populate_state()函数调用
220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)
220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)</pre></div>
</div>
<p>ORM将行转换为ORM映射对象的缓慢是此操作的复杂性与CPython的开销的结果。
缓解这种情况的常见策略包括：</p>
<ul>
<li><p>每次仅获取列而不获取完整的实体，也就是：</p>
<blockquote>
<div><p>select(User.id, User.name)</p>
</div></blockquote>
<p>而不是：</p>
<blockquote>
<div><p>select(User)</p>
</div></blockquote>
</li>
<li><p>使用 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.Bundle" title="sqlalchemy.orm.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a> 对象组织基于列的结果：</p>
<blockquote>
<div><p>u_b = Bundle(“user”, User.id, User.name)
a_b = Bundle(“address”, Address.id, Address.email)</p>
<dl class="simple">
<dt>for user, address in session.execute(select(u_b, a_b).join(User.addresses)):</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>使用结果缓存-请参阅  <a class="reference internal" href="../orm/examples.html#examples-caching"><span class="std std-ref">Dogpile 缓存</span></a> ，了解详细的示例
如何进行缓存。</p></li>
<li><p>考虑更快的解释器，例如PyPy。</p></li>
</ul>
<p>分析的输出可能有点令人生畏，但是经过一些练习，
它们非常容易阅读。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../orm/examples.html#examples-performance"><span class="std std-ref">性能</span></a>  - 带有捆绑的性能演示</p>
</div></blockquote>
<p>剖析能力。</p>
</div>
</section>
</section>
<section id="orm400-000">
<h2>我正在使用ORM插入400,000行，但速度非常慢！<a class="headerlink" href="#orm400-000" title="Permalink to this heading">¶</a></h2>
<p>ORM插入的性质已更改，因为包括大多数内置驱动程序都使用了带有  <a class="reference internal" href="../core/connections.html#engine-insertmanyvalues"><span class="std std-ref">官方API的RETURNING</span></a>
支持的插入manyvalue为SQLAlchemy 2.0。有关详细信息，请参见 <span class="xref std std-ref">change_6047</span> 部分。</p>
<p>总体而言，除了MySQL的SQLAlchemy内置驱动程序外，现在应该
提供非常快的ORM批量插入性能。</p>
<p>第三方驱动程序还可以选择使用新的批量基础设施，前提是它们的后端支持所需的语法。
SQLAlchemy开发人员将鼓励第三方方言的用户，以便他们可以为问题的这些驱动程序发布问题。
让SQLAlchemy开发人员提供帮助。</p>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="ormconfiguration.html" title="previous chapter">ORM配置</a>
        Next:
        <a href="sessions.html" title="next chapter">会话/查询</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:58:52

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


