<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="常见问题解答" href="index.html" />
        <link rel="next" title="Sessions / Queries" href="sessions.html" />
        <link rel="prev" title="ORM配置" href="ormconfiguration.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="常见问题解答">常见问题解答</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="installation.html">安装</a></span></li>
<li><span class="link-container"><a class="reference external" href="connections.html">连接/引擎</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata_schema.html">元数据 / 模式</a></span></li>
<li><span class="link-container"><a class="reference external" href="sqlexpressions.html">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="ormconfiguration.html">ORM配置</a></span></li>
<li class="selected"><span class="link-container"><strong>为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sql">第一步-打开 SQL 日志并确认是否启用了缓存</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id3">第二步-识别阻止启用缓存的构造的对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id4">第三步-针对给定的对象启用缓存和/或寻找替代方案</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy">如何对由 SQLAlchemy 驱动的应用进行性能分析？</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-400-000">我正在使用 ORM 插入 400,000 行，这很慢！</a></span></li>
<li><span class="link-container"><a class="reference external" href="sessions.html">Sessions / Queries</a></span></li>
<li><span class="link-container"><a class="reference external" href="thirdparty.html">第三方集成问题</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="ormconfiguration.html" title="previous chapter">ORM配置</a></li>
                <li><b>Next:</b>
                <a href="sessions.html" title="next chapter">Sessions / Queries</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="常见问题解答">常见问题解答</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#x">为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？</a><ul>
<li><a class="reference internal" href="#sql">第一步-打开 SQL 日志并确认是否启用了缓存</a></li>
<li><a class="reference internal" href="#id3">第二步-识别阻止启用缓存的构造的对象</a></li>
<li><a class="reference internal" href="#id4">第三步-针对给定的对象启用缓存和/或寻找替代方案</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sqlalchemy">如何对由 SQLAlchemy 驱动的应用进行性能分析？</a><ul>
<li><a class="reference internal" href="#id5">查询分析</a></li>
<li><a class="reference internal" href="#faq-code-profiling">代码分析</a></li>
<li><a class="reference internal" href="#id7">执行缓慢</a></li>
<li><a class="reference internal" href="#core">结果获取速度缓慢-Core</a></li>
<li><a class="reference internal" href="#orm">结果获取速度缓慢-ORM</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm-400-000">我正在使用 ORM 插入 400,000 行，这很慢！</a></li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar faq-performance" >
        
<p id="faq-performance">性能
===</p>
<section id="x">
<span id="faq-new-caching"></span><h1>为什么升级到 1.4 和/或 2.x 后我的应用变得很慢？<a class="headerlink" href="#x" title="Permalink to this heading">¶</a></h1>
<p>从版本 1.4 开始，SQLAlchemy 包括一个 <a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL 编译缓存工具</span></a>，可以让 Core 和 ORM SQL 结构缓存其序列化形式，以及其他用于从语句抓取结果的结构信息，当下一次使用一个具有相同结构的Construct 时，可以跳过相对昂贵的字符串编译过程。这个系统依赖于所有 SQL 构造的功能实现，包括对象如 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>、<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 和:class:<cite>_types.TypeEngine</cite>，以产生一个 <a href="#id1"><span class="problematic" id="id2">**</span></a>缓存键**（cache key），其完全代表这些构造的状态，以影响 SQL 编译过程。</p>
<p>缓存系统充许 SQLAlchemy 1.4 及以上版本比 SQLAlchemy 1.3 更具备处理转换 SQL 构造的时间效率，但在使用方言和 SQL 构造时，这仅适用于开启缓存的情况; 如果没有开启，字符串编译通常与SQLAlchemy 1.3相似，在某些情况下有轻微的速度降低。</p>
<p>然而，在一种情况下，如果 SQLAlchemy 的新缓存系统已被禁用（由于以下原因），此时 ORM 的性能可能实际上比 1.3 或其他先前版本显著降低，原因是 ORM 延迟加载器和对象刷新查询中缺少缓存，在 1.3 和早期版本中使用了现已遗留的 <code class="docutils literal notranslate"><span class="pre">BakedQuery</span></code> 系统。如果应用在切换到1.4时看到显著性能降级（测量完成操作所需的时间规模30%或更高），则这可能是问题的根本原因，如下面要采取的措施。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL编译缓存</span></a> - 缓存系统概述</p>
<p><a class="reference internal" href="../errors.html#caching-caveats"><span class="std std-ref">Object will not produce a cache key, Performance Implications</span></a> - 关于不启用缓存的元素生成警告的额外信息。</p>
</div>
<section id="sql">
<h2>第一步-打开 SQL 日志并确认是否启用了缓存<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h2>
<p>在此，我们要使用描述在 <a class="reference internal" href="../core/connections.html#sql-caching-logging"><span class="std std-ref">engine logging</span></a> 中的技术，查找具有 <code class="docutils literal notranslate"><span class="pre">[no</span> <span class="pre">key]</span></code> 指示器或甚至是 <code class="docutils literal notranslate"><span class="pre">[dialect</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">support</span> <span class="pre">caching]</span></code> 的语句。当语句首次调用时，我们所看到的指示器将表明“[generated in Xs]”，其后对于绝大多数语句将表明“[cached since Xs ago]”。如果``[no key]`` 对于 SELECT 语句普遍存在，或者如果由于``[dialect does not support caching]`` 而完全禁用了缓存，则这可能是显著性能降低的原因。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching-logging"><span class="std std-ref">使用日志记录估计缓存性能</span></a></p>
</div>
</section>
<section id="id3">
<h2>第二步-识别阻止启用缓存的构造的对象<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>假设没有缓存语句，应用程序日志中会很早地发出警告（仅适用于SQLAlchemy 1.4.28及以上版本），指出不参与缓存的方言、<a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 对象和 SQL 构造。</p>
<p>对于扩展 <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> 和:class:<cite>_types.UserDefinedType</cite> 的所有自定义数据类型，以及 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.PickleType" title="sqlalchemy.types.PickleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleType</span></code></a> 等的子类，警告将如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.ext.SAWarning: MyType will not produce a cache key because the
``cache_ok`` attribute is not set to True. This can have significant
performance implications including some performance degradations in
comparison to prior SQLAlchemy versions. Set this attribute to True if this
type object&#39;s state is safe to use in a cache key, or False to disable this
warning.</pre></div>
</div>
<p>对于自定义和第三方 SQL 元素，例如使用在 <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span> 中描述的技术构建的元素，这些警告将如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL
compilation caching as it does not set the &#39;inherit_cache&#39; attribute to
``True``. This can have significant performance implications including some
performance degradations in comparison to prior SQLAlchemy versions. Set
this attribute to True if this object can make use of the cache key
generated by the superclass. Alternatively, this attribute may be set to
False which will disable this warning.</pre></div>
</div>
<p>对于使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">dialect</span></code> 类层次结构的自定义和第三方方言，警告将如下所示：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL
compilation caching as it does not set the &#39;supports_statement_cache&#39;
attribute to ``True``. This can have significant performance implications
including some performance degradations in comparison to prior SQLAlchemy
versions. Dialect maintainers should seek to set this attribute to True
after appropriate development and testing for SQLAlchemy 1.4 caching
support. Alternatively, this attribute may be set to False which will
disable this warning.</pre></div>
</div>
</section>
<section id="id4">
<h2>第三步-针对给定的对象启用缓存和/或寻找替代方案<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>缓解缓存不足的措施包括：</p>
<ul>
<li><p>查看并设置 <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok" title="sqlalchemy.types.ExternalType.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ExternalType.cache_ok</span></code></a>，对于所有扩展 <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>、<a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.UserDefinedType" title="sqlalchemy.types.UserDefinedType"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedType</span></code></a>，以及 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.PickleType" title="sqlalchemy.types.PickleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleType</span></code></a> 或其子类的自定义类型。仅在自定义类型不包含影响其如何呈现 SQL 的任何其他状态属性的情况下设置这个属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyCustomType</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="n">cache_ok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">impl</span> <span class="o">=</span> <span class="n">String</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>如果使用的类型来自第三方库，请咨询该库的维护人员，以便进行调整和发布。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/type_api.html#sqlalchemy.types.ExternalType.cache_ok" title="sqlalchemy.types.ExternalType.cache_ok"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ExternalType.cache_ok</span></code></a> - 激活缓存以用于自定义数据类型的要求背景。</p>
</div>
</li>
<li><p>确保第三方方言将 <a class="reference internal" href="../core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache" title="sqlalchemy.engine.Dialect.supports_statement_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Dialect.supports_statement_cache</span></code></a> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。这表示第三方方言的维护者已确保他们自己的方言能够与 SQLAlchemy 1.4 或更高版本一起使用，并且他们的方言不包括可能妨碍缓存的编译功能。由于有一些常见的编译模式可能会影响缓存，因此方言维护者检查并仔细测试，调整遗留未工作的模式是非常重要的。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#engine-thirdparty-caching"><span class="std std-ref">第三方方言的缓存</span></a> - 在 SQL 语句缓存中参与第三方方言的背景和例子。</p>
</div>
</li>
<li><p>自定义 SQL 类，包括使用 <span class="xref std std-ref">sqlalchemy.ext.compiler_toplevel</span> 创建的所有 DQL / DML 构造，以及 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 或 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象的零散子类。对于仅承载缓存键的次要子类，可以将 <a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache" title="sqlalchemy.sql.traversals.HasCacheKey.inherit_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HasCacheKey.inherit_cache</span></code></a> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/compiler.html#compilerext-caching"><span class="std std-ref">Enabling Caching Support for Custom Constructs</span></a> - 应用 <a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache" title="sqlalchemy.sql.traversals.HasCacheKey.inherit_cache"><code class="xref py py-attr docutils literal notranslate"><span class="pre">HasCacheKey.inherit_cache</span></code></a> 属性的指南。</p>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/connections.html#sql-caching"><span class="std std-ref">SQL编译缓存</span></a> - 缓存系统概述</p>
<p><a class="reference internal" href="../errors.html#caching-caveats"><span class="std std-ref">Object will not produce a cache key, Performance Implications</span></a> - 关于特定构造和/或方言未启用缓存时发出的警告的背景信息。</p>
</div>
</section>
</section>
<section id="sqlalchemy">
<span id="faq-how-to-profile"></span><h1>如何对由 SQLAlchemy 驱动的应用进行性能分析？<a class="headerlink" href="#sqlalchemy" title="Permalink to this heading">¶</a></h1>
<p>查找性能问题通常涉及两种策略。一个是查询分析，另一个是代码分析。</p>
<section id="id5">
<h2>查询分析<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>有时仅通过 SQL 日志记录（使用 Python 的 logging 模块或通过 <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code> 的 <code class="docutils literal notranslate"><span class="pre">echo=True</span></code> 参数启用）就可以了解操作花费的时间多久。例如，如果在 SQL 操作之后记录了一些内容，您将在日志中看到：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...
17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {&lt;params&gt;}
17:37:48,660 DEBUG [myapp.somemessage]</pre></div>
</div>
<p>如果在操作之后记录了 <code class="docutils literal notranslate"><span class="pre">myapp.somemessage</span></code>，则知道在 SQL 部分完成了耗时为 334ms 的操作。</p>
<p>日志记录 SQL 还将说明是否正在发出几十个/数百个查询，这些查询可以更好地组织成更少的查询。当使用 SQLAlchemy ORM 时，“急加载”功能部分地 (<code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code>) 或完全地 (<code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">subqueryload()</span></code>) 自动执行此操作，但是没有 ORM 的“急加载”往往意味着使用联接，以便在加载多个表的结果时可以在一个结果集中加载，而不是增加更多深度的查询（即 <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">+</span> <span class="pre">r*r2</span> <span class="pre">+</span> <span class="pre">r*r2*r3</span></code> …）。</p>
<p>对于更长期的查询分析，或实现应用程序端“缓慢查询”监视器，可以使用事件拦截光标执行，使用以下脚本：</p>
<blockquote>
<div><p>from sqlalchemy import event
from sqlalchemy.engine import Engine
import time
import logging</p>
<p>logging.basicConfig()
logger = logging.getLogger(“myapp.sqltime”)
logger.setLevel(logging.DEBUG)</p>
<p>&#64;event.listens_for(Engine, “before_cursor_execute”)
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):</p>
<blockquote>
<div><p>conn.info.setdefault(“query_start_time”, []).append(time.time())
logger.debug(“Start Query: %s”, statement)</p>
</div></blockquote>
<p>&#64;event.listens_for(Engine, “after_cursor_execute”)
def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):</p>
<blockquote>
<div><p>total = time.time() - conn.info[“query_start_time”].pop(-1)
logger.debug(“Query Complete!”)
logger.debug(“Total Time: %f”, total)</p>
</div></blockquote>
</div></blockquote>
<p>上面，我们使用 <a class="reference internal" href="../core/events.html#sqlalchemy.events.ConnectionEvents.before_cursor_execute" title="sqlalchemy.events.ConnectionEvents.before_cursor_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionEvents.before_cursor_execute()</span></code></a> 和 <a class="reference internal" href="../core/events.html#sqlalchemy.events.ConnectionEvents.after_cursor_execute" title="sqlalchemy.events.ConnectionEvents.after_cursor_execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionEvents.after_cursor_execute()</span></code></a> 事件在语句执行时建立拦截点。我们使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">info</span></code> 字典为连接附加一个计时器；我们在这里使用一个堆栈，以便极少数情况下光标执行事件可能会嵌套。</p>
</section>
<section id="faq-code-profiling">
<span id="id6"></span><h2>代码分析<a class="headerlink" href="#faq-code-profiling" title="Permalink to this heading">¶</a></h2>
<p>如果记录显示个别查询花费的时间过长，则需了解在数据库内部处理查询、通过网络发送结果、由 <span class="xref std std-term">DBAPI</span> 处理以及最终由 SQLAlchemy 的结果集和/或 ORM 层处理时花费的时间量，每个阶段都可以根据具体情况产生自己的个别瓶颈。</p>
<p>为此，您需要使用“Python 分析模块”。下面是一个简单的配方，可将性能分析嵌入上下文管理器中：</p>
<blockquote>
<div><p>import cProfile
import io
import pstats
import contextlib</p>
<p>&#64;contextlib.contextmanager
def profiled():</p>
<blockquote>
<div><p>pr = cProfile.Profile()
pr.enable()
yield
pr.disable()
s = io.StringIO()
ps = pstats.Stats(pr, stream=s).sort_stats(“cumulative”)
ps.print_stats()
# unc
# omment this to see who’s calling what
# ps.print_callers()
print(s.getvalue())</p>
</div></blockquote>
</div></blockquote>
<p>要对代码部分进行性能分析：</p>
<blockquote>
<div><dl class="simple">
<dt>with profiled():</dt><dd><p>session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()</p>
</dd>
</dl>
</div></blockquote>
<p>分析输出可用于了解时间花在哪里。下面是分析输出的一部分：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>13726 function calls (13042 primitive calls) in 0.014 seconds

Ordered by: cumulative time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)
220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)
220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)
   20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)
   20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)
    1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)
   21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(&lt;genexpr&gt;)
    2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)
    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)</pre></div>
</div>
<p>…</p>
<blockquote>
<div><p>在上面，我们看到 <code class="docutils literal notranslate"><span class="pre">instances()</span></code> SQLAlchemy 函数被调用了 222 次（递归调用，外部有 21 次），在所有调用中花费了 .011 秒的时间。</p>
</div></blockquote>
</section>
<section id="id7">
<h2>执行缓慢<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>其所具体调用的底层部分可以告诉我们时间花费在哪里。例如，如果您看到时间花费在 <code class="docutils literal notranslate"><span class="pre">cursor.execute()</span></code> 上，例如针对 DBAPI：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2    0.102    0.102    0.204    0.102 {method &#39;execute&#39; of &#39;sqlite3.Cursor&#39; objects}</pre></div>
</div>
<p>这表明数据库花费了很长时间来开始返回结果，这意味着您的查询应以添加索引或重组查询和/或基础架构的方式进行优化。为此，应使用查询计划等系统，如 EXPLAIN、SHOW PLAN 等提供的系统。</p>
</section>
<section id="core">
<h2>结果获取速度缓慢-Core<a class="headerlink" href="#core" title="Permalink to this heading">¶</a></h2>
<p>另一方面，如果您看到数千次与提取行相关的调用，或者对 <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> 有非常长的调用，这可能意味着查询返回的行数比预期的多，或者在获取行本身方面很慢。 ORM 本身通常使用 <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> 提取行（或者如果使用了 <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per" title="sqlalchemy.orm.Query.yield_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.yield_per()</span></code></a> 选项，则使用 <code class="docutils literal notranslate"><span class="pre">fetchmany()</span></code>）。</p>
<p>大量行的存在会通过 DBAPI 级别的非常缓慢的调用 <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> 表示出来：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2    0.300    0.600    0.300    0.600 {method &#39;fetchall&#39; of &#39;sqlite3.Cursor&#39; objects}</pre></div>
</div>
<p>即使结果看起来没有很多行，如果返回的行数出乎意料地大，则可能是由于多个行集组合在一起，而没有适当地将表连接在一起引起的。使用 SQLAlchemy Core 或 ORM 查询，在复杂查询中使用错误的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象将会导入预期之外的额外 FROM 子句。</p>
<p>另一方面，在 DBAPI 级别的快速调用 <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> 之后，当 SQLAlchemy 的 <code class="xref py py-class docutils literal notranslate"><span class="pre">CursorResult</span></code> 被要求进行 <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> 时，表明处理数据类型（例如 Unicode 转换等）的速度缓慢。</p>
<p>在这种情况下，确保查看已知性能调整建议的 <a class="reference internal" href="../dialects/index.html"><span class="std std-ref">方言文档</span></a>，尤其是对于像 Oracle 这样的数据库。可能存在与确保数值精度或字符串处理相关的系统，这些系统在所有情况下可能都不受需要。</p>
<p>在提取行合成性能的更低级别点中可能还存在更多的问题；例如，如果花费的时间似乎集中在像 <code class="docutils literal notranslate"><span class="pre">socket.receive()</span></code> 这样的调用中，这可能表明除网络连接之外的一切都很快，花费过多的时间是在数据移动过程中。</p>
</section>
<section id="orm">
<h2>结果获取速度缓慢-ORM<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h2>
<p>为检测 ORM 获取行的速度缓慢（这是最常见的性能问题），可以类似下面的例子，为每个 ORM 加载的行调用 <code class="docutils literal notranslate"><span class="pre">populate_state()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">_instance()</span></code> 函数以说明：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># ORM 在看到每个 ORM 加载的行时会调用 _instance，
# 对于 ORM 加载的行结果导致对象属性的填充，会调用 populate_state。
220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)
220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)</pre></div>
</div>
<p>ORM 将行转换为 ORM 映射对象的缓慢，是由于此操作的复杂性与 cPython 的开销共同作用的结果。减轻这种情况的常见策略包括：</p>
<ul>
<li><p>仅获取单个列，而不是完整实体，即：</p>
<blockquote>
<div><p>select(User.id, User.name)</p>
</div></blockquote>
<p>而不是：</p>
<blockquote>
<div><p>select(User)</p>
</div></blockquote>
</li>
<li><p>使用 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.Bundle" title="sqlalchemy.orm.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a> 对象组织基于列的结果：</p>
<blockquote>
<div><p>u_b = Bundle(“user”, User.id, User.name)
a_b = Bundle(“address”, Address.id, Address.email)</p>
<dl class="simple">
<dt>for user, address in session.execute(select(u_b, a_b).join(User.addresses)):</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>使用结果缓存-有关此功能的全面示例，请参阅 <span class="xref std std-ref">例子缓存</span>。</p></li>
<li><p>考虑使用像 PyPy 这样更快的解释器。</p></li>
</ul>
<p>分析的输出可能有些令人生畏，但经过一些练习后，它们很容易阅读。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/examples.html#examples-performance"><span class="std std-ref">性能</span></a> -一套带有捆绑的性能演示和性能分析能力。</p>
</div>
</section>
</section>
<section id="orm-400-000">
<h1>我正在使用 ORM 插入 400,000 行，这很慢！<a class="headerlink" href="#orm-400-000" title="Permalink to this heading">¶</a></h1>
<p>由 ORM 插入的性质已更改，因为随着SQLAlchemy 2.0 的发布，除 MySQL 外的大多数内置驱动程序都支持具有 <span class="xref std std-ref">insertmanyvalues</span> 支持的 RETURNING 语句。有关详细信息，请参见 <span class="xref std std-ref">change_6047</span> 部分。</p>
<p>整体而言，除 MySQL 外的 SQLAlchemy 内置驱动程序现在应该提供非常快的 ORM 大块插入性能。</p>
<p>第三方驱动程序可以通过进行一些小的代码更改来选择新的大块基础架构，假设它们的后端支持必要的语法。SQLAlchemy 开发人员鼓励第三方方言的用户发布这些驱动程序的问题，以便他们可以联系 SQLAlchemy 开发人员寻求帮助。</p>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="ormconfiguration.html" title="previous chapter">ORM配置</a>
        Next:
        <a href="sessions.html" title="next chapter">Sessions / Queries</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 10:07:08

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


