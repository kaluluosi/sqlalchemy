<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    SQLAlchemy 1.1新功能
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="变更和迁移" href="index.html" />
        <link rel="next" title="SQLAlchemy 1.0有哪些新特性？" href="migration_10.html" />
        <link rel="prev" title="SQLAlchemy 1.2有哪些新特性?" href="migration_12.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="变更和迁移">变更和迁移</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="migration_20.html">SQLAlchemy 2.0 - 主要迁移指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="whatsnew_20.html">SQLAlchemy 2.0 有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_20.html">2.0 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_14.html">1.4 版本更新历史</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9版本更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">版本记录</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_14.html">SQLAlchemy 1.4有哪些新内容？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">SQLAlchemy 1.3有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">SQLAlchemy 1.2有哪些新特性?</a></span></li>
<li class="selected"><span class="link-container"><strong>SQLAlchemy 1.1新功能</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">简介</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id2">平台/安装器更改</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#setuptools">安装时现在需要Setuptools</a></span></li>
<li><span class="link-container"><a class="reference external" href="#c">启用/禁用C扩展的构建仅通过环境变量完成</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm">新功能和改进 - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#change-2677">新会话生命周期事件</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id10">新状态转换事件</a></span></li>
<li><span class="link-container"><a class="reference external" href="#deleted-persistent">新增的对象状态“deleted”，已删除对象不再是“persistent”</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id11">强标识映射已被弃用</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#init-scalar-orm">新的 init_scalar() 事件可截取 ORM 级别默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#hash-orm">关于“不可Hash”类型的特定检查，对 ORM 行进行了排重处理</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sql">对映射类、实例传递 SQL 字面量的特定检查已添加</a></span></li>
<li><span class="link-container"><a class="reference external" href="#feature-indexable">新的可索引 ORM 扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3250">新选项允许显式保留空值而非默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3582">继续单表继承查询方面的修复</a></span></li>
<li><span class="link-container"><a class="reference external" href="#savepoint">取消数据库 SAVEPOINT 时，改进会话状态</a></span></li>
<li><span class="link-container"><a class="reference external" href="#xy">修复了错误“新实例X与持久实例Y冲突”的刷新错误</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-2349">连同继承映射的级联删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3630">必须不会再处理具有相同名称的反向引用，该反向引用适用于具体的继承子类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3749">当创建两个映射器在继承场景中，如果在两者上都放置具有相同名称的关系，则不会再次出现警告</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm-orm">改善的ORM特性和改进 - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#session-mergepersistent">Session.merge会将未决冲突解决为persistent的相同方式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#many-to-one">修复了用户启动的外键操纵与many-to-one对象移动相关问题</a></span></li>
<li><span class="link-container"><a class="reference external" href="#query-correlate">通过多态实体提高了 <cite>Query.correlate</cite></a></span></li>
<li><span class="link-container"><a class="reference external" href="#query-session">字符串化Query将查阅 Session 获取正确的方言</a></span></li>
<li><span class="link-container"><a class="reference external" href="#entity-joined-eager-loading">在一个行中多次存在相同的entity时，加入了joined eager loading机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mutable-toplevelmutablelistmutableset">为mutable_toplevel扩展了新的MutableList和MutableSet辅助类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#raise-raise-on-sql">新的”raise” / “raise_on_sql”加载器策略</a></span></li>
<li><span class="link-container"><a class="reference external" href="#order-by">映射器的order_by参数已不再使用</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id62">新功能和改进 - 核心</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#enginesbaseexception">Engines现在会为BaseException类型的情况使连接失效，并运行错误处理程序</a></span></li>
<li><span class="link-container"><a class="reference external" href="#insert-update-deletecte">支持INSERT，UPDATE，DELETE的CTE</a></span></li>
<li><span class="link-container"><a class="reference external" href="#rangerows">支持窗口函数中的RANGE和ROWS指定</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sql-lateral">支持SQL LATERAL关键字</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tablesample">支持TABLESAMPLE</a></span></li>
<li><span class="link-container"><a class="reference external" href="#autoincrement">现在不再针对复合主键列隐式启用`.autoincrement`指令</a></span></li>
<li><span class="link-container"><a class="reference external" href="#is-distinct-fromis-not-distinct-from">支持IS DISTINCT FROM和IS NOT DISTINCT FROM</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id79">``.autoincrement``指令不再针对复合主键列隐式启用</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#textasfrom-columns">TextAsFrom.columns()现在按位置工作</a></span></li>
<li><span class="link-container"><a class="reference external" href="#core-orm-sql-constructs">对于Core/ORM SQL constructs，位置匹配优先于基于名称的匹配</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id87">更不可能出现“模棱两可列”错误消息</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#corepython-enum">在Core中添加对Python原生``enum``类型和兼容形式的支持</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#enum-enums">``Enum.enums``集合现在是一个列表而不是一个元组</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#change-2837">日志记录和异常显示中现在会截断大的参数和行值</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#jsonormnull">JSON支持现在针对ORM操作插入“null”，在未出现时省略</a></span></li>
<li><span class="link-container"><a class="reference external" href="#json-null">添加新的JSON.NULL常量</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#within-group-array-aggset">新功能函数，”WITHIN GROUP”，array_agg和set集合函数</a></span></li>
<li><span class="link-container"><a class="reference external" href="#typedecoratorenum-boolean-schema">TypeDecorator现在自动使用Enum，Boolean，“schema”类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#table">Table对象的多租户模式翻译</a></span></li>
<li><span class="link-container"><a class="reference external" href="#core-sql">Core SQL构造的“友好”字符串化没有发现方言现在</a></span></li>
<li><span class="link-container"><a class="reference external" href="#type-coercesql">type_coerce函数现在是一个持久的SQL元素</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id107">主要行为更改 - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#jsonjson-null">如果没有提供值且未建立默认值，则JSON列将不插入JSON NULL</a></span></li>
<li><span class="link-container"><a class="reference external" href="#distinct-order-by-validates">DISTINCT + ORDER BY的相同命名的&#64;validates装饰符现在会引发异常</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#core">主要行为更改 - Core</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#textclause-columns">当按位置传递列时，TextClause.columns()将按位置而不是按名称进行匹配</a></span></li>
<li><span class="link-container"><a class="reference external" href="#server-default">字符串server_default现在是文字引用</a></span></li>
<li><span class="link-container"><a class="reference external" href="#limit-offset-order-byselectunion">带有LIMIT / OFFSET / ORDER BY的SELECT的UNION或类似操作现在在嵌入式选​​择中加括号</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dialect-improvements-and-changes-postgresql">Dialect Improvements and Changes - PostgreSQL</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#insert-on-conflict-do-update-do-nothing">支持INSERT.. ON CONFLICT（DO UPDATE | DO NOTHING）</a></span></li>
<li><span class="link-container"><a class="reference external" href="#arrayjson">ARRAY和JSON类型现在正确指定为“不可哈希的”</a></span></li>
<li><span class="link-container"><a class="reference external" href="#array-json-hstoresql">从ARRAY，JSON，HSTORE的索引访问现在正确建立了正确的SQL类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id108">减小一维数组大小</a></span></li>
<li><span class="link-container"><a class="reference external" href="#the-json-cast-astext">The JSON cast() 操作现在要求显式调用 <cite>.astext</cite></a></span></li>
<li><span class="link-container"><a class="reference external" href="#arrayenumenum-create-type">ARRAY与ENUM将为ENUM生成 CREATE TYPE</a></span></li>
<li><span class="link-container"><a class="reference external" href="#check">```check```约束现在被反映</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id117">可以分别检查“普通”和“材质化”视图</a></span></li>
<li><span class="link-container"><a class="reference external" href="#indextablespace">向Index添加tablespace选项</a></span></li>
<li><span class="link-container"><a class="reference external" href="#for-update-skip-for-no-key-update-for-key-share">对于FOR UPDATE SKIP锁定/ FOR NO KEY UPDATE / FOR KEY SHARE的支持</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dialect-improvements-and-changes-mysql">Dialect Improvements and Changes - MySQL</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#mysql-json">MySQL JSON 支持</a></span></li>
<li><span class="link-container"><a class="reference external" href="#autocommit">新增对 AUTOCOMMIT“隔离级别”的支持</a></span></li>
<li><span class="link-container"><a class="reference external" href="#auto-increment">不再为具有AUTO_INCREMENT的组合主键生成隐式键</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dialect-improvements-and-changes-sqlite">Dialect Improvements and Changes - SQLite</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlite-3-7-16">SQLite 3.7.16 版本解决了的正确处理右嵌套链接</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlite-3-10-0">取消 SQLite 版本 3.10.0 解决了集合的列名问题的“点”符号列名的解决方法</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-sqlite-schemas">对远程模式的支持做出了改进</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3629">反射主键约束名称</a></span></li>
<li><span class="link-container"><a class="reference external" href="#max">现在不再强制字符串/变长类型在反映时显式表示为“max”</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="migration_10.html">SQLAlchemy 1.0有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_09.html">SQLAlchemy 0.9 的新特性</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_08.html">SQLAlchemy 0.8有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">SQLAlchemy 0.7有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">SQLAlchemy 0.6 有哪些新变化?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">SQLAlchemy 0.5有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id1">主要文档更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id6">退化源</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id7">需求更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id8">ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id21">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id22">模式/类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id23">连接池不再默认为线程本地</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#args-args">*args已接受，不再接受*args</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id44">删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id77">已重命名或已移动</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id86">已弃用</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">SQLAlchemy 0.4有什么新功能？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id1">首先要做什么</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id2">模块导入</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id3">对象关系映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id22">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id26">架构和反射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id28">SQL执行</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="migration_12.html" title="previous chapter">SQLAlchemy 1.2有哪些新特性?</a></li>
                <li><b>Next:</b>
                <a href="migration_10.html" title="next chapter">SQLAlchemy 1.0有哪些新特性？</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="变更和迁移">变更和迁移</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#sqlalchemy-1-1">SQLAlchemy 1.1新功能</a><ul>
<li><a class="reference internal" href="#id1">简介</a></li>
<li><a class="reference internal" href="#id2">平台/安装器更改</a><ul>
<li><a class="reference internal" href="#setuptools">安装时现在需要Setuptools</a></li>
<li><a class="reference internal" href="#c">启用/禁用C扩展的构建仅通过环境变量完成</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm">新功能和改进 - ORM</a><ul>
<li><a class="reference internal" href="#change-2677">新会话生命周期事件</a><ul>
<li><a class="reference internal" href="#id10">新状态转换事件</a></li>
<li><a class="reference internal" href="#deleted-persistent">新增的对象状态“deleted”，已删除对象不再是“persistent”</a></li>
<li><a class="reference internal" href="#id11">强标识映射已被弃用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#init-scalar-orm">新的 init_scalar() 事件可截取 ORM 级别默认值</a></li>
<li><a class="reference internal" href="#hash-orm">关于“不可Hash”类型的特定检查，对 ORM 行进行了排重处理</a></li>
<li><a class="reference internal" href="#sql">对映射类、实例传递 SQL 字面量的特定检查已添加</a></li>
<li><a class="reference internal" href="#feature-indexable">新的可索引 ORM 扩展</a></li>
<li><a class="reference internal" href="#change-3250">新选项允许显式保留空值而非默认值</a></li>
<li><a class="reference internal" href="#change-3582">继续单表继承查询方面的修复</a></li>
<li><a class="reference internal" href="#savepoint">取消数据库 SAVEPOINT 时，改进会话状态</a></li>
<li><a class="reference internal" href="#xy">修复了错误“新实例X与持久实例Y冲突”的刷新错误</a></li>
<li><a class="reference internal" href="#change-2349">连同继承映射的级联删除</a></li>
<li><a class="reference internal" href="#change-3630">必须不会再处理具有相同名称的反向引用，该反向引用适用于具体的继承子类</a></li>
<li><a class="reference internal" href="#change-3749">当创建两个映射器在继承场景中，如果在两者上都放置具有相同名称的关系，则不会再次出现警告</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm-orm">改善的ORM特性和改进 - ORM</a><ul>
<li><a class="reference internal" href="#session-mergepersistent">Session.merge会将未决冲突解决为persistent的相同方式</a></li>
<li><a class="reference internal" href="#many-to-one">修复了用户启动的外键操纵与many-to-one对象移动相关问题</a></li>
<li><a class="reference internal" href="#query-correlate">通过多态实体提高了 <cite>Query.correlate</cite> 方法</a></li>
<li><a class="reference internal" href="#query-session">字符串化Query将查阅 Session 获取正确的方言</a></li>
<li><a class="reference internal" href="#entity-joined-eager-loading">在一个行中多次存在相同的entity时，加入了joined eager loading机制</a></li>
<li><a class="reference internal" href="#mutable-toplevelmutablelistmutableset">为mutable_toplevel扩展了新的MutableList和MutableSet辅助类</a></li>
<li><a class="reference internal" href="#raise-raise-on-sql">新的”raise” / “raise_on_sql”加载器策略</a></li>
<li><a class="reference internal" href="#order-by">映射器的order_by参数已不再使用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id62">新功能和改进 - 核心</a><ul>
<li><a class="reference internal" href="#enginesbaseexception">Engines现在会为BaseException类型的情况使连接失效，并运行错误处理程序</a></li>
<li><a class="reference internal" href="#insert-update-deletecte">支持INSERT，UPDATE，DELETE的CTE</a></li>
<li><a class="reference internal" href="#rangerows">支持窗口函数中的RANGE和ROWS指定</a></li>
<li><a class="reference internal" href="#sql-lateral">支持SQL LATERAL关键字</a></li>
<li><a class="reference internal" href="#tablesample">支持TABLESAMPLE</a></li>
<li><a class="reference internal" href="#autoincrement">现在不再针对复合主键列隐式启用`.autoincrement`指令</a></li>
<li><a class="reference internal" href="#is-distinct-fromis-not-distinct-from">支持IS DISTINCT FROM和IS NOT DISTINCT FROM</a></li>
<li><a class="reference internal" href="#id79">``.autoincrement``指令不再针对复合主键列隐式启用</a><ul>
<li><a class="reference internal" href="#textasfrom-columns">TextAsFrom.columns()现在按位置工作</a></li>
<li><a class="reference internal" href="#core-orm-sql-constructs">对于Core/ORM SQL constructs，位置匹配优先于基于名称的匹配</a></li>
<li><a class="reference internal" href="#id87">更不可能出现“模棱两可列”错误消息</a></li>
</ul>
</li>
<li><a class="reference internal" href="#corepython-enum">在Core中添加对Python原生``enum``类型和兼容形式的支持</a><ul>
<li><a class="reference internal" href="#enum-enums">``Enum.enums``集合现在是一个列表而不是一个元组</a></li>
</ul>
</li>
<li><a class="reference internal" href="#change-2837">日志记录和异常显示中现在会截断大的参数和行值</a><ul>
<li><a class="reference internal" href="#jsonormnull">JSON支持现在针对ORM操作插入“null”，在未出现时省略</a></li>
<li><a class="reference internal" href="#json-null">添加新的JSON.NULL常量</a></li>
</ul>
</li>
<li><a class="reference internal" href="#within-group-array-aggset">新功能函数，”WITHIN GROUP”，array_agg和set集合函数</a></li>
<li><a class="reference internal" href="#typedecoratorenum-boolean-schema">TypeDecorator现在自动使用Enum，Boolean，“schema”类型</a></li>
<li><a class="reference internal" href="#table">Table对象的多租户模式翻译</a></li>
<li><a class="reference internal" href="#core-sql">Core SQL构造的“友好”字符串化没有发现方言现在</a></li>
<li><a class="reference internal" href="#type-coercesql">type_coerce函数现在是一个持久的SQL元素</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id107">主要行为更改 - ORM</a><ul>
<li><a class="reference internal" href="#jsonjson-null">如果没有提供值且未建立默认值，则JSON列将不插入JSON NULL</a></li>
<li><a class="reference internal" href="#distinct-order-by-validates">DISTINCT + ORDER BY的相同命名的&#64;validates装饰符现在会引发异常</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core">主要行为更改 - Core</a><ul>
<li><a class="reference internal" href="#textclause-columns">当按位置传递列时，TextClause.columns()将按位置而不是按名称进行匹配</a></li>
<li><a class="reference internal" href="#server-default">字符串server_default现在是文字引用</a></li>
<li><a class="reference internal" href="#limit-offset-order-byselectunion">带有LIMIT / OFFSET / ORDER BY的SELECT的UNION或类似操作现在在嵌入式选​​择中加括号</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dialect-improvements-and-changes-postgresql">Dialect Improvements and Changes - PostgreSQL</a><ul>
<li><a class="reference internal" href="#insert-on-conflict-do-update-do-nothing">支持INSERT.. ON CONFLICT（DO UPDATE | DO NOTHING）</a></li>
<li><a class="reference internal" href="#arrayjson">ARRAY和JSON类型现在正确指定为“不可哈希的”</a></li>
<li><a class="reference internal" href="#array-json-hstoresql">从ARRAY，JSON，HSTORE的索引访问现在正确建立了正确的SQL类型</a></li>
<li><a class="reference internal" href="#id108">减小一维数组大小</a></li>
<li><a class="reference internal" href="#the-json-cast-astext">The JSON cast() 操作现在要求显式调用 <cite>.astext</cite></a></li>
<li><a class="reference internal" href="#arrayenumenum-create-type">ARRAY与ENUM将为ENUM生成 CREATE TYPE</a></li>
<li><a class="reference internal" href="#check">```check```约束现在被反映</a></li>
<li><a class="reference internal" href="#id117">可以分别检查“普通”和“材质化”视图</a></li>
<li><a class="reference internal" href="#indextablespace">向Index添加tablespace选项</a></li>
<li><a class="reference internal" href="#for-update-skip-for-no-key-update-for-key-share">对于FOR UPDATE SKIP锁定/ FOR NO KEY UPDATE / FOR KEY SHARE的支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dialect-improvements-and-changes-mysql">Dialect Improvements and Changes - MySQL</a><ul>
<li><a class="reference internal" href="#mysql-json">MySQL JSON 支持</a></li>
<li><a class="reference internal" href="#autocommit">新增对 AUTOCOMMIT“隔离级别”的支持</a></li>
<li><a class="reference internal" href="#auto-increment">不再为具有AUTO_INCREMENT的组合主键生成隐式键</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dialect-improvements-and-changes-sqlite">Dialect Improvements and Changes - SQLite</a><ul>
<li><a class="reference internal" href="#sqlite-3-7-16">SQLite 3.7.16 版本解决了的正确处理右嵌套链接</a></li>
<li><a class="reference internal" href="#sqlite-3-10-0">取消 SQLite 版本 3.10.0 解决了集合的列名问题的“点”符号列名的解决方法</a></li>
<li><a class="reference internal" href="#change-sqlite-schemas">对远程模式的支持做出了改进</a></li>
<li><a class="reference internal" href="#change-3629">反射主键约束名称</a></li>
<li><a class="reference internal" href="#max">现在不再强制字符串/变长类型在反映时显式表示为“max”</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar changelog-migration_11" >
        
<section id="sqlalchemy-1-1">
<h1>SQLAlchemy 1.1新功能<a class="headerlink" href="#sqlalchemy-1-1" title="Permalink to this heading">¶</a></h1>
<div class="admonition- admonition">
<p class="admonition-title">关于本文档</p>
<p>该文档描述的是SQLAlchemy版本1.0和版本1.1之间的更改。</p>
</div>
<section id="id1">
<h2>简介<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>本指南介绍了SQLAlchemy版本1.1中的新功能，并记录了影响从SQLAlchemy 1.0系列迁移应用程序的用户的更改。
请仔细查看潜在的不兼容行为的行为更改部分。</p>
</section>
<section id="id2">
<h2>平台/安装器更改<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<section id="setuptools">
<h3>安装时现在需要Setuptools<a class="headerlink" href="#setuptools" title="Permalink to this heading">¶</a></h3>
<p>多年来，SQLAlchemy的``setup.py``文件支持安装得有Setuptools，也支持不使用Setuptools进行操作；支持使用直接的Distutils的“后备”模式。
在现在不再支持没有Setuptools安装的Python环境的情况下，为了更充分地支持Setuptools的特征集，特别是支持pytest与之进行集成以及像“extras”之类的功能，<a href="#id3"><span class="problematic" id="id4">``</span></a>setup.py``现在完全依赖于Setuptools。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../intro.html#installation"><span class="std std-ref">安装指南</span></a></p>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">:ticket:`3489`</span></a></p>
</div>
</section>
<section id="c">
<h3>启用/禁用C扩展的构建仅通过环境变量完成<a class="headerlink" href="#c" title="Permalink to this heading">¶</a></h3>
<p>默认情况下，在安装时构建C扩展是可能的。自SQLAlchemy 0.8.6 / 0.9.4起，通过将``DISABLE_SQLALCHEMY_CEXT``环境变量提供给安装过程可以禁用C扩展版本。以前使用``–without-cextensions``参数的方法已删除，因为该方法使用了setuptools的已弃用特性。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../intro.html#c-extensions"><span class="std std-ref">生成Cython扩展</span></a></p>
</div></blockquote>
<p><a href="#id7"><span class="problematic" id="id8">:ticket:`3500`</span></a></p>
</div>
</section>
</section>
<section id="orm">
<h2>新功能和改进 - ORM<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h2>
<section id="change-2677">
<span id="id9"></span><h3>新会话生命周期事件<a class="headerlink" href="#change-2677" title="Permalink to this heading">¶</a></h3>
<p>长期以来，  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  支持事件，这些事件允许在一定程度上跟踪对象的状态更改，包括  :meth:` .SessionEvents.before_attach`  ，  <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach" title="sqlalchemy.orm.SessionEvents.after_attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SessionEvents.after_attach()</span></code></a>  和  :meth:` .SessionEvents.before_flush`  .
会话文档还记录了主要的对象状态，参见   :ref:` session_object_states` 。但是，从未存在过通过这些转换精确定位对象的系统。此外，“已删除”对象的状态历史上一直模糊不清，因为这些对象在“持久”状态和“分离”状态之间具有某种功能。</p>
<p>为了清理这个区域并允许会话状态转换的领域完全透明，添加了一系列新事件，这些事件旨在覆盖对象可能发生的所有状态之间的任何方式，此外该“已删除”状态已在会话对象状态的范围内获得了其自己的官方状态名称。</p>
<section id="id10">
<h4>新状态转换事件<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h4>
<p>单位作为:期间的对象状态之间转换，例如：术语:<cite>persistent</cite>，期间等，现在可以拦截以特定转换进行覆盖功能。
现在，在  <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.SessionEvents" title="sqlalchemy.orm.SessionEvents"><code class="xref py py-class docutils literal notranslate"><span class="pre">SessionEvents</span></code></a> .Session` 对象移入、移出一个对象o, 还有所述:return  :meth:` .Session.rollback`  , 满足所有状态转换。</p>
<p>总共有**十个新事件**。一个新的文档部分   <a class="reference internal" href="../orm/session_events.html#session-lifecycle-events"><span class="std std-ref">对象生命周期事件</span></a>  阐述了这些事件的概要。</p>
</section>
<section id="deleted-persistent">
<h4>新增的对象状态“deleted”，已删除对象不再是“persistent”<a class="headerlink" href="#deleted-persistent" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><span class="xref std std-ref">persistent</span> .Session` 中一直被记录作为具有有效数据库标识符的对象；但是，对于在刷新时被删除的对象，它们一直处于一片灰色地带，在其中它们不是真正的“分离”从  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> ,因为在回滚中它们仍然可以被恢复，但是也不是真正的“persistent”，因为它们的数据库标识符已被删除，它们不在标识映射中。</p>
</div></blockquote>
<p>为了解决这种灰色地带，在添加的新事件中，介绍了一种新的对象状态：term:<cite>deleted</cite>。在新的“deleted”状态之间存在“persistent”状态和“detached”状态。使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code>  标记删除的对象将保留在“persistent”状态，直到执行刷新；在那时，它将从标识映射中删除，将移至“deleted”状态，并调用  :meth:` .SessionEvents.persistent_to_deleted`  钩子。如果  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> .SessionEvents.deleted_to_persistent` 转换。否则，如果  :class:` .Session` .SessionEvents.deleted_to_detached` 转换。</p>
<p>此外，  <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState.persistent" title="sqlalchemy.orm.InstanceState.persistent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InstanceState.persistent</span></code></a>  读取器**不再返回true**用于处于新的“deleted”状态的对象；相反，  :attr:` .InstanceState.deleted`  读取器已增强，以可靠地报告此新状态。当对象分离时，  <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState.deleted" title="sqlalchemy.orm.InstanceState.deleted"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InstanceState.deleted</span></code></a>  返回:False，并将  :attr:` .InstanceState.detached`  读取器设置为True。要确定对象是否在当前事务或先前事务中已删除，请使用  <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted" title="sqlalchemy.orm.InstanceState.was_deleted"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InstanceState.was_deleted</span></code></a>  读取器。</p>
</section>
<section id="id11">
<h4>强标识映射已被弃用<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h4>
<p>强标识映射的新系列转换事件是检测对象在其进出标识映射过程中的泄漏的来源灵感，以便可以维护“强引用”，以反映该对象在映射中的输入输出。具有此新功能，不再需要  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.weak_identity_map</span></code>  参数和相应的   :class:` .StrongIdentityMap`  对象。多年来，该选项一直作为“强引用”行为的SQLAlchemy的一部分存在，许多应用程序都写了可以采用该行为的应用程序级构造功能。长期以来，已建议将对象的强引用跟踪方法区分为   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  的固有工作，而应作为应用程序级别的构造而建立应用程序所需。新 Event 模型使甚至可以复制强标识映射的确切行为。请参阅   :ref:` session_referencing_behavior` ，了解如何替换强标识映射的新配方。</p>
<blockquote>
<div><p><a href="#id12"><span class="problematic" id="id13">:ticket:`2677`</span></a></p>
</div></blockquote>
</section>
</section>
<section id="init-scalar-orm">
<span id="change-1311"></span><h3>新的 init_scalar() 事件可截取 ORM 级别默认值<a class="headerlink" href="#init-scalar-orm" title="Permalink to this heading">¶</a></h3>
<p>访问未设置的属性时，ORM 将生成一个“None”值，用于非永久对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyObj</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">some_value</span>
<span class="go">None</span></pre></div>
</div>
<p>即使在对象持久之前，这里也有用例对应于核心生成的默认值 。为了适应这种用例，添加了一个新事件  <a class="reference internal" href="../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar" title="sqlalchemy.orm.AttributeEvents.init_scalar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AttributeEvents.init_scalar()</span></code></a> 。新示例` <cite>active_column_defaults.py`</cite>，演示了一种简单用法，可以实现如下效果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">MyObj</span><span class="p">()</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">some_value</span>
  <span class="s2">&quot;my default&quot;</span>

<span class="p">:</span><span class="n">ticket</span><span class="p">:</span><span class="err">`</span><span class="mi">1311</span><span class="err">`</span></pre></div>
</div>
</section>
<section id="hash-orm">
<span id="change-3499"></span><h3>关于“不可Hash”类型的特定检查，对 ORM 行进行了排重处理<a class="headerlink" href="#hash-orm" title="Permalink to this heading">¶</a></h3>
<p>查询对象  <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  具有“排重”行为，用于返回包含  :term:` ORM`  映射实体（例如，完整的映射对象，而不是单个列值）的行。其主要目的是使实体的处理与标识映射一起自然而然地进行，包括为目的而使用连接的急切加载中通常表示的重复实体，以及用于过滤额外列的目的。</p>
<p>此排重依赖于行内元素的可哈希性。随着PostgreSQL的特殊类型（如  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> ,` _postgresql.HSTORE` 和  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> ）的引入，类型在行内的经验与对这里遇到问题的类型的浩瀚的描述经历了更多预变化。</p>
<p>事实上，自版本0.8以来，SQLAlchemy在数据类型上包含了一个被标记为“不可Hash”的标志，但是这个标志并没有在所有内置的类型上一致使用。如在   <a class="reference internal" href="#change-3499-postgresql"><span class="std std-ref">ARRAY和JSON类型现在正确指定为“不可哈希的”</span></a>  中所述，将为PostgreSQL的所有“结构型”类型设置一致的标志。</p>
<blockquote>
<div><p><a class="reference internal" href="../core/type_api.html#sqlalchemy.types.NullType" title="sqlalchemy.types.NullType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullType</span></code></a>  类型上也设置了“不可Hash”标志，因为  :class:` .NullType`  用于引用任何类型的未知表达式。因为在大多数情况下  <code class="xref py py-attr docutils literal notranslate"><span class="pre">func</span></code>  不会实际知道给出的函数名称，所以  :attr:` .func`  应用于大多数用途的  <code class="xref py py-attr docutils literal notranslate"><span class="pre">func</span></code>  将很可能使行车去重失效。以下示例说明了对字符串表达式应用` <a href="#id14"><span class="problematic" id="id15">`</span></a>func.substr()``以及对datetime表达式应用``func.date()``将返回重复行，这是由于不存在应用显式键入的情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">substr</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">some_thing</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bs</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">func</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">date_created</span><span class="p">,</span> <span class="s2">&quot;start of month&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;month&quot;</span><span class="p">),</span>
        <span class="n">User</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>
    <span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span></pre></div>
</div>
</div></blockquote>
<p>上述示例为了保持去重，应指定如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">substr</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">some_thing</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">),</span> <span class="n">A</span><span class="p">)</span>
    <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bs</span><span class="p">))</span>
    <span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">func</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">date_created</span><span class="p">,</span> <span class="s2">&quot;start of month&quot;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">DateTime</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;month&quot;</span><span class="p">),</span>
        <span class="n">User</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>
    <span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span></pre></div>
</div>
<p>此外，所谓的“不可Hash”类型的处理方式与以前的版本略有不同；在这里，我们使用``id()``函数从这些结构中获取“哈希值”，就像将任何普通映射对象一样。这取代了以前的方法，该方法将计数器应用于对象。</p>
<blockquote>
<div><p><a href="#id16"><span class="problematic" id="id17">:ticket:`3499`</span></a></p>
</div></blockquote>
</section>
<section id="sql">
<span id="change-3321"></span><h3>对映射类、实例传递 SQL 字面量的特定检查已添加<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h3>
<p>现在类型系统具有特定检查，用于在上下文中传递 SQLAlchemy“可检查”对象，这使得它们处理为字面值时产生错误。任何Python内置对象都可以作为SQL值合法传递（不是  <a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> ` __clause_element__()``方法的方法，为该对象提供有效的SQL表达式。
对于不提供此功能的SQLAlchemy对象，例如映射类、映射程序和映射实例，在后面发生故障之前，会发出更详细的错误消息，而不会将其传递给DBAPI。下面是一个例子，其中字符串属性“User.name”与完整实例“User()”进行比较，而不是与字符串值进行比较:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">some_user</span><span class="p">)</span>
<span class="go">sqlalchemy.exc.ArgumentError: Object &lt;__main__.User object at 0x103167e90&gt; is not legal as a SQL literal value</span></pre></div>
</div>
<p>在进行比较“User.name == some_user”时，立即引发异常。以前，上面的比较将生成一个SQL表达式，只有在解决为DBAPI执行调用时才会失败；映射的“User”对象最终将成为一个拒绝DBAPI的绑定参数。</p>
<p>请注意，在上述示例中，该表达式失败，因为“User.name”是一个基于字符串的（例如列导向）属性。更改不*不*使用显示编写的类型时，将许多使用:<cite>func`的其他示例将其应用于函数名称中返回。.func不实际知道大多数情况下给出的函数名称，因此  :attr:</cite>.func`  将使行车去重失效。以下示例说明这种情况:将时期应用于日期时间表达式，将Substr()应用于字符串表达式;这两个示例将返回重复行，比如之前使用了明确类型:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">substr</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">some_thing</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bs</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">users</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">func</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">date_created</span><span class="p">,</span> <span class="s2">&quot;start of month&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;month&quot;</span><span class="p">),</span>
        <span class="n">User</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>
    <span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="p">)</span></pre></div>
</div>
<p>上述示例为了保持排重，应该被指定为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">substr</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">some_thing</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">),</span> <span class="n">A</span><span class="p">)</span>
      <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">bs</span><span class="p">))</span>
      <span class="o">.</span><span class="n">all</span><span class="p">()</span>
  <span class="p">)</span>

  <span class="n">users</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
          <span class="n">func</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">date_created</span><span class="p">,</span> <span class="s2">&quot;start of month&quot;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">DateTime</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;month&quot;</span><span class="p">),</span>
          <span class="n">User</span><span class="p">,</span>
      <span class="p">)</span>
      <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>
      <span class="o">.</span><span class="n">all</span><span class="p">()</span>
  <span class="p">)</span>

<span class="p">:</span><span class="n">ticket</span><span class="p">:</span><span class="err">`</span><span class="mi">3321</span><span class="err">`</span></pre></div>
</div>
</section>
<section id="feature-indexable">
<span id="id18"></span><h3>新的可索引 ORM 扩展<a class="headerlink" href="#feature-indexable" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><span class="xref std std-ref">indexable_toplevel</span>  扩展是混合属性功能的扩展，它允许构建属性，该属性引用“可索引”数据类型的特定元素，例如阵列或JSON 字段:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;person&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">JSON</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">index_property</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</div></blockquote>
<p>上述代码中，<code class="docutils literal notranslate"><span class="pre">name``属性将从JSON列``data``中读取/写入</span></code>”name”`` 字段，并初始化为空字典:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">person</span><span class="o">.</span><span class="n">name</span>
<span class="go">foobar</span></pre></div>
</div>
<p>当修改属性时，该扩展也会触发更改事件，因此无需使用   <a class="reference internal" href="../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict" title="sqlalchemy.ext.mutable.MutableDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableDict</span></code></a>  来跟踪此更改。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">indexable_toplevel</span></p>
</div>
</section>
<section id="change-3250">
<span id="id19"></span><h3>新选项允许显式保留空值而非默认值<a class="headerlink" href="#change-3250" title="Permalink to this heading">¶</a></h3>
<p>与   <a class="reference internal" href="#change-3514"><span class="std std-ref">JSON支持现在针对ORM操作插入“null”，在未出现时省略</span></a>  一起添加到PostgreSQL的新JSON-NULL的支持相关，现在基本的   :class:` .TypeEngine`  类支持一种方法  <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none" title="sqlalchemy.types.TypeEngine.evaluates_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.evaluates_none()</span></code></a>  允许将   :func:` _expression.null`  赋予该属性的对象的“None”值正面地保留为NULL，而不是从插入语句中省略该列，从而使用列级默认值。这允许基于初始映射级别的对象级别技术，将   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.null" title="sqlalchemy.sql.expression.null"><code class="xref py py-func docutils literal notranslate"><span class="pre">null()</span></code></a>  赋给该属性。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../orm/persistence_techniques.html#session-forcing-null"><span class="std std-ref">在具有默认值的列上强制执行NULL</span></a></p>
</div></blockquote>
<p><a href="#id20"><span class="problematic" id="id21">:ticket:`3250`</span></a></p>
</div>
</section>
<section id="change-3582">
<span id="id22"></span><h3>继续单表继承查询方面的修复<a class="headerlink" href="#change-3582" title="Permalink to this heading">¶</a></h3>
<p>从1.0 series的   <span class="xref std std-ref">migration_3177</span>  开始，  :class:` _query.Query`  在针对子查询表达式（例如exists）时不应再不适当地添加“单一继承性”标准，例如：</p>
<blockquote>
<div><dl class="simple">
<dt>class Widget(Base):</dt><dd><p>__tablename__ = “widget”
id = Column(Integer, primary_key=True)
type = Column(String)
data = Column(String)
__mapper_args__ = {“polymorphic_on”: type}</p>
</dd>
<dt>class FooWidget(Widget):</dt><dd><p>__mapper_args__ = {“polymorphic_identity”: “foo”}</p>
</dd>
</dl>
<p>q = session.query(FooWidget).filter(FooWidget.data == “bar”).exists()</p>
<p>session.query(q).all()</p>
</div></blockquote>
<p>会产生：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">widget</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">widget</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">data_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">widget</span><span class="p">.</span><span class="k">type</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(:</span><span class="n">type_1</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span></pre></div>
</div>
<p>内部的 IN 子句是正确的，以限制为 FooWidget 对象，但是以前，也将在子查询外部生成一个 IN 子句。</p>
<blockquote>
<div><p><a href="#id23"><span class="problematic" id="id24">:ticket:`3582`</span></a></p>
</div></blockquote>
</section>
<section id="savepoint">
<span id="change-3680"></span><h3>取消数据库 SAVEPOINT 时，改进会话状态<a class="headerlink" href="#savepoint" title="Permalink to this heading">¶</a></h3>
<p>MySQL中的常见情况是在事务内发生死锁时将SAVEPOINT取消。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 已修改为在某种程度上更加优雅地处理此失败模式，以便仍然可以使用外部的非SAVEPOINT事务:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>

<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SomeObject</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># assume the flush fails, flush goes to rollback to the</span>
    <span class="c1"># savepoint and that also fails</span>
    <span class="n">s</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&quot;Something broke, and our SAVEPOINT vanished too&quot;</span><span class="p">)</span>

<span class="c1"># this is the SAVEPOINT transaction, marked as</span>
<span class="c1"># DEACTIVE so the rollback() call succeeds</span>
<span class="n">s</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

<span class="c1"># this is the outermost transaction, remains ACTIVE</span>
<span class="c1"># so rollback() or commit() can succeed</span>
<span class="n">s</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span></pre></div>
</div>
<p>这个问题是  <a href="#id25"><span class="problematic" id="id26">:ticket:`2696`</span></a>  的延续，在Python 2上运行时，我们发出警告，以便在发生SAVEPOINT异常时可以看到原始错误，尽管SAVEPOINT异常优先纳入。在Python 3上，异常链接在一起，因此在报告原始错误时也会报告SAVEPOINT异常。</p>
<blockquote>
<div><p><a href="#id27"><span class="problematic" id="id28">:ticket:`3680`</span></a></p>
</div></blockquote>
</section>
<section id="xy">
<span id="change-3677"></span><h3>修复了错误“新实例X与持久实例Y冲突”的刷新错误<a class="headerlink" href="#xy" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">rollback</span></code>  转移到  :term:` persistent` 。这些状态转换跟踪在弱引用集合中，如果从该集合进行垃圾回收，则 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 将不再担心它（否则，无法处理插入许多新对象的操作事务）。</p>
</div></blockquote>
<p>但是，如果应用程序在回滚发生之前重新装载该相同的已垃圾回收行，那么在下一个事务进入强引用之前，该对象的被删除状态将丢失；就是说，如果强引用的对象的状态被标记为已删除，那么刷新将错误地引发异常:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="c1"># persist an object</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">s</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="c1"># rollback buffer loses reference to A</span>

<span class="c1"># load it again, rollback buffer knows nothing</span>
<span class="c1"># about it</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># roll back the transaction; all state is expired but the</span>
<span class="c1"># &quot;a1&quot; reference remains</span>
<span class="n">s</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

<span class="c1"># previous &quot;a1&quot; conflicts with the new one because we aren&#39;t</span>
<span class="c1"># checking that it never got committed</span>
<span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">s</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面的程序将引发：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>FlushError: New instance &lt;User at 0x7f0287eca4d0&gt; with identity key
(&lt;class &#39;test.orm.test_transaction.User&#39;&gt;, (&#39;u1&#39;,)) conflicts
with persistent instance &lt;User at 0x7f02889c70d0&gt;</pre></div>
</div>
<p>错误在于，当引发上述异常时，工作单位正在处理原始对象，假定它是活行，而实际上该对象已过期，并在测试后消失。修复了此问题，因此在 SQL 日志中，我们会看到：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>

<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

<span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">OFFSET</span><span class="w"> </span><span class="o">?</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="k">ROLLBACK</span>

<span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>

<span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

<span class="k">COMMIT</span></pre></div>
</div>
<p>以上，在工作单元现在对试图报告为冲突的行进行SELECT检查后，看到该行不存在，然后正常处理该单元。只有当需要错误地引发异常时，才会产生SELECT。SELECT的成本仅在该字段将抛出异常的子查询或相似操作中有所体现。</p>
<blockquote>
<div><p><a href="#id29"><span class="problematic" id="id30">:ticket:`3677`</span></a></p>
</div></blockquote>
</section>
<section id="change-2349">
<span id="id31"></span><h3>连同继承映射的级联删除<a class="headerlink" href="#change-2349" title="Permalink to this heading">¶</a></h3>
<p>将连接表继承映射扩展为仅在  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.delete()</span></code>  的结果下进行DELETE，该方法仅发布基表的DELETE，而不是子类表，允许 ON DELETE CASCADE 配置为针对配置的外键。这是使用  :paramref:` .orm.mapper.passive_deletes`  选项进行配置:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_on&quot;</span><span class="p">:</span> <span class="n">type</span><span class="p">,</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span>
        <span class="s2">&quot;passive_deletes&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>
    <span class="n">b_table_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;b_table_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bid</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;bid&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;a.id&quot;</span><span class="p">,</span> <span class="n">ondelete</span><span class="o">=</span><span class="s2">&quot;CASCADE&quot;</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">}</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述映射的  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapper.passive_deletes</span></code>  选项在基础映射器上进行了配置；它对所有具有该选项设置的映射器后代（非基映射器的映射器）生效。针对类型为` <a href="#id32"><span class="problematic" id="id33">`</span></a>B``的对象的DELETE不再需要未加载的``b_table_id``的主键值，也不需要为表本身发出DELETE语句:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">some_b</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>将以如下方式发出SQL语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">%</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">s</span>
<span class="c1">-- {&#39;id&#39;: 1}</span>
<span class="k">COMMIT</span></pre></div>
</div>
<p>正如往常一样，目标数据库必须具有启用的 ON DELETE CASCADE 的外键支持。</p>
<blockquote>
<div><p><a href="#id34"><span class="problematic" id="id35">:ticket:`2349`</span></a></p>
</div></blockquote>
</section>
<section id="change-3630">
<span id="id36"></span><h3>必须不会再处理具有相同名称的反向引用，该反向引用适用于具体的继承子类<a class="headerlink" href="#change-3630" title="Permalink to this heading">¶</a></h3>
<p>以下映射一直没有问题的配置：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”
id = Column(Integer, primary_key=True)
b = relationship(“B”, foreign_keys=”B.a_id”, backref=”a”)</p>
</dd>
<dt>class A1(A):</dt><dd><p>__tablename__ = “a1”
id = Column(Integer, primary_key=True)
b = relationship(“B”, foreign_keys=”B.a1_id”, backref=”a1”)
__mapper_args__ = {“concrete”: True}</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)</p>
<p>a_id = Column(ForeignKey(“a.id”))
a1_id = Column(ForeignKey(“a1.id”))</p>
</dd>
</dl>
</div></blockquote>
<p>上述配置可以如上所述完成，即使类``A``和类``A1``都有名为``b``的关系也没有任何冲突，因为类``A1``被标记为“concrete”。</p>
<p>但是，如果使用另一种方式配置关系，则会引发错误：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”
id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class A1(A):</dt><dd><p>__tablename__ = “a1”
id = Column(Integer, primary_key=True)
__mapper_args__ = {“concrete”: True}</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)</p>
<p>a_id = Column(ForeignKey(“a.id”))
a1_id = Column(ForeignKey(“a1.id”))</p>
<p>a = relationship(“A”, backref=”b”)
a1 = relationship(“A1”, backref=”b”)</p>
</dd>
</dl>
</div></blockquote>
<p>该修复增强了反向引用功能，因此不会发出错误，还增加了对更换属性的其他检查逻辑，以跳过替换属性的警告。</p>
<blockquote>
<div><p><a href="#id37"><span class="problematic" id="id38">:ticket:`3630`</span></a></p>
</div></blockquote>
</section>
<section id="change-3749">
<span id="id39"></span><h3>当创建两个映射器在继承场景中，如果在两者上都放置具有相同名称的关系，则不会再次出现警告<a class="headerlink" href="#change-3749" title="Permalink to this heading">¶</a></h3>
<p>在继承情况下的两个映射器创建时，在其中放置具有相同名称的关系，将会标记警告；警告是“&lt;name&gt;”上的关系标记了映射“&lt;name&gt;”上同名关系的相同关系；此过程可能在flush操作期间导致依赖项问题。一个实例是如下的映射配置:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ASub</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a_sub&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;a.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;a.id&quot;</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>这个警告可追溯到2007年0.4系列的一个版本，基于一种已经完全重写了的单位的版本。目前，似乎没有已知问题有相同命名的关系位于基类和派生类中，因此取消了警告。但是，请注意，由于警告的存在，这种用例在实际使用中可能不普遍。此修复添加了对此用例的基本测试支持，但是可能会识别到该模式的某些新问题。</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.1.0b3: </span><a href="#id40"><span class="problematic" id="id41">:ticket:`3749`</span></a></p>
</div>
<p id="change-3653">在混合属性和方法中传播docstring以及.info</p>
</section>
</section>
<section id="orm-orm">
<h2>改善的ORM特性和改进 - ORM<a class="headerlink" href="#orm-orm" title="Permalink to this heading">¶</a></h2>
<p id="change-3657">映射器的`hybrid_property`将会反映原始 docstring 中的 <a href="#id42"><span class="problematic" id="id43">`</span></a>__doc__`值:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

    <span class="nd">@hybrid_property</span>
    <span class="k">def</span> <span class="nf">some_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The name field&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述代码会被翻译成如下格式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">some_name</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">The name field</span></pre></div>
</div>
<p>然而，为了实现这个，<a href="#id44"><span class="problematic" id="id45">`</span></a>hybrid_property`的机制必然变得更加复杂。之前，混合类访问器只是简单地传递的，也就是说，这个测试将会成功:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">some_name</span></pre></div>
</div>
<p>通过这个改变，<cite>A.some_name`表达式返回的表达式将被包含在它自己的 `QueryableAttribute</cite> 包装器中:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">some_name</span>
<span class="go">&lt;sqlalchemy.orm.attributes.hybrid_propertyProxy object at 0x7fde03888230&gt;</span></pre></div>
</div>
<p>已经经过了大量的测试，以确保这个包装器能够被正确地运作。 包括
<a class="reference external" href="https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/">Custom Value Object</a> 这样的精细方案，不过我们将会看到没有其它的功能回退会发生。</p>
<p>作为这个改变的一部分，`  :attr:` .hybrid_property.info 此属性的收集现在也从混合描述符本身传播，而不是从底层表达式传播。也就是说，访问 `  A.some_name.info` 现在会返回与 ` inspect(A).all_orm_descriptors[‘some_name’].info` 获得相同的字典。</p>
<p>但是这个 <cite>.info</cite> 字典是**独立**于混合描述符可能直接代理的映射属性的。这个处理改变于1.0版。包装器仍将代理镜像属性的其它有用属性，例如  <code class="xref py py-attr docutils literal notranslate"><span class="pre">QueryableAttribute.property</span></code>   和  :attr:` .QueryableAttribute.class_` 。</p>
<blockquote>
<div><p><a href="#id46"><span class="problematic" id="id47">:ticket:`3653`</span></a></p>
</div></blockquote>
<section id="session-mergepersistent">
<span id="change-3601"></span><h3>Session.merge会将未决冲突解决为persistent的相同方式<a class="headerlink" href="#session-mergepersistent" title="Permalink to this heading">¶</a></h3>
<p>现在，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.merge()</span></code>   方法将跟踪给定图形内的对象身份，以在发出` INSERT`之前维护主键的唯一性。当遇到具有相同标识的重复对象时，non-primary-key属性被 <strong>覆盖</strong>，因为找到了对象，这基本上是不确定的。如果一个唯一标识贯穿整个图形，那么该行为与persistent对象的行为相匹配，因此该行为更加内部一致。</p>
<p>比如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">u1</span><span class="o">.</span><span class="n">orders</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Order</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;o1&quot;</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">Address</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)),</span>
    <span class="n">Order</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;o2&quot;</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">Address</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)),</span>
    <span class="n">Order</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;o3&quot;</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">Address</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">)),</span>
<span class="p">]</span>

<span class="n">sess</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">sess</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span></pre></div>
</div>
<p>在上述代码中，我们将一个 <cite>User</cite> 对象与三个新的 <cite>Order</cite> 对象合并，每个 <cite>Order</cite> 对象都引用不同的 <cite>Address</cite> 对象，但是都具有相同的primary key。默认情况下，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.merge()</span></code>  的当前行为是从标识映射中查找此 ` Address` 对象，并将其用作目标。 如果对象存在，即数据库已经有一个带有primary key 的“1”的 <cite>Address</cite> 的行，则可以看到 <cite>Address</cite> 的 <cite>email_address</cite> 字段将被覆盖 三次，在这种情况下分别为a，b，最后c。</p>
<p>但是，如果主键key为”1”的 <cite>Address</cite> 行不存在，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.merge()</span></code>  将创建三个单独的 ` Address` 实例，然后我们将在INSERT时得到主键冲突。新的行为是，这些提议的 <cite>Address</cite> 对象的主键被跟踪在一个单独的字典中，以便将三个提议的 <cite>Address</cite> 对象的状态合并到一个要插入的 <cite>Address</cite> 对象上。</p>
<p>如果检测到合并树中存在冲突数据，则可能最好发出某种警告，但是多年来，用于persistent case的值非确定合并已经是行为，所以这个行为更匹配于pending case. 对于两种情况，都仍然可以实现警告存在冲突值的功能，但是这将增加相当大的性能开销，因为在合并过程中必须比较每个列值。</p>
<blockquote>
<div><p><a href="#id48"><span class="problematic" id="id49">:ticket:`3601`</span></a></p>
</div></blockquote>
</section>
<section id="many-to-one">
<span id="change-3708"></span><h3>修复了用户启动的外键操纵与many-to-one对象移动相关问题<a class="headerlink" href="#many-to-one" title="Permalink to this heading">¶</a></h3>
<p>在替换引用到一个对象中的many-to-one reference with another object的机制中修复了一个bug。在属性操作期间，以前引用的对象对应到的数据库-committed外键值现在使用，而不是当前的外键值。修复的主要影响是，当进行many-to-one change时，后退事件向集合发出的精度更高，即使手动将外键属性移动到了新的值上，而只是在引用many-to-one变化之前调用了backref事件。假设 <cite>Parent</cite> 和 <cite>SomeClass</cite> 的地图，其中 <cite>SomeClass.parent</cite> 引用 <cite>Parent</cite>，而 <cite>Parent.items</cite> 引用 <cite>SomeClass</cite> 对象的collection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">some_object</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span>
<span class="n">some_object</span><span class="o">.</span><span class="n">parent_id</span> <span class="o">=</span> <span class="n">some_parent</span><span class="o">.</span><span class="n">id</span>
<span class="n">some_object</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">some_parent</span></pre></div>
</div>
<p>上述代码创建了一个未决的对象 <cite>some_object</cite>，引用 <cite>Parent</cite> 的三个新的 <cite>Order</cite> 对象，每个都指向一个不同的`Address` 对象，但每个具有相同的主键。</p>
<p>在bug修复之前，backref将不会发出:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># before the fix</span>
<span class="k">assert</span> <span class="n">some_object</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">some_parent</span><span class="o">.</span><span class="n">items</span></pre></div>
</div>
<p>现在修复了，当我们寻找上一个值时，我们忽略已手动设置的父`parent_id`，而我们查找数据库-committed值. 在这种情况下，它为 <cite>None</cite>，因为对象是pending的，因此事件系统将 <cite>some_object.parent</cite> 进行标记为清晰更改:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># after the fix, backref fired off for some_object.parent = some_parent</span>
<span class="k">assert</span> <span class="n">some_object</span> <span class="ow">in</span> <span class="n">some_parent</span><span class="o">.</span><span class="n">items</span></pre></div>
</div>
<p>尽管将外键属性移动到新值是被不鼓励的操作，但仍有有限的支持此用例的支持。操纵外键以允许使用加载的应用程序通常会使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.enable_relationship_loading()</span></code>  和  :attr:` .RelationshipProperty.load_on_pending`  特性，这将导致relationship基于尚未持久化的内存中的外键值进行懒惰加载。无论是否使用这些特性，这个行为改进现在应该是明显的。</p>
<blockquote>
<div><p><a href="#id50"><span class="problematic" id="id51">:ticket:`3708`</span></a></p>
</div></blockquote>
</section>
<section id="query-correlate">
<span id="change-3662"></span><h3>通过多态实体提高了 <cite>Query.correlate</cite> 方法<a class="headerlink" href="#query-correlate" title="Permalink to this heading">¶</a></h3>
<p>在最近的SQLAlchemy版本中，大量poly的查询生成的SQL的形式比它的子查询中捆绑多个数据表的形式更加“平坦”。为适应这一变化，  <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate" title="sqlalchemy.orm.Query.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.correlate()</span></code></a>  方法现在提取这种多态可选择的单独表，并确保所有这些表都是子查询的一部分。 假设通过` with_polymorphic`从映射文档中的Person/Manager/Engineer-&gt;Company建立的映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">company_id</span> <span class="o">==</span> <span class="n">Person</span><span class="o">.</span><span class="n">company_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span>
    <span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span>
    <span class="o">==</span> <span class="s2">&quot;Elbonia, Inc.&quot;</span>
<span class="p">)</span></pre></div>
</div>
<p>上述查询现在产生：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">people_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">people</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">engineers</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">person_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">engineers</span><span class="p">.</span><span class="n">person_id</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">managers</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">person_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">managers</span><span class="p">.</span><span class="n">person_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">companies</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">companies</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">companies</span><span class="p">.</span><span class="n">company_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">company_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span></pre></div>
</div>
<p>我们可以看到， <cite>c`表在两次选择中都被选中，一次是在 `A.b.c -&gt; c_alias_1</cite> 的情况下，一次是在 <cite>A.c -&gt; c_alias_2</cite> 的情况下. 同样，我们还可以看到，在identity map中得到的最终 <cite>C</cite> 对象是否已加载取决于映射是如何遍历的，即使不完全是随机的，而是基本上是不确定的。 查询选项仅要求在 <cite>c_alias_1</cite> 的上下文中加载属性`C.d`，而不是 <cite>c_alias_2</cite> 上下文中。因此，我们在最终得到的identity map中得到的 <cite>C</cite> 对象是否有 <cite>C.d</cite> 属性取决于映射的遍历顺序，这是不完全 - 预测态的。 加强处理量的测试是多次方向上找到mapping的entity的情况，这一修正将希望涵盖所有这种性质的场景。</p>
<blockquote>
<div><p><a href="#id52"><span class="problematic" id="id53">:ticket:`3662`</span></a></p>
</div></blockquote>
</section>
<section id="query-session">
<span id="change-3081"></span><h3>字符串化Query将查阅 Session 获取正确的方言<a class="headerlink" href="#query-session" title="Permalink to this heading">¶</a></h3>
<p>在   <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  对象上调用 ` str（）` 将会查阅   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  获取正确的“bind”，以便呈现SQL，该SQL将会传递到数据库。 特别是，这允许查询包含特定于方言的SQL构造的情况可以呈现出来，假设将   :class:` _query.Query`  关联到一个适当的   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 。 以前，只有在   :class:` _schema.MetaData`  与映射相关联的情况下才会发挥此行为，并且   <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  对象被视为公共查询结构。</p>
<p>如果基础的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  或   :class:` .Session`  都未与任何绑定的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>  相关联，则将使用Fall-back到“默认”方言来生成SQL字符串。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="#change-3631"><span class="std std-ref">Core SQL构造的“友好”字符串化没有发现方言现在</span></a></p>
</div></blockquote>
<p><a href="#id54"><span class="problematic" id="id55">:ticket:`3081`</span></a></p>
</div>
</section>
<section id="entity-joined-eager-loading">
<span id="change-3431"></span><h3>在一个行中多次存在相同的entity时，加入了joined eager loading机制<a class="headerlink" href="#entity-joined-eager-loading" title="Permalink to this heading">¶</a></h3>
<p>在一个多样化的查询中，当一个属性通过joined eager loading加载时，即使该实体已经从另一条不包括该属性的“路径”中加载，属性也会被加载。这是一种难以重现的深度用例，但是通常的想法是如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;b.id&quot;</span><span class="p">))</span>
    <span class="n">c_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;c.id&quot;</span><span class="p">))</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">c_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;c.id&quot;</span><span class="p">))</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">d_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;d.id&quot;</span><span class="p">))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>


<span class="n">c_alias_1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">c_alias_2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c_alias_1</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c_alias_1</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">contains_eager</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">c_alias_1</span><span class="p">)</span><span class="o">.</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c_alias_2</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">c_alias_2</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上述查询可能产生如下这种形式的SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
<span class="w">    </span><span class="n">d</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">d_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">c_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">c_1_id</span><span class="p">,</span><span class="w"> </span><span class="n">c_1</span><span class="p">.</span><span class="n">d_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">c_1_d_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">b_id</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">c_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">b_c_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">c_2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">c_2_id</span><span class="p">,</span><span class="w"> </span><span class="n">c_2</span><span class="p">.</span><span class="n">d_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">c_2_d_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_b_id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">c_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_c_id</span>
<span class="k">FROM</span>
<span class="w">    </span><span class="n">a</span>
<span class="w">    </span><span class="k">JOIN</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span>
<span class="w">    </span><span class="k">JOIN</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">c_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">c_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">c_id</span>
<span class="w">    </span><span class="k">JOIN</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_1</span><span class="p">.</span><span class="n">d_id</span>
<span class="w">    </span><span class="k">JOIN</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">c_2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">c_2</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">c_id</span></pre></div>
</div>
<p>我们可以看到，<cite>c`表被选中了两次。一次是在 `A.b.c -&gt; c_alias_1</cite> 的情况下，另一次是在 <cite>A.c -&gt; c_alias_2</cite> 的情况下。此外，我们可以看到，在一个单行中得到的`C` identity是相同的，尽管在identity映射中只添加了一个新对象。</p>
<p>上述的查询选项要求加载属性 <cite>C.d</cite>，并且只涉及到 <cite>c_alias_1</cite> 的情况。而不涉及别名为 <cite>c_alias_2</cite> 的情况。因此，我们得到的最终的 <cite>C</cite> 对象在identity map中是否已加载取决于映射是如何遍历的，即使不是完全随机，而是基本上是不确定的。修复包括两种“多路径到一个实体”的情况的测试，应该能涵盖所有这类型的场景。</p>
<blockquote>
<div><p><a href="#id56"><span class="problematic" id="id57">:ticket:`3431`</span></a></p>
</div></blockquote>
</section>
<section id="mutable-toplevelmutablelistmutableset">
<h3>为mutable_toplevel扩展了新的MutableList和MutableSet辅助类<a class="headerlink" href="#mutablelistmutableset" title="Permalink to this heading">¶</a></h3>
<p>加入新的辅助类   <a class="reference internal" href="../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList" title="sqlalchemy.ext.mutable.MutableList"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableList</span></code></a>  和   :class:` .MutableSet`  配合现有的   <a class="reference internal" href="../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict" title="sqlalchemy.ext.mutable.MutableDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableDict</span></code></a>  辅助器。</p>
<blockquote>
<div><p><a href="#id58"><span class="problematic" id="id59">:ticket:`3297`</span></a></p>
</div></blockquote>
</section>
<section id="raise-raise-on-sql">
<span id="change-3512"></span><h3>新的”raise” / “raise_on_sql”加载器策略<a class="headerlink" href="#raise-raise-on-sql" title="Permalink to this heading">¶</a></h3>
<p>为了帮助防止一系列对象加载后发生不需要的延迟加载，现在可以对关系属性应用新的”lazy=’raise‘“和”lazy=’raise_on_sql‘“策略以及相应的文章选择器   <code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code> ，当读取时，会导致它引发一个 ` InvalidRequestError` 。
两个变体都测试懒加载，包括只返回None或从identity map中检索的那些的延迟加载。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">raiseload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">raiseload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">some_b</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">some_b</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">sqlalchemy.exc.InvalidRequestError</span>: <span class="n">&#39;A.some_b&#39; is not available due to lazy=&#39;raise&#39;</span></pre></div>
</div>
<p>或仅限于在发出SQL时发出延迟加载:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">raiseload</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">raiseload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">some_b</span><span class="p">,</span> <span class="n">sql_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span><span class="o">.</span><span class="n">some_b</span>
  <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">:</span> <span class="s1">&#39;A.bs&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span> <span class="n">due</span> <span class="n">to</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;raise_on_sql&#39;</span>

<span class="p">:</span><span class="n">paramref</span><span class="p">:</span><span class="err">`</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">over</span><span class="o">.</span><span class="n">range_</span><span class="err">`</span>   <span class="n">和</span>  <span class="p">:</span><span class="n">paramref</span><span class="p">:</span><span class="err">`</span> <span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">over</span><span class="o">.</span><span class="n">rows</span><span class="err">`</span>  <span class="n">形式采用的都是</span> <span class="mi">2</span> <span class="n">元组指示针对特定范围的负值和正值</span><span class="err">，</span><span class="mi">0</span><span class="n">表示</span> <span class="err">“</span><span class="n">CURRENT</span> <span class="n">ROW</span><span class="err">”，</span><span class="n">和</span> <span class="kc">None</span> <span class="n">表示</span> <span class="err">“</span><span class="n">UNBOUNDED</span><span class="err">”。</span>

<span class="p">:</span><span class="n">ticket</span><span class="p">:</span><span class="err">`</span><span class="mi">3512</span><span class="err">`</span></pre></div>
</div>
</section>
<section id="order-by">
<span id="change-3394"></span><h3>映射器的order_by参数已不再使用<a class="headerlink" href="#order-by" title="Permalink to this heading">¶</a></h3>
<p>这个参数是第一个版本的ORM中设计的一部分，是ORM的原始设计的一部分，它在ORM中扮演着公共查询结构的角色。现在，这个角色已经被   <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>  对象所取代，这里我们只需要使用  :meth:` _query.Query.order_by`  来指示结果的排序方式，无论是任何组合的SELECT语句，实体或SQL表达式。有许多情况下决定不清楚，诸如将查询组合到联合中，这些情况不被支持。</p>
<blockquote>
<div><p><a href="#id60"><span class="problematic" id="id61">:ticket:`3394`</span></a></p>
</div></blockquote>
</section>
</section>
<section id="id62">
<h2>新功能和改进 - 核心<a class="headerlink" href="#id62" title="Permalink to this heading">¶</a></h2>
<section id="enginesbaseexception">
<span id="change-3803"></span><h3>Engines现在会为BaseException类型的情况使连接失效，并运行错误处理程序<a class="headerlink" href="#enginesbaseexception" title="Permalink to this heading">¶</a></h3>
<p>Python <code class="docutils literal notranslate"><span class="pre">BaseException</span></code> 类在 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 的下面，但是这个类是系统级别异常超集的基类，例如 <cite>KeyboardInterrupt</cite>，<cite>SystemExit</cite>，尤其是 <cite>GreenletExit</cite> 异常，后者被事件和植物使用。因此，此异常类现在被   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  的异常处理程序所拦截，并由  :meth:` _events.ConnectionEvents.handle_error`  事件处理程序包括。默认情况下，  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  现在在不是 ` Exception` 的子类的情况下外部系统异常发生时，被 <strong>无效废除</strong>，因为我们假设已中断操作，并且连接可能处于不可用状态。MySQL驱动程序受此更改的影响最大，但该更改适用于所有DBAPIs。</p>
<p>请注意，在失效时，当前已使用 `  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  的即时DBAPI连接会被处理，如果仍然在引发异常后继续使用  :class:` _engine.Connection` ，下一次会使用一个新的DBAPI连接来进行后续操作；但是，在操作中的任何事务状态将会丢失，并且在此重新使用之前，必须（如果适用）调用适当的 <cite>.rollback()</cite> 方法。</p>
<p>为了识别这种变化，可以演示在程序执行中处理 <cite>KeyboardInterrupt`</cite> 或 <code class="docutils literal notranslate"><span class="pre">GreenletExit</span></code> 并希望在同一事务中继续工作。这样的操作在理论上是可能的，因为不会受到像 psycopg2 这样的其他DBAPI被 <code class="docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code> 所影响，此时以下绕路将使禁用连接被重新用于特定异常：</p>
<blockquote>
<div><blockquote>
<div><p>engine = create_engine(“postgresql+psycopg2://”)</p>
<p>&#64;event.listens_for(engine, “handle_error”)
def cancel_disconnect(ctx):</p>
<blockquote>
<div><dl class="simple">
<dt>if isinstance(ctx.original_exception, KeyboardInterrupt):</dt><dd><p>ctx.is_disconnect = False</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><a href="#id63"><span class="problematic" id="id64">:ticket:`3803`</span></a></p>
</div></blockquote>
</section>
<section id="insert-update-deletecte">
<span id="change-2551"></span><h3>支持INSERT，UPDATE，DELETE的CTE<a class="headerlink" href="#insert-update-deletecte" title="Permalink to this heading">¶</a></h3>
<p>业界最广泛要求的功能之一是对插入，更新，删除进行通用表达式（CTE）的支持，现在已经实现。INSERT / UPDATE / DELETE可以从自身语句中作为CTE中派生的表中提取，以及为查询或更大的语句的CTE，举例如下。</p>
<p>为INSERT增加了CTE：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">literal</span><span class="p">,</span> <span class="n">exists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orders</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span>
<span class="go">...     &quot;orders&quot;,</span>
<span class="go">...     column(&quot;region&quot;),</span>
<span class="go">...     column(&quot;amount&quot;),</span>
<span class="go">...     column(&quot;product&quot;),</span>
<span class="go">...     column(&quot;quantity&quot;),</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">upsert</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     orders.update()</span>
<span class="go">...     .where(orders.c.region == &quot;Region1&quot;)</span>
<span class="go">...     .values(amount=1.0, product=&quot;Product1&quot;, quantity=1)</span>
<span class="go">...     .returning(*(orders.c._all_columns))</span>
<span class="go">...     .cte(&quot;upsert&quot;)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insert</span> <span class="o">=</span> <span class="n">orders</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">from_select</span><span class="p">(</span>
<span class="go">...     orders.c.keys(),</span>
<span class="go">...     select([literal(&quot;Region1&quot;), literal(1.0), literal(&quot;Product1&quot;), literal(1)]).where(</span>
<span class="go">...         ~exists(upsert.select())</span>
<span class="go">...     ),</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>  <span class="c1"># Note: formatting added for clarity</span>
<div class='show_sql_print'><span class="k">WITH</span><span class="w"> </span><span class="n">upsert</span><span class="w"> </span><span class="k">AS</span>
<span class="p">(</span><span class="k">UPDATE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">amount</span><span class="o">=</span><span class="p">:</span><span class="n">amount</span><span class="p">,</span><span class="w"> </span><span class="n">product</span><span class="o">=</span><span class="p">:</span><span class="n">product</span><span class="p">,</span><span class="w"> </span><span class="n">quantity</span><span class="o">=</span><span class="p">:</span><span class="n">quantity</span>
<span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">orders</span><span class="p">.</span><span class="n">region</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">region_1</span>
<span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">orders</span><span class="p">.</span><span class="n">region</span><span class="p">,</span><span class="w"> </span><span class="n">orders</span><span class="p">.</span><span class="n">amount</span><span class="p">,</span><span class="w"> </span><span class="n">orders</span><span class="p">.</span><span class="n">product</span><span class="p">,</span><span class="w"> </span><span class="n">orders</span><span class="p">.</span><span class="n">quantity</span>
<span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span><span class="n">region</span><span class="p">,</span><span class="w"> </span><span class="n">amount</span><span class="p">,</span><span class="w"> </span><span class="n">product</span><span class="p">,</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span>
<span class="k">SELECT</span>
<span class="w">    </span><span class="p">:</span><span class="n">param_1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">param_2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_2</span><span class="p">,</span>
<span class="w">    </span><span class="p">:</span><span class="n">param_3</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_3</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">param_4</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_4</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="k">SELECT</span><span class="w"> </span><span class="n">upsert</span><span class="p">.</span><span class="n">region</span><span class="p">,</span><span class="w"> </span><span class="n">upsert</span><span class="p">.</span><span class="n">amount</span><span class="p">,</span>
<span class="w">               </span><span class="n">upsert</span><span class="p">.</span><span class="n">product</span><span class="p">,</span><span class="w"> </span><span class="n">upsert</span><span class="p">.</span><span class="n">quantity</span>
<span class="w">        </span><span class="k">FROM</span><span class="w"> </span><span class="n">upsert</span><span class="p">))</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">tutorial_cte</span></p>
<p><a href="#id65"><span class="problematic" id="id66">:ticket:`2551`</span></a></p>
</div>
</section>
<section id="rangerows">
<span id="change-3049"></span><h3>支持窗口函数中的RANGE和ROWS指定<a class="headerlink" href="#rangerows" title="Permalink to this heading">¶</a></h3>
<p>新的参数  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_" title="sqlalchemy.sql.expression.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">over.range_</span></code></a>  和  :paramref:` .expression.over.rows`  允许RANGE和ROWS表达式用于窗口函数。:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go">  &gt;&gt;&gt; from sqlalchemy import func</span>

<span class="go">  &gt;&gt;&gt; print(func.row_number().over(order_by=&quot;x&quot;, range_=(-5, 10)))</span>
<span class="go">  {printsql}row_number() OVER (ORDER BY x RANGE BETWEEN :param_1 PRECEDING AND :param_2 FOLLOWING){stop}</span>

<span class="go">  &gt;&gt;&gt; print(func.row_number().over(order_by=&quot;x&quot;, rows=(None, 0)))</span>
<span class="go">  {printsql}row_number() OVER (ORDER BY x ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW){stop}</span>

<span class="go">  &gt;&gt;&gt; print(func.row_number().over(order_by=&quot;x&quot;, range_=(-2, None)))</span>
<span class="go">  {printsql}row_number() OVER (ORDER BY x RANGE BETWEEN :param_1 PRECEDING AND UNBOUNDED FOLLOWING){stop}</span>

<span class="go">:paramref:`.expression.over.range_`   和  :paramref:` .expression.over.rows`  被指定为2元组，指示特定范围的负值和正值，对于特定范围，0表示“CURRENT ROW”，NOne表示“UNBOUNDED”。</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><span class="xref std std-ref">tutorial_window_functions</span></p>
</div></blockquote>
<p><a href="#id67"><span class="problematic" id="id68">:ticket:`3049`</span></a></p>
</div>
</section>
<section id="sql-lateral">
<span id="change-2857"></span><h3>支持SQL LATERAL关键字<a class="headerlink" href="#sql-lateral" title="Permalink to this heading">¶</a></h3>
<p>LATERAL关键字目前已知仅由PostgreSQL 9.3及更高版本支持，但作为SQL标准的一部分，Core已经支持了此关键字。  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a>  的实现 beyond 只是渲染LATERAL关键字，还允许表的相关联，这些表衍生自与可选择的相同FROM子句的selectable，例如外侧相关表达式（lateral correlation）:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">people</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;people&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;people_id&quot;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">books</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;books&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;book_id&quot;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;owner_id&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select([books.c.book_id])</span>
<span class="go">...     .where(books.c.owner_id == people.c.people_id)</span>
<span class="go">...     .lateral(&quot;book_subq&quot;)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">people</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subq</span><span class="p">,</span> <span class="n">true</span><span class="p">())))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">people_id</span><span class="p">,</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">people</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="k">LATERAL</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">books</span><span class="p">.</span><span class="n">book_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">book_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">books</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">books</span><span class="p">.</span><span class="n">owner_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">people</span><span class="p">.</span><span class="n">people_id</span><span class="p">)</span>
<span class="k">AS</span><span class="w"> </span><span class="n">book_subq</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">true</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><blockquote>
<div><p><span class="xref std std-ref">tutorial_lateral_correlation</span></p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a></p>
</div></blockquote>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a></p>
</div></blockquote>
<p><a href="#id69"><span class="problematic" id="id70">:ticket:`2857`</span></a></p>
</div>
</section>
<section id="tablesample">
<span id="change-3718"></span><h3>支持TABLESAMPLE<a class="headerlink" href="#tablesample" title="Permalink to this heading">¶</a></h3>
<p>参考支持SQL的标准TABLESAMPLE使用</p>
<p>这是SQL标准的一部分。因此，Core现在支持渲染SQL表SAMPLE关键字。尽管PostgreSQL 9.5是唯一可知支持的数据库，但希望此功能将扩展到其他SQL数据库可能会增加对TABLESAMPLE的支持，包括Oracle和SQL Server, 等等。</p>
<p>看下面的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">select</span><span class="p">([</span><span class="n">mytable</span><span class="p">])</span><span class="o">.</span><span class="n">tablesample</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span></pre></div>
</div>
<p>将产生如下所示的SQL语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">mytable</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">mytable</span><span class="w"> </span><span class="n">TABLESAMPLE</span><span class="w"> </span><span class="n">BERNOULLI</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span></pre></div>
</div>
<p>请注意，<cite>TABLESAMPLE BERNOULLI</cite> 是 PostgreSQL 的默认选项，Hash和系统都是默认的。</p>
<blockquote>
<div><p><a href="#id71"><span class="problematic" id="id72">:ticket:`3718`</span></a>    :meth:` _expression.FromClause.tablesample`  方法，返回一个类似于别名的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.TableSample" title="sqlalchemy.sql.expression.TableSample"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableSample</span></code></a> 结构:</p>
<blockquote>
<div><p>from sqlalchemy import func</p>
<p>selectable = people.tablesample(func.bernoulli(1), name=”alias”, seed=func.random())
stmt = select([selectable.c.people_id])</p>
</div></blockquote>
</div></blockquote>
<p>假设`people`有一个`people_id`列，则上述语句将呈现为:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">SELECT</span><span class="w"> </span><span class="k">alias</span><span class="p">.</span><span class="n">people_id</span><span class="w"> </span><span class="k">FROM</span>
<span class="w">  </span><span class="n">people</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">alias</span><span class="w"> </span><span class="n">TABLESAMPLE</span><span class="w"> </span><span class="n">bernoulli</span><span class="p">(:</span><span class="n">bernoulli_1</span><span class="p">)</span>
<span class="w">  </span><span class="k">REPEATABLE</span><span class="w"> </span><span class="p">(</span><span class="n">random</span><span class="p">())</span>

<span class="p">:</span><span class="n">ticket</span><span class="p">:</span><span class="o">`</span><span class="mi">3718</span><span class="o">`</span></pre></div>
</div>
</section>
<section id="autoincrement">
<span id="change-3216"></span><h3>现在不再针对复合主键列隐式启用`.autoincrement`指令<a class="headerlink" href="#autoincrement" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy始终有一个方便功能，即对于单列整数主键，启用后端数据库的“自动增量”功能；通过“自动增量”，我们指的是数据库列将包括任何DDL指令，以指示自增长整数标识符，例如在PostgreSQL上的SERIAL关键字或MySQL上的AUTO_INCREMENT，此外，方言将使用适合于该后端的执行从一：meth:<a href="#id73"><span class="problematic" id="id74">`</span></a>_schema.Table.insert`构造，以获取这些生成的值。</p>
<p>更改的是，此功能不再自动应用于复合主键；以前，表定义，如:</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>只有因为它是主键列列表中的第一列，因此将对“x”列应用“autoincrement”语义。为了禁用它，必须关闭所有列上的“autoincrement”：</p>
<blockquote>
<div><p># 旧方式
Table(</p>
<blockquote>
<div><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True, autoincrement=False),
Column(“y”, Integer, primary_key=True, autoincrement=False),</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>使用新行为，除非某个列已明确标记为“autoincrement = True”，否则复合主键将不具有自动增量语义：</p>
<blockquote>
<div><p>#列“y”将是SERIAL/AUTO_INCREMENT/自动生成
Table(</p>
<blockquote>
<div><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True, autoincrement=True),</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>为了预期一些可能的向后不兼容情况，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.insert()</span></code>  构造将执行更彻底的检查，并检查不具有设置自增量的复合主键列的缺少主键值；给定一个表，例如：</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“b”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>使用没有插入值的INSERT将产生以下警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: Column &#39;b.x&#39; is marked as a member of the primary
key for table &#39;b&#39;, but has no Python-side or server-side default
generator indicated, nor does it indicate &#39;autoincrement=True&#39;,
and no explicit value is passed.  Primary key columns may not
store NULL. Note that as of SQLAlchemy 1.1, &#39;autoincrement=True&#39;
must be indicated explicitly for composite (e.g. multicolumn)
primary keys if AUTO_INCREMENT/SERIAL/IDENTITY behavior is
expected for one of the columns in the primary key. CREATE TABLE
statements are impacted by this change as well on most backends.</pre></div>
</div>
<p>对于从服务器端默认值或触发器接收主键值的列，可以使用 <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.FetchedValue" title="sqlalchemy.schema.FetchedValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">FetchedValue</span></code></a> 指示存在值生成器：</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“b”,
metadata,
Column(“x”, Integer, primary_key=True, server_default=FetchedValue()),
Column(“y”, Integer, primary_key=True, server_default=FetchedValue()),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>对于确实意图将空值存储在一个或多个列中的复合主键（仅在SQLite和MySQL上受支持），请使用“nullable = True”指定该列：</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“b”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True, nullable=True),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>在一个相关的更改中，可以在客户端侧或服务器侧启用自动增量标志为True的列。在INSERT期间，这通常不会对列的行为产生太大影响。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="#change-mysql-3216"><span class="std std-ref">不再为具有AUTO_INCREMENT的组合主键生成隐式键</span></a></p>
</div></blockquote>
<p><a href="#id75"><span class="problematic" id="id76">:ticket:`3216`</span></a></p>
</div>
</section>
<section id="is-distinct-fromis-not-distinct-from">
<span id="change-is-distinct-from"></span><h3>支持IS DISTINCT FROM和IS NOT DISTINCT FROM<a class="headerlink" href="#is-distinct-fromis-not-distinct-from" title="Permalink to this heading">¶</a></h3>
</section>
<section id="id79">
<h3><a href="#id77"><span class="problematic" id="id78">``</span></a>.autoincrement``指令不再针对复合主键列隐式启用<a class="headerlink" href="#id79" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy始终有一个方便功能，即对于单列整数主键，启用后端数据库的“自动增量”功能；通过“自动增量”，我们指的是数据库列将包括任何DDL指令，以指示自增长整数标识符，例如在PostgreSQL上的SERIAL关键字或MySQL上的AUTO_INCREMENT，此外，方言将使用适合于该后端的执行从一：meth:<a href="#id80"><span class="problematic" id="id81">`</span></a>_schema.Table.insert`构造，以获取这些生成的值。</p>
<p>更改的是，此功能不再自动应用于复合主键；以前，表定义，如:</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>只有因为它是主键列列表中的第一列，因此将对“x”列应用“autoincrement”语义。为了禁用它，必须关闭所有列上的“autoincrement”：</p>
<blockquote>
<div><p># 旧方式
Table(</p>
<blockquote>
<div><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True, autoincrement=False),
Column(“y”, Integer, primary_key=True, autoincrement=False),</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>使用新行为，除非某个列已明确标记为“autoincrement = True”，否则复合主键将不具有自动增量语义：</p>
<blockquote>
<div><p>#列“y”将是SERIAL/AUTO_INCREMENT/自动生成
Table(</p>
<blockquote>
<div><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True, autoincrement=True),</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>为了预期一些可能的向后不兼容情况，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.insert()</span></code>  构造将执行更彻底的检查，并检查不具有设置自增量的复合主键列的缺少主键值；给定一个表，例如：</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“b”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>使用没有插入值的INSERT将产生以下警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: 列&#39;b.x&#39;被标记为&#39;Key&#39;成员，并且没有指示Python侧或服务器端默认生成器，
也没有指定&#39;autoincrement = True&#39;，而且没有显式传递值。主键列可能不存储NULL。
注意，自_SQLAlchemy 1.1以来，对于复合（例如多列）主键，如果希望对主键中的某一列采用AUTO_INCREMENT /
SERIAL / IDENTITY行为，则必须明确指示“autoincrement = True”。CREATE TABLE语句也受此更改影响。</pre></div>
</div>
<p>对于从服务器端默认值或触发器接收主键值的列，可以使用 <a class="reference internal" href="../core/defaults.html#sqlalchemy.schema.FetchedValue" title="sqlalchemy.schema.FetchedValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">FetchedValue</span></code></a> 指示存在值生成器：</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“b”,
metadata,
Column(“x”, Integer, primary_key=True, server_default=FetchedValue()),
Column(“y”, Integer, primary_key=True, server_default=FetchedValue()),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>对于确实意图将空值存储在一个或多个列中的复合主键（仅在SQLite和MySQL上受支持），请使用“nullable = True”指定该列：</p>
<blockquote>
<div><dl class="simple">
<dt>Table(</dt><dd><p>“b”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True, nullable=True),</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>在一个相关的更改中，可以在客户端侧或服务器侧启用自动增量标志为True的列。在INSERT期间，这通常不会对列的行为产生太大影响。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="#change-mysql-3216"><span class="std std-ref">不再为具有AUTO_INCREMENT的组合主键生成隐式键</span></a></p>
</div></blockquote>
<p><a href="#id82"><span class="problematic" id="id83">:ticket:`3216`</span></a></p>
</div>
<p id="id84">支持IS DISTINCT FROM和IS NOT DISTINCT FROM
此外，新操作员  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from" title="sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.isnot_distinct_from()</span></code></a>   allow the IS NOT DISTINCT
FROM sql operation: 新操作员  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from" title="sqlalchemy.sql.expression.ColumnOperators.is_distinct_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.is_distinct_from()</span></code></a>   和</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;打印（列（“x”）。is_distinct_from（None））</span>
<div class='show_sql_print'><span class="n">x</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">NULL</span>
</div></pre></div>
</div>
<p>将提供有关NULL、True和False的处理：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isnot_distinct_from</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
<div class='show_sql_print'><span class="n">x</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">false</span>
</div></pre></div>
</div>
<p>对于SQLite，它没有这种运算符，它在SQLite上呈现为“IS”/“IS NOT”，这在SQLite中可以处理NULL，与其他后端不同：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">sqlite</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_distinct_from</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">sqlite</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="n">x</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
</div></pre></div>
</div>
<p id="change-1957">Core和ORM支持FULL OUTER JOIN
————————————————– —–</p>
<p>新标志  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">outerjoin.full</span></code>  ，在Core和ORM级别上提供，
指示编译器呈现“FULL OUTER JOIN”而不是通常呈现“LEFT OUTER JOIN”：</p>
<blockquote>
<div><p>stmt = select([t1]).select_from(t1.outerjoin(t2, full=True))</p>
</div></blockquote>
<p>标志也在ORM级别下起作用：</p>
<blockquote>
<div><blockquote>
<div><p>q = session.query(MyClass).outerjoin(MyOtherClass, full=True)</p>
</div></blockquote>
<p><a href="#id85"><span class="problematic" id="id86">:ticket:`1957`</span></a></p>
</div></blockquote>
<p id="change-3501">ResultSet列匹配增强;文本SQL的位置列安装
————————————————– —————————–</p>
<p>在1.0系列中，通过:ticket: 918，对 <code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code> 系统进行了一系列改进，
将基于匹配名称而不是基于表/ORM元数据对游标绑定的结果列进行调整，这应包含完整信息
有关要返回的结果行。这允许显着降低Python开销，以及更准确地将ORM和Core链接起来
SQL表达式到结果行。在1.1中，此重新组织在内部进一步，并通过最近添加的  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>  方法
使其可用于纯文本SQL构造。</p>
<section id="textasfrom-columns">
<h4>TextAsFrom.columns()现在按位置工作<a class="headerlink" href="#textasfrom-columns" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>  方法在0.9中添加，接受基于列的参数</p>
</div></blockquote>
<p>按位置;在1.1中，当所有列被传递为位置时，这些列与最终结果集的关联
也进行了按位置执行。这里的关键优点是可以将文本SQL链接到ORM-
级别结果集而无需处理模棱两可或重复的列名称
要么必须将标记方案与ORM级标记方案匹配。所有
现在只需要在文本SQL中具有相同的列顺序
和传递给  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>  的列参数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>

<span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span>
    <span class="s2">&quot;SELECT users.id, addresses.id, users.id, &quot;</span>
    <span class="s2">&quot;users.name, addresses.email_address AS email &quot;</span>
    <span class="s2">&quot;FROM users JOIN addresses ON users.id=addresses.user_id &quot;</span>
    <span class="s2">&quot;WHERE users.id = 1&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上述文本SQL包含三个id列，这可能令人困惑，但现在我们可以直接应用
从`User`和` <cite>Address``类直接映射的列，即使在文本SQL中
将“Address.user_id”列链接到文本SQL中的“users.id”列，而  :obj:`_query.Query</cite>  对象将获得正确的行
需要瞄准，包括针对贪婪加载。</p>
<p>这是**向后不兼容的**行为更改，对使用不同的列的方法进行列的应用
与文本语句中存在重要关注点的行为变化。希望这个
影响将因此方法一直记录并且
方法仅在0.9中添加，在任何情况下可能还没有广泛使用。在现有的
如何处理使用它的应用程序的行为更改说明请参见  <a class="reference internal" href="#behavior-change-3501"><span class="std std-ref">当按位置传递列时，TextClause.columns()将按位置而不是按名称进行匹配</span></a> 。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../tutorial/data_select.html#tutorial-select-arbitrary-text"><span class="std std-ref">使用文本列表达式选择</span></a></p>
<blockquote>
<div><p><a class="reference internal" href="#behavior-change-3501"><span class="std std-ref">当按位置传递列时，TextClause.columns()将按位置而不是按名称进行匹配</span></a>  - 向后兼容性备注</p>
</div></blockquote>
</div>
</section>
<section id="core-orm-sql-constructs">
<h4>对于Core/ORM SQL constructs，位置匹配优先于基于名称的匹配<a class="headerlink" href="#core-orm-sql-constructs" title="Permalink to this heading">¶</a></h4>
<p>此更改的另一个方面是修改匹配列的规则
对于已编译的SQL构造，更全面地依赖于“位置性”匹配
表/ORM级元数据。给出如下语句:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ua</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;ua&quot;</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">ua</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">])</span></pre></div>
</div>
<p>当执行上述语句时，该语句在1.0中将与其原始匹配
使用与SQL列进行定位匹配的编译构造，但是由于语句
包含“user_id”标签重复，因此“模棱两可的列”规则
仍然会涉及并防止列从行中获取。从1.1开始，“模棱两可的列”规则
不会影响从列构造到SQL列的精确匹配，这是ORM用于
获取列:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># 这两个都匹配位置，因此没有错误</span>
<span class="n">user_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">]</span>
<span class="n">ua_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">ua</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">]</span>

<span class="c1"># 这仍然会引发 exception</span>
<span class="n">user_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;user_id&quot;</span><span class="p">]</span></pre></div>
</div>
</section>
<section id="id87">
<h4>更不可能出现“模棱两可列”错误消息<a class="headerlink" href="#id87" title="Permalink to this heading">¶</a></h4>
<p>随着这个变化，错误消息“结果集中存在模糊不清的列名’&lt;name&gt;’！
尝试“在选择语句中使用’use_labels’选项”已被缩小；因为现在这个
消息在使用ORM或Core编译SQL构造获取结果列时几乎不会发生,
它只是在实际存在模糊不清的名称“模糊不清的列”时才会出现
在渲染的SQL语句本身中，而不是指示键或存在本构造中的名称
用于获取。</p>
<blockquote>
<div><p><a href="#id88"><span class="problematic" id="id89">:ticket:`3501`</span></a></p>
</div></blockquote>
</section>
</section>
<section id="corepython-enum">
<span id="change-3292"></span><h3>在Core中添加对Python原生``enum``类型和兼容形式的支持<a class="headerlink" href="#corepython-enum" title="Permalink to this heading">¶</a></h3>
<p>现在可以使用任何符合PEP-435的列举类型构造 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> 类型。使用此模式，输入值和返回值都是实际的枚举对象，而不是字符串/整数等值:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">create_engine</span>


<span class="k">class</span> <span class="nc">MyEnum</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">two</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">three</span> <span class="o">=</span> <span class="mi">3</span>


<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">(),</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">Enum</span><span class="p">(</span><span class="n">MyEnum</span><span class="p">)))</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">e</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">MyEnum</span><span class="o">.</span><span class="n">two</span><span class="p">})</span>
<span class="k">assert</span> <span class="n">e</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">select</span><span class="p">())</span> <span class="ow">is</span> <span class="n">MyEnum</span><span class="o">.</span><span class="n">two</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<section id="enum-enums">
<h4><a href="#id90"><span class="problematic" id="id91">``</span></a>Enum.enums``集合现在是一个列表而不是一个元组<a class="headerlink" href="#enum-enums" title="Permalink to this heading">¶</a></h4>
<p>作为  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a> .Enum.enums` 的元素集合
现在是一个列表，而不是一个元组。这是因为列表
适合长度可变的均质项序列，其中
元素的位置没有语义意义。</p>
<blockquote>
<div><p><a href="#id92"><span class="problematic" id="id93">:ticket:`3292`</span></a></p>
</div></blockquote>
</section>
</section>
<section id="change-2837">
<span id="id94"></span><h3>日志记录和异常显示中现在会截断大的参数和行值<a class="headerlink" href="#change-2837" title="Permalink to this heading">¶</a></h3>
<p>绑定到SQL语句的大值，以及在结果行中存在的大值，将在日志记录、异常报告以及行本身的``repr()``内部截断:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">random</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="s2">&quot;debug&quot;</span><span class="p">)</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">some_value</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chr</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="mi">85</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">5000</span><span class="p">))</span>
  <span class="o">&gt;&gt;&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">some_value</span><span class="p">])</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
  <span class="o">...</span> <span class="c1"># (lines are wrapped for clarity) ...</span>
  <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">17</span> <span class="mi">13</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">03</span><span class="p">,</span><span class="mi">027</span> <span class="n">INFO</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Engine</span> <span class="n">select</span> <span class="err">?</span>
  <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">17</span> <span class="mi">13</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">03</span><span class="p">,</span><span class="mi">027</span> <span class="n">INFO</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Engine</span>
  <span class="p">(</span><span class="s1">&#39;E6@?&gt;9HPOJB&lt;&lt;BHR:@=TS:5ILU=;JLM&lt;4?B9&lt;S48PTNG9&gt;:=TSTLA;9K;9FPM4M8M@;NM6GU</span>
  <span class="n">LUAEBT9QGHNHTHR5EP75</span><span class="nd">@OER4</span><span class="err">?</span><span class="n">SKC</span><span class="p">;</span><span class="n">D</span><span class="p">:</span><span class="n">TFUMD</span><span class="p">:</span><span class="n">M</span><span class="o">&gt;</span><span class="p">;</span><span class="n">C6U</span><span class="p">:</span><span class="n">JLM6R67GEK</span><span class="o">&lt;</span><span class="n">A6</span><span class="nd">@S@C@J7</span><span class="o">&gt;</span><span class="mi">4</span><span class="o">=</span><span class="mi">4</span><span class="p">:</span><span class="n">P</span>
  <span class="n">GJ7HQ6</span> <span class="o">...</span> <span class="p">(</span><span class="mi">4702</span> <span class="n">characters</span> <span class="n">truncated</span><span class="p">)</span> <span class="o">...</span> <span class="n">J6IK546AJMB4N6S9L</span><span class="p">;;</span><span class="mi">9</span><span class="n">AKI</span><span class="p">;</span><span class="o">=</span><span class="n">RJP</span>
  <span class="n">HDSSOTNBUEEC9</span><span class="nd">@Q</span><span class="p">:</span><span class="n">RCL</span><span class="p">:</span><span class="n">I</span><span class="o">@</span><span class="mi">5</span><span class="err">?</span><span class="n">FO</span><span class="o">&lt;</span><span class="mi">9</span><span class="n">K</span><span class="o">&gt;</span><span class="n">KJAGAO</span><span class="nd">@E6@A7JI8O</span><span class="p">:</span><span class="n">J7B69T6</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">F</span><span class="p">:</span><span class="n">S</span><span class="p">;</span><span class="mi">4</span><span class="n">BEIJS9HM</span>
  <span class="n">K</span><span class="p">:;</span><span class="mi">5</span><span class="n">OLPM</span><span class="nd">@JR</span><span class="p">;</span><span class="n">R</span><span class="p">:</span><span class="n">J6</span><span class="o">&lt;</span><span class="n">SOTTT</span><span class="o">=&gt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="mi">7</span><span class="n">T</span><span class="nd">@I</span><span class="p">::</span><span class="n">OTDC</span><span class="p">:</span><span class="n">CC</span><span class="o">&lt;=</span><span class="n">NGP6C</span><span class="o">&gt;</span><span class="n">BC8N</span><span class="s1">&#39;,)</span>
  <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">17</span> <span class="mi">13</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">03</span><span class="p">,</span><span class="mi">027</span> <span class="n">DEBUG</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Engine</span> <span class="n">Col</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,)</span>
  <span class="mi">2016</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">17</span> <span class="mi">13</span><span class="p">:</span><span class="mi">23</span><span class="p">:</span><span class="mi">03</span><span class="p">,</span><span class="mi">027</span> <span class="n">DEBUG</span> <span class="n">sqlalchemy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Engine</span>
  <span class="n">Row</span> <span class="p">(</span><span class="sa">u</span><span class="s1">&#39;E6@?&gt;9HPOJB&lt;&lt;BHR:@=TS:5ILU=;JLM&lt;4?B9&lt;S48PTNG9&gt;:=TSTLA;9K;9FPM4M8M@;</span>
  <span class="n">NM6GULUAEBT9QGHNHTHR5EP75</span><span class="nd">@OER4</span><span class="err">?</span><span class="n">SKC</span><span class="p">;</span><span class="n">D</span><span class="p">:</span><span class="n">TFUMD</span><span class="p">:</span><span class="n">M</span><span class="o">&gt;</span><span class="p">;</span><span class="n">C6U</span><span class="p">:</span><span class="n">JLM6R67GEK</span><span class="o">&lt;</span><span class="n">A6</span><span class="nd">@S@C@J7</span>
  <span class="o">&gt;</span><span class="mi">4</span><span class="o">=</span><span class="mi">4</span><span class="p">:</span><span class="n">PGJ7HQ</span> <span class="o">...</span> <span class="p">(</span><span class="mi">4703</span> <span class="n">characters</span> <span class="n">truncated</span><span class="p">)</span> <span class="o">...</span> <span class="n">J6IK546AJMB4N6S9L</span><span class="p">;;</span><span class="mi">9</span><span class="n">AKI</span><span class="p">;</span><span class="o">=</span>
  <span class="n">RJPHDSSOTNBUEEC9</span><span class="nd">@Q</span><span class="p">:</span><span class="n">RCL</span><span class="p">:</span><span class="n">I</span><span class="o">@</span><span class="mi">5</span><span class="err">?</span><span class="n">FO</span><span class="o">&lt;</span><span class="mi">9</span><span class="n">K</span><span class="o">&gt;</span><span class="n">KJAGAO</span><span class="nd">@E6@A7JI8O</span><span class="p">:</span><span class="n">J7B69T6</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">F</span><span class="p">:</span><span class="n">S</span><span class="p">;</span><span class="mi">4</span><span class="n">BEIJS9HM</span>
  <span class="n">MK</span><span class="p">:;</span><span class="mi">5</span><span class="n">OLPM</span><span class="nd">@JR</span><span class="p">;</span><span class="n">R</span><span class="p">:</span><span class="n">J6</span><span class="o">&lt;</span><span class="n">SOTTT</span><span class="o">=&gt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="mi">7</span><span class="n">T</span><span class="nd">@I</span><span class="p">::</span><span class="n">OTDC</span><span class="p">:</span><span class="n">CC</span><span class="o">&lt;=</span><span class="n">NGP6C</span><span class="o">&gt;</span><span class="n">BC8N</span><span class="s1">&#39;,)</span>

<span class="p">:</span><span class="n">ticket</span><span class="p">:</span><span class="err">`</span><span class="mi">2837</span><span class="err">`</span></pre></div>
</div>
<p id="change-3619">Core中添加JSON支持
————————————————– ————————–</p>
<p>由于MySQL现在除了PostgreSQL JSON数据类型外还具有JSON数据类型，因此核心现在增加了一个 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.JSON</span></code></a> 数据类型，该类型是两者的基础。使用此类型允许访问“getitem”运算符以及“getpath”运算符，以一种适用于PostgreSQL和MySQL的方式。</p>
<p>新数据类型还具有一系列对NULL值的处理和表达式处理的改进。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="#change-3547"><span class="std std-ref">MySQL JSON 支持</span></a></p>
<p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a></p>
<p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a></p>
<p><a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON" title="sqlalchemy.dialects.mysql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a></p>
</div></blockquote>
<p><a href="#id95"><span class="problematic" id="id96">:ticket:`3619`</span></a></p>
</div>
<section id="jsonormnull">
<span id="change-3514"></span><h4>JSON支持现在针对ORM操作插入“null”，在未出现时省略<a class="headerlink" href="#jsonormnull" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> .mysql.JSON` 现在有一个标志  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null" title="sqlalchemy.types.JSON"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">JSON.none_as_null</span></code></a>  ，</p>
</div></blockquote>
<p>当设置为True时，表示Python值``None``应该转换为SQL NULL而不是JSON ]NULL值。默认情况下，此标志为False，这意味着Python值``None``应该导致JSON NULL值。</p>
<p>此逻辑将失败，并已进行更正，以下情况：</p>
<p>1.当列还包含默认值或server_default值时，映射到预计持久化JSON“null”的映射属性的正值
在有映射属性可以插入预期的“NULL”值的情况下，仍将导致触发列级默认值，
替换了”None”值:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyObject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">json_value</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">JSON</span><span class="p">(</span><span class="n">none_as_null</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;some default&quot;</span><span class="p">)</span>


<span class="c1"># 将插入“&#39;null&#39;”而不是“&#39;some default&#39;”,</span>
<span class="c1"># 现在将插入“&#39;null&#39;”</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">json_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>2.当列*未*包含默认值或server_default值时，在具有none_as_null=False的JSON列上丢失
将仍然呈现JSON NULL值而不会后退以不插入任何值，会表现出
与所有其他数据类型不同的行为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyObject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">some_other_value</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">json_value</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">JSON</span><span class="p">(</span><span class="n">none_as_null</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>


<span class="c1"># 某些情况下会为some_other_value结果为空，</span>
<span class="c1"># 但是json_value结果是“&#39;null&#39;”。现在两者都为空</span>
<span class="c1"># （json_value从INSERT中省略）</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>这是一个行为改变，对于依赖于默认缺少缺少数据的应用程序来说，这是向后不兼容的情况。这
本质上建立了一个**缺失的值与不存在的值有所区别**。有关此方案的更多详细信息，请参见  <a class="reference internal" href="#behavior-change-3514"><span class="std std-ref">如果没有提供值且未建立默认值，则JSON列将不插入JSON NULL</span></a> 。</p>
<p>3.当使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.bulk_insert_mappings()</span></code>  方法时，将在所有情况下忽略` <cite>None`</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="c1"># 将INSERT SQL空/触发默认值</span>
  <span class="c1"># 现在将插入“&#39;null&#39;”</span>
  <span class="n">session</span><span class="o">.</span><span class="n">bulk_insert_mappings</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span> <span class="p">[{</span><span class="s2">&quot;json_value&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}])</span>

<span class="p">:</span><span class="n">class</span><span class="p">:</span><span class="err">`</span><span class="n">_types</span><span class="o">.</span><span class="n">JSON</span><span class="err">`</span> <span class="o">.</span><span class="n">TypeEngine</span><span class="o">.</span><span class="n">should_evaluate_none</span><span class="err">`</span> <span class="n">标志</span><span class="err">，</span><span class="n">表示不应忽略</span><span class="err">`</span> <span class="err">`</span><span class="kc">None</span><span class="err">``</span><span class="p">;</span><span class="n">它是基于值</span></pre></div>
</div>
<p>自  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null" title="sqlalchemy.types.JSON"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">JSON.none_as_null</span></code></a>  的值进行自动配置。感谢  :ticket:` 3061`  ，我们可以区分用户主动设置的值
与从未设置的值。</p>
<p>该功能也适用于新的基类 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 类型及其后代类型。</p>
<blockquote>
<div><p><a href="#id97"><span class="problematic" id="id98">:ticket:`3514`</span></a></p>
</div></blockquote>
</section>
<section id="json-null">
<span id="change-3514-jsonnull"></span><h4>添加新的JSON.NULL常量<a class="headerlink" href="#json-null" title="Permalink to this heading">¶</a></h4>
<dl class="simple">
<dt>为确保应用程序始终可以完全控制  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 、  :class:` _postgresql.JSON` 、 <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON" title="sqlalchemy.dialects.mysql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 或</dt><dd><p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a> ` “null”<a href="#id99"><span class="problematic" id="id100">``</span></a>值，已添加常量  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON.NULL" title="sqlalchemy.types.JSON.NULL"><code class="xref py py-attr docutils literal notranslate"><span class="pre">JSON.NULL</span></code></a>  ，</p>
</dd>
</dl>
<p>它与  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.null" title="sqlalchemy.sql.expression.null"><code class="xref py py-func docutils literal notranslate"><span class="pre">null()</span></code></a> ` “null”<a href="#id101"><span class="problematic" id="id102">``</span></a>且无论设置：paramref:<cite>.types.JSON.none_as_null</cite>
如何，都可以在两者之间进行。</p>
<blockquote>
<div><p>from sqlalchemy import null
from sqlalchemy.dialects.postgresql import JSON</p>
<p>obj1 = MyObject(json_value=null())  # 将始终插入SQL NULL
obj2 = MyObject(json_value=JSON.NULL)  # 将始终插入JSON字符串“null”</p>
<p>session.add_all([obj1, obj2])
session.commit()</p>
</div></blockquote>
<p>该功能也适用于新的基类 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 类型及其后代类型。</p>
<blockquote>
<div><p><a href="#id103"><span class="problematic" id="id104">:ticket:`3514`</span></a></p>
</div></blockquote>
<p id="change-3516">Core中添加数组支持;添加新的ANY和ALL操作符
————————————————– ——————————</p>
<p>随随着对PostgreSQL  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 。</p>
<p>数组是SQL标准的一部分，与此类似的还有几个面向数组的函数，例如 “array_agg ()”和“unnest ()”。为了支持这些构造不仅适用于PostgreSQL而且也适用于未来的其他具有数组功能的引擎，例如DB2，因此SQL表达式的大部分数组逻辑现在都在Core中。  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 类型仍然仅在 PostgreSQL上工作，但是它可以直接使用，支持特殊的数组用例，例如索引访问，以及对任何和全部的支持：</p>
<blockquote>
<div><p>mytable = Table(“mytable”, metadata, Column(“data”, ARRAY(Integer, dimensions=2)))</p>
<p>expr = mytable.c.data[5][6]</p>
<p>expr = mytable.c.data[5].any(12)</p>
</div></blockquote>
<p>为了支持ANY和ALL，   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> .types.ARRAY.Comparator.any` 和 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all" title="sqlalchemy.types.ARRAY.Comparator.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Comparator.all()</span></code></a> 方法，但还将这些操作导出到新的独立操作函数  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.any_" title="sqlalchemy.sql.expression.any_"><code class="xref py py-func docutils literal notranslate"><span class="pre">any_()</span></code></a> 和  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.all_" title="sqlalchemy.sql.expression.all_"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_()</span></code></a> 中。这两个函数以更传统的SQL方式工作，允许一个右侧表达式形式，例如：</p>
<blockquote>
<div><p>from sqlalchemy import <a href="#id134"><span class="problematic" id="id135">any_</span></a>, <a href="#id136"><span class="problematic" id="id137">all_</span></a></p>
<p>select([mytable]).where(12 == any_(mytable.c.data[5]))</p>
</div></blockquote>
<p>对于PostgreSQL特定的运算符“ contains”，“ contained_by”和“ overlaps”，应继续直接使用  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 类型，该类型提供了  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 类型的所有功能。</p>
<p>现在，  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.any_" title="sqlalchemy.sql.expression.any_"><code class="xref py py-func docutils literal notranslate"><span class="pre">any_()</span></code></a> 和  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.all_" title="sqlalchemy.sql.expression.all_"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_()</span></code></a> 操作符是在Core级别开放的，但是它们在后端数据库中的解释是有限制的。在PostgreSQL后端上，这两个运算符仅接受数组值。然而，在MySQL后端上，它们仅接受子查询值。在MySQL上，可以使用以下表达式：</p>
<blockquote>
<div><blockquote>
<div><p>from sqlalchemy import <a href="#id138"><span class="problematic" id="id139">any_</span></a>, <a href="#id140"><span class="problematic" id="id141">all_</span></a></p>
<p>subq = select([mytable.c.value])
select([mytable]).where(12 &gt; any_(subq))</p>
</div></blockquote>
<p>$&amp;</p>
</div></blockquote>
</section>
</section>
<section id="within-group-array-aggset">
<span id="change-3132"></span><h3>新功能函数，”WITHIN GROUP”，array_agg和set集合函数<a class="headerlink" href="#within-group-array-aggset" title="Permalink to this heading">¶</a></h3>
<p>有了新的   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> ` array_agg ()`` SQL函数，这可以使用   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.array_agg" title="sqlalchemy.sql.functions.array_agg"><code class="xref py py-class docutils literal notranslate"><span class="pre">array_agg</span></code></a>  获得：</p>
<blockquote>
<div><p>from sqlalchemy import func</p>
<p>stmt = select([func.array_agg(table.c.value)])</p>
</div></blockquote>
<p>通过引入   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by" title="sqlalchemy.dialects.postgresql.aggregate_order_by"><code class="xref py py-class docutils literal notranslate"><span class="pre">aggregate_order_by</span></code></a> ，还添加了一个面向PostgreSQL的聚合ORDER BY元素：</p>
<blockquote>
<div><p>from sqlalchemy.dialects.postgresql import aggregate_order_by</p>
<p>expr = func.array_agg(aggregate_order_by(table.c.a, table.c.b.desc()))
stmt = select([expr])</p>
</div></blockquote>
<p>生成结果为：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">array_agg</span><span class="p">(</span><span class="n">table1</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">table1</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="k">DESC</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">array_agg_1</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span></pre></div>
</div>
<p>PG方言本身还提供了   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg" title="sqlalchemy.dialects.postgresql.array_agg"><code class="xref py py-func docutils literal notranslate"><span class="pre">array_agg()</span></code></a>  包装器，以确保   :class:` _postgresql.ARRAY`  类型：</p>
<blockquote>
<div><p>from sqlalchemy.dialects.postgresql import array_agg</p>
<p>stmt = select([array_agg(table.c.value).contains(“foo”)])</p>
</div></blockquote>
<p>此外，像 <code class="docutils literal notranslate"><span class="pre">percentile_cont()</span></code>, <code class="docutils literal notranslate"><span class="pre">percentile_disc()</span></code>,
<code class="docutils literal notranslate"><span class="pre">rank()</span></code>, <a href="#id105"><span class="problematic" id="id106">``</span></a>dense_rank()``和其他需要此功能的函数
“WITHIN GROUP（ORDER BY &lt;expr&gt;）”现已通过  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group" title="sqlalchemy.sql.functions.FunctionElement.within_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.within_group()</span></code></a>  修饰符提供：</p>
<blockquote>
<div><p>from sqlalchemy import func</p>
<dl>
<dt>stmt = select(</dt><dd><dl class="simple">
<dt>[</dt><dd><p>department.c.id,
func.percentile_cont(0.5).within_group(department.c.salary.desc()),</p>
</dd>
</dl>
<p>]</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>上述语句将生成类似的SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">department</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">percentile_cont</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">WITHIN</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">department</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="k">DESC</span><span class="p">)</span></pre></div>
</div>
<p>这些函数的正确返回类型现在提供了占位符，
包括   <code class="xref py py-class docutils literal notranslate"><span class="pre">percentile_cont</span></code> 、   :class:` _sql.expression.percentile_disc` 、</p>
<blockquote>
<div><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">rank</span></code> 、   :class:` _sql.expression.dense_rank` 、</dt><dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">mode</span></code> 、   :class:` _sql.expression.percent_rank`</p>
</dd>
</dl>
</div></blockquote>
<p>和   <code class="xref py py-class docutils literal notranslate"><span class="pre">cume_dist</span></code> 。</p>
<blockquote>
<div><p>$&amp;   $&amp;</p>
</div></blockquote>
</section>
<section id="typedecoratorenum-boolean-schema">
<span id="change-2919"></span><h3>TypeDecorator现在自动使用Enum，Boolean，“schema”类型<a class="headerlink" href="#typedecoratorenum-boolean-schema" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.SchemaType" title="sqlalchemy.types.SchemaType"><code class="xref py py-class docutils literal notranslate"><span class="pre">SchemaType</span></code></a> .Enum`  和  :class:` .Boolean`的类型，除了与相应的数据库类型相对应之外，</p>
</div></blockquote>
<p>还会生成CHECK约束或在PostgreSQL ENUM的情况下创建新的CREATE TYPE语句，现在它们将自动与   <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> .TypeDecorator` 必须如下所示：</p>
<blockquote>
<div><p># old way
class MyEnum(TypeDecorator, SchemaType):</p>
<blockquote>
<div><p>impl = postgresql.ENUM(“one”, “two”, “three”, name=”myenum”)</p>
<dl class="simple">
<dt>def _set_table(self, table):</dt><dd><p>self.impl._set_table(table)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>现在，  <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a> 传播了这些附加事件，因此可以像任何其他类型一样完成:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="c1"># new way</span>
   <span class="k">class</span> <span class="nc">MyEnum</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
       <span class="n">impl</span> <span class="o">=</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">ENUM</span><span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myenum&quot;</span><span class="p">)</span>

<span class="err">$</span><span class="o">&amp;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</section>
<section id="table">
<span id="change-2685"></span><h3>Table对象的多租户模式翻译<a class="headerlink" href="#table" title="Permalink to this heading">¶</a></h3>
<p>为了支持在许多模式中使用相同的一组   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象的应用程序（例如，每个用户的架构），现在添加了一个新的执行选项  :paramref:` .Connection.execution_options.schema_translate_map` 。使用此映射，可以在每个连接基础上使一组   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象引用任何一组模式，而不是它们分配给的  :paramref:` _schema.Table.schema` 。DDL和SQL生成以及ORM都可以使用翻译。</p>
<p>例如，如果“User”类被分配了模式“per_user”：</p>
<blockquote>
<div><dl>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”
id = Column(Integer, primary_key=True)</p>
<p>__table_args__ = {“schema”: “per_user”}</p>
</dd>
</dl>
</div></blockquote>
<p>每次请求时，   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  可以设置为引用不同的模式：</p>
<blockquote>
<div><p>session = Session()
session.connection(</p>
<blockquote>
<div><p>execution_options={“schema_translate_map”: {“per_user”: “account_one”}}</p>
</div></blockquote>
<p>)</p>
<p># will query from the <code class="docutils literal notranslate"><span class="pre">account_one.user</span></code> table
session.query(User).get(5)</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../core/connections.html#schema-translating"><span class="std std-ref">翻译模式名称</span></a></p>
</div></blockquote>
<p>$&amp;</p>
</div>
</section>
<section id="core-sql">
<span id="change-3631"></span><h3>Core SQL构造的“友好”字符串化没有发现方言现在<a class="headerlink" href="#core-sql" title="Permalink to this heading">¶</a></h3>
<p>在Core SQL构造上调用 <code class="docutils literal notranslate"><span class="pre">str()</span></code> 现在会在比以前更多的情况下生成字符串，支持各种默认SQL中通常不存在的 SQL 构造，例如 RETURNING，数组索引和非标准数据类型：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span>
<span class="go">t&gt;&gt;&gt; t = table(&#39;x&#39;, column(&#39;a&#39;), column(&#39;b&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">returning</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(:</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">b</span>
</div></pre></div>
</div>
<p>现在， <code class="docutils literal notranslate"><span class="pre">str()</span></code> 函数调用单独的方言/编译器，旨在进行纯字符串打印，而不设置特定的方言，
因此在出现更多“只有显示给我一个字符串！”的情况时，这些可添加到此语言/编译器中，而不会影响实际方言上的行为。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="#change-3081"><span class="std std-ref">字符串化Query将查阅 Session 获取正确的方言</span></a></p>
</div></blockquote>
<p>$&amp;</p>
</div>
</section>
<section id="type-coercesql">
<span id="change-3531"></span><h3>type_coerce函数现在是一个持久的SQL元素<a class="headerlink" href="#type-coercesql" title="Permalink to this heading">¶</a></h3>
<p>以前，函数   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a>  会返回一个   :class:` .BindParameter`  或   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Label" title="sqlalchemy.sql.expression.Label"><code class="xref py py-class docutils literal notranslate"><span class="pre">Label</span></code></a>  类型的对象，这取决于输入。这会产生这样的影响：如果使用表达式转换，例如将一个元素从   :class:` _schema.Column`  转换为   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> ，这对于ORM级别的懒惰加载是至关重要的，那么类型转换信息将不会被使用，因为它已经丢失了。</p>
<p>为了改进此行为，该函数现在返回一个持久的   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce" title="sqlalchemy.sql.expression.TypeCoerce"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeCoerce</span></code></a>  容器，该容器包围给定表达式，但是该表达式本身不受影响; 此结构由SQL编译器明确评估。这允许内部表达式的类型强制转换保持不变，无论如何修改语句，包括如果包含元素替换为不同元素的情况，这在ORM的懒惰加载功能中很常见。</p>
<p>用于说明效果的测试用例使用了异构的 primaryjoin 条件，以及自定义类型和懒惰加载。在给定应用程序中，假设数据库的字符串“id”列等于另一个表中的整数“id”列：</p>
<blockquote>
<div><dl>
<dt>class Person(Base):</dt><dd><p>__tablename__ = “person”
id = Column(StringAsInt, primary_key=True)</p>
<dl>
<dt>pets = relationship(</dt><dd><p>“Pets”,
primaryjoin=(</p>
<blockquote>
<div><p>“foreign(Pets.person_id)” “==cast(type_coerce(Person.id, Integer), Integer)”</p>
</div></blockquote>
<p>),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>class Pets(Base):</dt><dd><p>__tablename__ = “pets”
id = Column(“id”, Integer, primary_key=True)
person_id = Column(“person_id”, Integer)</p>
</dd>
</dl>
</div></blockquote>
<p>在上述代码中，在  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.primaryjoin</span></code>  表达式中，我们使用   :func:` .type_coerce`  来处理以整数形式传递的绑定参数，因为我们已经知道这些将来自我们将该值作为整数在Python中维护的“StringAsInt”类型。然后，我们正在使用   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> ，以便作为SQL表达式，VARCHAR“id”列将被CAST为整数，用于正常的非转换连接，例如  :meth:` _query.Query.join`  或   <code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code>  的连接。例如，加载 ` <cite>.pets`</cite> 的 joinedload：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">person</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">person_id</span><span class="p">,</span><span class="w"> </span><span class="n">pets_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pets_1_id</span><span class="p">,</span>
<span class="w">       </span><span class="n">pets_1</span><span class="p">.</span><span class="n">person_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pets_1_person_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">person</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">pets</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">pets_1</span>
<span class="k">ON</span><span class="w"> </span><span class="n">pets_1</span><span class="p">.</span><span class="n">person_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">)</span></pre></div>
</div>
<p>在连接中不使用CAST，在PostgreSQL等强类型数据库上将会无法隐式地比较整数并失败。</p>
<p>“ .pets” 的lazyload情况仅依赖于在加载时用绑定参数替换 “Person.id” 列，该绑定参数接收Python加载的值。在需要替换列使用语句时，类型强制转换信息将丢失的情况下，此替换是特定的地方，现在将使用   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a>  函数维护包装，即使在列为绑定参数替换为其他列的情况下，查询也会像上面所述那样进行。</p>
<blockquote>
<div><p>$&amp;</p>
</div></blockquote>
</section>
</section>
<section id="id107">
<h2>主要行为更改 - ORM<a class="headerlink" href="#id107" title="Permalink to this heading">¶</a></h2>
<section id="jsonjson-null">
<span id="behavior-change-3514"></span><h3>如果没有提供值且未建立默认值，则JSON列将不插入JSON NULL<a class="headerlink" href="#jsonjson-null" title="Permalink to this heading">¶</a></h3>
<p>如   <a class="reference internal" href="#change-3514"><span class="std std-ref">JSON支持现在针对ORM操作插入“null”，在未出现时省略</span></a>  中所述，  :class:` _types.JSON`  不会再在值完全丢失时呈现JSON“null”值。为了防止SQL NULL，应该设置默认值。给定以下映射：</p>
<blockquote>
<div><dl>
<dt>class MyObject(Base):</dt><dd><p># …</p>
<p>json_value = Column(JSON(none_as_null=False), nullable=False)</p>
</dd>
</dl>
</div></blockquote>
<p>以下提交操作将失败并引发完整性错误：</p>
<blockquote>
<div><p>obj = MyObject()  # 注意没有 json_value
session.add(obj)
session.commit()  # 将引发完整性错误</p>
</div></blockquote>
<p>如果列的默认值应该是JSON NULL，则应设置该值：</p>
<blockquote>
<div><dl>
<dt>class MyObject(Base):</dt><dd><p># …</p>
<p>json_value = Column(JSON(none_as_null=False), nullable=False, default=JSON.NULL)</p>
</dd>
</dl>
</div></blockquote>
<p>否则，请确保对象上存在该值：</p>
<blockquote>
<div><p>obj = MyObject(json_value=None)
session.add(obj)
session.commit()  # 将插入JSON NULL</p>
</div></blockquote>
<p>请注意，将  <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null" title="sqlalchemy.types.JSON"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">JSON.none_as_null</span></code></a>  标志设置为 ` <cite>None`</cite> 与完全省略它相同；该标志对于传递给  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.default</span></code></a>  或  :paramref:` _schema.Column.server_default`  的 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值不产生影响。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#change-3514"><span class="std std-ref">JSON支持现在针对ORM操作插入“null”，在未出现时省略</span></a></p>
</div>
</section>
<section id="distinct-order-by-validates">
<span id="change-3641"></span><h3>DISTINCT + ORDER BY的相同命名的&#64;validates装饰符现在会引发异常<a class="headerlink" href="#distinct-order-by-validates" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../orm/mapped_attributes.html#id0" title="sqlalchemy.orm.validates"><code class="xref py py-class docutils literal notranslate"><span class="pre">validates</span></code></a>  装饰器只应为特定属性名称的类创建一次。创建多个现在会引发错误，虽然先前它会默默选择最后定义的验证器：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”
id = Column(Integer, primary_key=True)</p>
<p>data = Column(String)</p>
<p>&#64;validates(“data”)
def _validate_data_one(self):</p>
<blockquote>
<div><p>assert “x” in data</p>
</div></blockquote>
<p>&#64;validates(“data”)
def _validate_data_two(self):</p>
<blockquote>
<div><p>assert “y” in data</p>
</div></blockquote>
</dd>
</dl>
<p>configure_mappers()</p>
</div></blockquote>
</div></blockquote>
<p>将引发以下错误：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>   sqlalchemy.exc.InvalidRequestError: A validation function for mapped attribute &#39;data&#39;
   on mapper Mapper|A|a already exists.

$&amp;</pre></div>
</div>
</section>
</section>
<section id="core">
<h2>主要行为更改 - Core<a class="headerlink" href="#core" title="Permalink to this heading">¶</a></h2>
<section id="textclause-columns">
<span id="behavior-change-3501"></span><h3>当按位置传递列时，TextClause.columns()将按位置而不是按名称进行匹配<a class="headerlink" href="#textclause-columns" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>  方法的新行为，它本身实际上是在0.9系列中添加的，现在，在位置上传递列而不添加任何其他关键字参数时，它们与最终结果集的列位置相关联，而不是名称。由于该方法一直都在文档中说明列以与文本SQL中列的相同顺序传递，因此对该方法的内部不再进行检查，并且应用程序使用此方法将在将   :class:` _schema.Column`  对象按位置传递给该方法时确保这些   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象的位置与文本SQL中声明这些列的位置相同。</p>
</div></blockquote>
<p>例如，如下代码：</p>
<blockquote>
<div><p>stmt = text(“SELECT id, name, description FROM table”)</p>
<p># no longer matches by name
stmt = stmt.columns(my_table.c.name, my_table.c.description, my_table.c.id)</p>
</div></blockquote>
<p>现在不再像预期的那样工作了；现在给出的列的顺序已经具有重要意义：</p>
<blockquote>
<div><p>stmt = stmt.columns(my_table.c.id, my_table.c.name, my_table.c.description)</p>
</div></blockquote>
<p>可能更有可能的是，类似如下的语句：</p>
<blockquote>
<div><p>stmt = text(“SELECT * FROM table”)
stmt = stmt.columns(my_table.c.id, my_table.c.name, my_table.c.description)</p>
</div></blockquote>
<p>现在稍微有些冒险，因为“*”规范通常按表中的存在顺序提供列。如果表结构因模式更改而更改，则此排序可能不再相同。
因此，使用  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns" title="sqlalchemy.sql.expression.TextClause.columns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TextClause.columns()</span></code></a>  方法建议在文本SQL中明确列出所需的列，尽管在文本SQL中名称本身不再需要担心。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">change_3501</span></p>
</div>
</section>
<section id="server-default">
<span id="change-3809"></span><h3>字符串server_default现在是文字引用<a class="headerlink" href="#server-default" title="Permalink to this heading">¶</a></h3>
<p>现在，将字符串 server_default 作为普通Python字符串传递到  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.server_default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_default</span></code></a>  的服务器默认值现在将通过文字引用系统传递：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.schema</span> <span class="kn">import</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">CreateTable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="kn">import</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">(),</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(),</span> <span class="n">server_default</span><span class="o">=</span><span class="s2">&quot;hi &#39; there&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">CreateTable</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;hi &#39;&#39; there&#39;</span>
<span class="p">)</span>
</div></pre></div>
</div>
<p>先前的引号会直接呈现。对于具有此类用例的应用程序，此更改可能是不向后兼容的。</p>
<blockquote>
<div><p>$&amp;</p>
</div></blockquote>
</section>
<section id="limit-offset-order-byselectunion">
<span id="change-2528"></span><h3>带有LIMIT / OFFSET / ORDER BY的SELECT的UNION或类似操作现在在嵌入式选​​择中加括号<a class="headerlink" href="#limit-offset-order-byselectunion" title="Permalink to this heading">¶</a></h3>
<p>“ UNION”查询由多个 包含行限制或排序行为（包括LIMIT，OFFSET和/或 ORDER BY） 的 SELECT语句组成，例如：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">UNION</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span></pre></div>
</div>
<p>此查询需要在每个子选择中使用括号以便正确组合子结果。
在 SQLAlchemy Core 中生成上述查询的方法类似于此：</p>
<blockquote>
<div><p>stmt1 = select([table1.c.x]).order_by(table1.c.y).limit(1)
stmt2 = select([table1.c.x]).order_by(table2.c.y).limit(2)</p>
<p>stmt = union(stmt1, stmt2)</p>
</div></blockquote>
<p>先前，上述结构不会产生内部SELECT语句的括号，从而产生了一个在所有后端上均失败的查询。</p>
<p>以上格式将在SQLite上 <strong>继续失败</strong>；此外，在Oracle上， <strong>仅按顺序排列</strong> 而没有 LIMIT / SELECT 的格式将 <strong>继续失败</strong>。
这不是向后不兼容的更改，因为查询在没有括号的情况下失败；修复后，查询顶多在所有其他数据库上正常工作。</p>
<p>在所有情况下，在调用与嵌套自描述查询一起使用很少用到的情况下，为了产生一个有限的SELECT语句的UNION语句存在工作风险，因此建议使用子查询：：</p>
<blockquote>
<div><p>stmt1 = select([table1.c.x]).order_by(table1.c.y).limit(1).alias().select()
stmt2 = select([table2.c.x]).order_by(table2.c.y).limit(2).alias().select()</p>
<p>stmt = union(stmt1, stmt2)</p>
</div></blockquote>
<p>这种解决方法在所有 SQLAlchemy 版本中都可以使用。在 ORM 中，看起来像：</p>
<blockquote>
<div><p>stmt1 = session.query(Model1).order_by(Model1.y).limit(1).subquery().select()
stmt2 = session.query(Model2).order_by(Model2.y).limit(1).subquery().select()</p>
<p>stmt = session.query(Model1).from_statement(stmt1.union(stmt2))</p>
</div></blockquote>
<p>此行为具有与 SQLAlchemy 0.9 中   <span class="xref std std-ref">feature_joins_09</span>  中介绍的 “join rewriting” 行为的许多相似之处；
但是，在这种情况下，我们选择不添加新的重写行为以适应此用例的 SQLite，现有的重写行为已经非常复杂了。
使用此功能的 UNION 与带有括号的 SELECT 语句的情况比   <span class="xref std std-ref">feature_joins_09</span>  中的案例要少得多。</p>
<blockquote>
<div><p>$&amp;</p>
</div></blockquote>
</section>
</section>
<section id="dialect-improvements-and-changes-postgresql">
<h2>Dialect Improvements and Changes - PostgreSQL<a class="headerlink" href="#dialect-improvements-and-changes-postgresql" title="Permalink to this heading">¶</a></h2>
<section id="insert-on-conflict-do-update-do-nothing">
<span id="change-3529"></span><h3>支持INSERT.. ON CONFLICT（DO UPDATE | DO NOTHING）<a class="headerlink" href="#insert-on-conflict-do-update-do-nothing" title="Permalink to this heading">¶</a></h3>
<p>自PostgreSQL 9.5起新增加的“ON CONFLICT”子句在   <code class="xref py py-func docutils literal notranslate"><span class="pre">sqlalchemy.dialects.postgresql.dml.insert()</span></code>  中现在已经通过   :class:` _expression.Insert`  子类支持。此   <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert" title="sqlalchemy.sql.expression.Insert"><code class="xref py py-class docutils literal notranslate"><span class="pre">Insert</span></code></a>  子类添加了两个新方法  :meth:` _expression.Insert.on_conflict_do_update`  和  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.on_conflict_do_nothing()</span></code> ，这两个方法实现了这个领域支持的所有语法：</p>
<blockquote>
<div><p>from sqlalchemy.dialects.postgresql import insert</p>
<p>insert_stmt = insert(my_table).values(id=”some_id”, data=”some data to insert”)</p>
<dl class="simple">
<dt>do_update_stmt = insert_stmt.on_conflict_do_update(</dt><dd><p>index_elements=[my_table.c.id], set_=dict(data=”some data to update”)</p>
</dd>
</dl>
<p>)</p>
<p>conn.execute(do_update_stmt)</p>
</div></blockquote>
<p>以上将呈现：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span>
<span class="k">VALUES</span><span class="w"> </span><span class="p">(:</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="k">data</span><span class="p">)</span>
<span class="k">ON</span><span class="w"> </span><span class="n">CONFLICT</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">DO</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="k">data</span><span class="o">=</span><span class="p">:</span><span class="n">data_2</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../dialects/postgresql.html#postgresql-insert-on-conflict"><span class="std std-ref">INSERT…ON CONFLICT (Upsert)</span></a></p>
</div></blockquote>
<p>$&amp;</p>
</div>
</section>
<section id="arrayjson">
<span id="change-3499-postgresql"></span><h3>ARRAY和JSON类型现在正确指定为“不可哈希的”<a class="headerlink" href="#arrayjson" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>如   <a class="reference internal" href="#change-3499"><span class="std std-ref">关于“不可Hash”类型的特定检查，对 ORM 行进行了排重处理</span></a>  中所述，ORM依靠能够为列值生成散列函数，例如当查询的所选实体混合了完整的ORM实体和列表达式时。 ` <cite>hashable=False`</cite> 现在已正确设置在PG的所有“数据结构”类型上，包括   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a>  和   :class:` _postgresql.JSON` 。</dt><dd><p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a>  和   :class:` .HSTORE`  类型已包含此标志。对于   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> ，这取决于  :paramref:` .postgresql.ARRAY.as_tuple`  标志的条件，但是现在应该不再需要设置此标志才能在组合的ORM行中具有数组值。</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="#change-3499"><span class="std std-ref">关于“不可Hash”类型的特定检查，对 ORM 行进行了排重处理</span></a></p>
<p><a class="reference internal" href="#change-3503"><span class="std std-ref">从ARRAY，JSON，HSTORE的索引访问现在正确建立了正确的SQL类型</span></a></p>
</div></blockquote>
<p>$&amp;</p>
</div>
</section>
<section id="array-json-hstoresql">
<span id="change-3503"></span><h3>从ARRAY，JSON，HSTORE的索引访问现在正确建立了正确的SQL类型<a class="headerlink" href="#array-json-hstoresql" title="Permalink to this heading">¶</a></h3>
<p>对于   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 、   :class:` _postgresql.JSON`  和   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE" title="sqlalchemy.dialects.postgresql.HSTORE"><code class="xref py py-class docutils literal notranslate"><span class="pre">HSTORE</span></code></a> ，返回的表示为索引访问的表达式的SQL类型应在所有情况下正确。</p>
<p>其中包括：</p>
<ul class="simple">
<li><p>分配给   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a>  索引访问的SQL类型会考虑配置的维数数量。具有三个维度的   :class:` _postgresql.ARRAY`  将返回类型为   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a>  的SQL表达式的表达式</p></li>
</ul>
</section>
<section id="id108">
<h3>减小一维数组大小<a class="headerlink" href="#id108" title="Permalink to this heading">¶</a></h3>
<p>对于具有类型``ARRAY(Integer, dimensions=3)``的列，现在可以执行以下表达式：</p>
<blockquote>
<div><p>int_expr = col[5][6][7]  # 返回整数表达式对象</p>
</div></blockquote>
<p>以前，访问``col [5]``的索引访问将返回类型为 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>
的表达式，我们无法再访问剩余维度，除非使用  <code class="xref py py-func docutils literal notranslate"><span class="pre">Cast()</span></code>
或  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> 。</p>
<blockquote>
<div><p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a></p>
</div></blockquote>
<hr class="docutils" />
<p>现在， <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 和  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a> 类型反映了PostgreSQL本身
对于索引访问所做的操作。这意味着所有针对  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 或</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a> 类型的索引访问都将返回一个总是  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 或</dt><dd><p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a> ~.postgresql.JSON.Comparator.astext`</p>
</dd>
</dl>
</div></blockquote>
<p>修饰符，否则不会将JSON结构的索引访问归类为其他原生类型，比如字符串、列表、数字等等。
这意味着，和   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a>  类型一样，现在可以直接生成具有多层索引访问的JSON表达式：</p>
<blockquote>
<div><p>json_expr = json_col[“key1”][“attr1”][5]</p>
</div></blockquote>
<p>对于 <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE" title="sqlalchemy.dialects.postgresql.HSTORE"><code class="xref py py-class docutils literal notranslate"><span class="pre">HSTORE</span></code></a> 的索引访问，返回的“文本”类型以及
与  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 和  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB" title="sqlalchemy.dialects.postgresql.JSONB"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONB</span></code></a> 的索引
访问一起使用  <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext" title="sqlalchemy.dialects.postgresql.JSON.Comparator.astext"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Comparator.astext</span></code></a>  修饰符的“文本”类型
是可配置的；默认值为   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.TextClause" title="sqlalchemy.sql.expression.TextClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextClause</span></code></a> ，但可以使用  :paramref:` .postgresql.JSON.astext_type`  或</p>
<blockquote>
<div><p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type" title="sqlalchemy.dialects.postgresql.HSTORE"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">HSTORE.text_type</span></code></a> 参数设置为用户定义的类型。</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><span class="xref std std-ref">change_3503_cast</span></p>
</div></blockquote>
<p><a href="#id109"><span class="problematic" id="id110">:ticket:`3499`</span></a>
<a href="#id111"><span class="problematic" id="id112">:ticket:`3487`</span></a></p>
</div>
</section>
<section id="the-json-cast-astext">
<h3>The JSON cast() 操作现在要求显式调用 <cite>.astext</cite><a class="headerlink" href="#the-json-cast-astext" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>作为   <a class="reference internal" href="#change-3503"><span class="std std-ref">从ARRAY，JSON，HSTORE的索引访问现在正确建立了正确的SQL类型</span></a>   运算符的操作</dt><dd><p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> .postgresql.JSON.Comparator.astext`</p>
</dd>
</dl>
<p>修饰符；PostgreSQL的JSON/JSONB类型支持彼此之间的CAST操作，而不需要“astext”方面。</p>
<p>这意味着在大多数情况下，做了这样的应用：</p>
<blockquote>
<div><p>expr = json_col [“somekey”].cast(Integer)</p>
</div></blockquote>
<p>现在需要更改为：</p>
<blockquote>
<div><p>expr = json_col [“somekey”].astext.cast(Integer)</p>
</div></blockquote>
</section>
<section id="arrayenumenum-create-type">
<span id="change-2729"></span><h3>ARRAY与ENUM将为ENUM生成 CREATE TYPE<a class="headerlink" href="#arrayenumenum-create-type" title="Permalink to this heading">¶</a></h3>
<p>类似如下的表定义现在将如预期一样生成 CREATE TYPE：</p>
<blockquote>
<div><dl class="simple">
<dt>enum = Enum(</dt><dd><p>“manager”,
“place_admin”,
“carwash_admin”,
“parking_admin”,
“service_admin”,
“tire_admin”,
“mechanic”,
“carwasher”,
“tire_mechanic”,
name=”work_place_roles”,</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>class WorkPlacement(Base):</dt><dd><p>__tablename__ = “work_placement”
id = Column(Integer, primary_key=True)
roles = Column(ARRAY(enum))</p>
</dd>
</dl>
<p>e = create_engine(“postgresql://scott:tiger&#64;localhost/test”, echo=True)
Base.metadata.create_all(e)</p>
</div></blockquote>
<p>输出如下：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">CREATE</span><span class="w"> </span><span class="k">TYPE</span><span class="w"> </span><span class="n">work_place_roles</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">ENUM</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="s1">&#39;manager&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;place_admin&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;carwash_admin&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;parking_admin&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;service_admin&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;tire_admin&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;mechanic&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;carwasher&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="s1">&#39;tire_mechanic&#39;</span><span class="p">)</span>

<span class="w">  </span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">work_placement</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="n">id</span><span class="w"> </span><span class="nb">SERIAL</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="n">roles</span><span class="w"> </span><span class="n">work_place_roles</span><span class="p">[],</span>
<span class="w">      </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>


<span class="p">:</span><span class="n">ticket</span><span class="p">:</span><span class="o">`</span><span class="mi">2729</span><span class="o">`</span></pre></div>
</div>
</section>
<section id="check">
<h3><a href="#id113"><span class="problematic" id="id114">``</span></a><a href="#id115"><span class="problematic" id="id116">`</span></a>check```约束现在被反映<a class="headerlink" href="#check" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>PostgreSQL dialect 现在支持  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_check_constraints()</span></code>  中检查约束的反射，以及</dt><dd><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  值得一提的是，反映了  :attr:` _schema.Table.constraints`  集合内的 CHECK 约束。</p>
</dd>
</dl>
</section>
<section id="id117">
<h3>可以分别检查“普通”和“材质化”视图<a class="headerlink" href="#id117" title="Permalink to this heading">¶</a></h3>
<p>新的参数  <code class="xref py py-paramref docutils literal notranslate"><span class="pre">PGInspector.get_view_names.include</span></code>  允许指定应返回哪些视图的子类型：</p>
<blockquote>
<div><blockquote>
<div><p>from sqlalchemy import insp</p>
<p>insp = inspect(engine)</p>
<p>plain_views = insp.get_view_names(include=”plain”)
all_views = insp.get_view_names(include=(“plain”, “materialized”))</p>
</div></blockquote>
<p><a href="#id118"><span class="problematic" id="id119">:ticket:`3588`</span></a></p>
</div></blockquote>
</section>
<section id="indextablespace">
<h3>向Index添加tablespace选项<a class="headerlink" href="#indextablespace" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Index" title="sqlalchemy.schema.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> ` postgresql_tablespace``，以指定TABLESPACE，</p>
</div></blockquote>
<p>就像 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象一样。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../dialects/postgresql.html#postgresql-index-storage"><span class="std std-ref">Index Storage Parameters</span></a></p>
</div></blockquote>
<p><a href="#id120"><span class="problematic" id="id121">:ticket:`3720`</span></a></p>
</div>
</section>
<section id="for-update-skip-for-no-key-update-for-key-share">
<h3>对于FOR UPDATE SKIP锁定/ FOR NO KEY UPDATE / FOR KEY SHARE的支持<a class="headerlink" href="#for-update-skip-for-no-key-update-for-key-share" title="Permalink to this heading">¶</a></h3>
<p>Core 和 ORM 中的  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked" title="sqlalchemy.sql.expression.GenerativeSelect.with_for_update"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">GenerativeSelect.with_for_update.skip_locked</span></code></a>
和  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share" title="sqlalchemy.sql.expression.GenerativeSelect.with_for_update"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">GenerativeSelect.with_for_update.key_share</span></code></a>  新参数在 PostgreSQL 后端查询时应用了
“SELECT…FOR UPDATE”或“SELECT…FOR SHARE”的修改：</p>
<ul>
<li><p>SELECT FOR NO KEY UPDATE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="p">])</span><span class="o">.</span><span class="n">with_for_update</span><span class="p">(</span><span class="n">key_share</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p>SELECT FOR UPDATE SKIP LOCKED:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="p">])</span><span class="o">.</span><span class="n">with_for_update</span><span class="p">(</span><span class="n">skip_locked</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p>SELECT FOR KEY SHARE:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="p">])</span><span class="o">.</span><span class="n">with_for_update</span><span class="p">(</span><span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key_share</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="dialect-improvements-and-changes-mysql">
<h2>Dialect Improvements and Changes - MySQL<a class="headerlink" href="#dialect-improvements-and-changes-mysql" title="Permalink to this heading">¶</a></h2>
<section id="mysql-json">
<span id="change-3547"></span><h3>MySQL JSON 支持<a class="headerlink" href="#mysql-json" title="Permalink to this heading">¶</a></h3>
<p>MySQL 5.7 新添加了 JSON 类型，MySQL 方言增加了新的类型  <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON" title="sqlalchemy.dialects.mysql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> ，支持该类型。此类型同时提供JSON的持久性和基于“JSON_EXTRACT”函数的基本索引访问。可以通过使用通用于MySQL和PostgreSQL的 :class:` _types.JSON`数据类型来实现跨MySQL和PostgreSQL的可索引JSON列。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><span class="xref std std-ref">change_3619</span></p>
</div></blockquote>
<p><a href="#id122"><span class="problematic" id="id123">:ticket:`3547`</span></a></p>
</div>
</section>
<section id="autocommit">
<span id="change-3332"></span><h3>新增对 AUTOCOMMIT“隔离级别”的支持<a class="headerlink" href="#autocommit" title="Permalink to this heading">¶</a></h3>
<dl>
<dt>MySQL 方言现在接受值“AUTOCOMMIT”作为 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.isolation_level</span></code> 和</dt><dd><p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level" title="sqlalchemy.engine.Connection.execution_options"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Connection.execution_options.isolation_level</span></code></a>   参数：</p>
<blockquote>
<div><p>connection = engine.connect()
connection = connection.execution_options(isolation_level=”AUTOCOMMIT”)</p>
</div></blockquote>
</dd>
</dl>
<p>隔离级别使用大多数 MySQL DBAPI 提供的各种“autocommit”的属性。</p>
<blockquote>
<div><p><a href="#id124"><span class="problematic" id="id125">:ticket:`3332`</span></a></p>
</div></blockquote>
</section>
<section id="auto-increment">
<span id="change-mysql-3216"></span><h3>不再为具有AUTO_INCREMENT的组合主键生成隐式键<a class="headerlink" href="#auto-increment" title="Permalink to this heading">¶</a></h3>
<p>MySQL 方言的行为是，如果InnoDB表上的复合主键通过一个或多个自增列进行配置，而自增列并不是第一列，如：</p>
<blockquote>
<div><dl class="simple">
<dt>t = Table(</dt><dd><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True, autoincrement=False),
Column(“y”, Integer, primary_key=True, autoincrement=True),
mysql_engine=”InnoDB”,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>上述 ddl 将生成：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span>
<span class="w">    </span><span class="k">KEY</span><span class="w"> </span><span class="n">idx_autoinc_y</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="p">)</span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span></pre></div>
</div>
<p>注意上面的“KEY”和自动生成的名称；这是许多年前改编该方言的响应之后的一项更改，该方言已经发出多年的警告，现在应该调用“sqlalchemy.dialects.postgresql”。</p>
<p>现在，这个解决方案已被删除并替换为更好的系统，只需要在主键中明确声明自动增量列 * 在主键列中* ：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">)</span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span></pre></div>
</div>
<p>为了保持对主键列顺序的明确控制，您可以显式使用  <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="sqlalchemy.schema.PrimaryKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a> 构造（1.1.0b2）（以及一个必需的自动增量列的KEY，如需要的MySQL），例如：</p>
<blockquote>
<div><dl class="simple">
<dt>t = Table(</dt><dd><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True, autoincrement=True),
PrimaryKeyConstraint(“x”, “y”),
UniqueConstraint(“y”),
mysql_engine=”InnoDB”,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>随着   <a class="reference internal" href="#change-3216"><span class="std std-ref">现在不再针对复合主键列隐式启用`.autoincrement`指令</span></a>  的改变，具有或不具有自动增量的组合主键现在更容易指定；</dt><dd><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.autoincrement</span></code></a>  现在默认为值 ` <cite>“auto”`</cite>，不再需要 <code class="docutils literal notranslate"><span class="pre">autoincrement=False</span></code> 指令：</p>
<blockquote>
<div><dl class="simple">
<dt>t = Table(</dt><dd><p>“some_table”,
metadata,
Column(“x”, Integer, primary_key=True),
Column(“y”, Integer, primary_key=True, autoincrement=True),
mysql_engine=”InnoDB”,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
</section>
</section>
<section id="dialect-improvements-and-changes-sqlite">
<h2>Dialect Improvements and Changes - SQLite<a class="headerlink" href="#dialect-improvements-and-changes-sqlite" title="Permalink to this heading">¶</a></h2>
<section id="sqlite-3-7-16">
<span id="change-3634"></span><h3>SQLite 3.7.16 版本解决了的正确处理右嵌套链接<a class="headerlink" href="#sqlite-3-7-16" title="Permalink to this heading">¶</a></h3>
<p>在版本0.9中，通过   <span class="xref std std-ref">feature_joins_09</span>  引入了新特性，它花费了很多的功夫来支持重写在SQLite上的联接，以始终使用子查询来实现“right-nested-join”效果，因为SQLite多年来没有支持这个语法的方法。有趣的是，标记在这个迁移注释中的SQLite版本，即3.7.15.2版本，实际上是最后一个实际上拥有此限制的SQLite版本！下一个发布版本是3.7.16，而恰恰是支持了右嵌套链接。在1.1中，执行了查找这个更改发生的特定SQLite版本和源提交的工作（SQLite的更改日志以加密短语“增强查询优化器以利用传递式连接限制”而没有链接任何问题编号，更改编号或更多解释），并且这种解决方法现在已经被 SQLite 的版本检测到，并针对版本3.7.16或更高版本关闭了这种行为。</p>
<blockquote>
<div><p><a href="#id126"><span class="problematic" id="id127">:ticket:`3634`</span></a></p>
</div></blockquote>
</section>
<section id="sqlite-3-10-0">
<span id="change-3633"></span><h3>取消 SQLite 版本 3.10.0 解决了集合的列名问题的“点”符号列名的解决方法<a class="headerlink" href="#sqlite-3-10-0" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>SQLite 方言长期以来都使用了一个解决方法来解决这个问题，即数据库驱动程序没有为某些 SQL 结果集正确报告列名，特别是在使用 UNION 时；</dt><dd><p><a class="reference internal" href="../dialects/sqlite.html#sqlite-dotted-column-names"><span class="std std-ref">Dotted Column Names</span></a>  详细描述了这个解决方法，其中要求 SQLAlchemy 假定任何具有一个字符点的列名实际上是通过此错误行为传递的 ` <cite>tablename.columnname`</cite> 组合，并通过``sqlite_raw_colnames `` 执行选项将其关闭。</p>
</dd>
</dl>
<p>截至 SQLite 3.10.0 版本，修复了 UNION 和其他查询中的错误，就像在   <a class="reference internal" href="#change-3634"><span class="std std-ref">SQLite 3.7.16 版本解决了的正确处理右嵌套链接</span></a>  中描述的那样。就像更改描述中所述的那样，SQLite 的更改日志仅以加密短语“已将colUsed字段添加到sqlite3_index_info中，供sqlite3_module.xBestIndex方法使用”命名，没有链接到任何问题编号、更改编号或更多的解释。</p>
<p>总的来说，从1.0系列开始，SQLAlchemy   <code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code>  不再依赖于结果集中的列名，以提供 Core 和 ORM 的 SQL 构造结果。</p>
<blockquote>
<div><p><a href="#id128"><span class="problematic" id="id129">:ticket:`3633`</span></a></p>
</div></blockquote>
</section>
<section id="change-sqlite-schemas">
<span id="id130"></span><h3>对远程模式的支持做出了改进<a class="headerlink" href="#change-sqlite-schemas" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>SQLite方言通过实现  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_schema_names()</span></code>  ，并显著改进了被创建并反射的来自远程模式的表和索引，远程模式是通过 ` <cite>ATTACH`</cite> 语句分配名称的数据库。以前，数据库在一个分隔名表上创建索引无法正确工作，并且</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_foreign_keys()</span></code>   方法现在会在结果中指示给定的模式。不支持跨模式外键。</p>
</dd>
</dl>
</section>
<section id="change-3629">
<span id="id131"></span><h3>反射主键约束名称<a class="headerlink" href="#change-3629" title="Permalink to this heading">¶</a></h3>
<p>SQLite 后端现在利用 SQLite 的 “sqlite_master” 视图，以从原始 DDL 提取表的主键约束名称，就像在近期 SQLAlchemy 版本中为外键约束所实现的那样。</p>
<blockquote>
<div><p><a href="#id132"><span class="problematic" id="id133">:ticket:`3629`</span></a></p>
</div></blockquote>
</section>
<section id="max">
<h3>现在不再强制字符串/变长类型在反映时显式表示为“max”<a class="headerlink" href="#max" title="Permalink to this heading">¶</a></h3>
<p>反映   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> 、  :class:` _expression.TextClause` （等含长度的类型）的类型时，一个“未设长度”的类型在 SQL Server 上会将“长度”参数复制为值 <code class="docutils literal notranslate"><span class="pre">&quot;max&quot;</span></code>：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mssql+pyodbc://scott:tiger@ms_2008&quot;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table s (x varchar(max), y varbinary(max))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">insp</span><span class="o">.</span><span class="n">get_columns</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">print</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="go">&lt;class &#39;sqlalchemy.sql.sqltypes.VARCHAR&#39;&gt; max</span>
<span class="go">&lt;class &#39;sqlalchemy.dialects.mssql.base.VARBINARY&#39;&gt; max</span></pre></div>
</div>
<p>在基本类型中，“长度”参数预期是一个整数值或仅为None的值；
None 表示无界限制长度，在 SQL Server 方言中将其解释为“max”。因此，修复长度应设置为 None，以便类型对象在非 SQL Server 上下文中工作：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">insp</span><span class="o">.</span><span class="n">get_columns</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">print</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="go">&lt;class &#39;sqlalchemy.sql.sqltypes.VARCHAR&#39;&gt; None</span>
<span class="go">&lt;class &#39;sqlalchemy.dialects.mssql.base.VARBINARY&#39;&gt; None</span></pre></div>
</div>
<p>应用程序可能依靠将“长度”值直接与字符串“max”进行比较，应考虑使用值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 代替相同的含义。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="migration_12.html" title="previous chapter">SQLAlchemy 1.2有哪些新特性?</a>
        Next:
        <a href="migration_10.html" title="next chapter">SQLAlchemy 1.0有哪些新特性？</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:58:38

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


