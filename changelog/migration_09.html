<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    SQLAlchemy 0.9 的新特性
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="变更和迁移" href="index.html" />
        <link rel="next" title="SQLAlchemy 0.8有哪些新特性？" href="migration_08.html" />
        <link rel="prev" title="SQLAlchemy 1.0有哪些新特性？" href="migration_10.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="变更和迁移">变更和迁移</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="migration_20.html">SQLAlchemy 2.0 - 主要迁移指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="whatsnew_20.html">SQLAlchemy 2.0 有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_20.html">2.0 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_14.html">1.4 版本更新历史</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9版本更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">版本记录</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_14.html">SQLAlchemy 1.4有哪些新内容？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">SQLAlchemy 1.3有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">SQLAlchemy 1.2有哪些新特性?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_11.html">SQLAlchemy 1.1新功能</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_10.html">SQLAlchemy 1.0有哪些新特性？</a></span></li>
<li class="selected"><span class="link-container"><strong>SQLAlchemy 0.9 的新特性</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">引言</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id6">平台支持</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#python-2-6-python-3-2to3">针对Python 2.6, 支持Python 3 (无需使用2to3).</a></span></li>
<li><span class="link-container"><a class="reference external" href="#cpython-3">C扩展在Python 3中可用</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm">行为变更 - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#migration-2824">复合属性现在在按属性基础上查询时作为它们的对象形式返回</a></span></li>
<li><span class="link-container"><a class="reference external" href="#meth-query-query-select-from">:meth:`_query.Query.select_from`不再将子句应用于对应的实体</a></span></li>
<li><span class="link-container"><a class="reference external" href="#relationship-viewonly-true-history">在“relationship ()”上使用”viewonly=True”将阻止 history 生效</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sql">关联代理SQL表达式的改进和修复</a></span></li>
<li><span class="link-container"><a class="reference external" href="#none">关联代理缺失标量将返回 None</a></span></li>
<li><span class="link-container"><a class="reference external" href="#attributes-get-history-db">attributes.get_history()现在默认情况下如果值不存在，则查询DB</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#core">行为变更 - Core</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id44">类型对象不再接受被忽略的关键字参数</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id55">)</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id58">)</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id83">加载类</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id90">仅加载</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id97">类指定通配符</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#text">``text()``新功能</a></span></li>
<li><span class="link-container"><a class="reference external" href="#select">从SELECT中插入</a></span></li>
<li><span class="link-container"><a class="reference external" href="#select-query-for-update">新的对于``select()``, ``Query()``的 ‘FOR UPDATE’ 支持</a></span></li>
<li><span class="link-container"><a class="reference external" href="#feature-2867">本机浮点类型的浮点字符串转换精度可进行配置</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-2824">针对ORM查询的列捆绑包</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id126">服务器端版本计数</a></span></li>
<li><span class="link-container"><a class="reference external" href="#include-backrefs-false-validates"><code class="docutils literal notranslate"><span class="pre">include_backrefs</span> <span class="pre">=</span> <span class="pre">False``选项对于``&#64;validates</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#postgresql-json">PostgreSQL JSON类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#automap">Automap扩展</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="migration_08.html">SQLAlchemy 0.8有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">SQLAlchemy 0.7有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">SQLAlchemy 0.6 有哪些新变化?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">SQLAlchemy 0.5有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id1">主要文档更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id6">退化源</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id7">需求更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id8">ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id21">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id22">模式/类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id23">连接池不再默认为线程本地</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#args-args">*args已接受，不再接受*args</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id44">删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id77">已重命名或已移动</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id86">已弃用</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">SQLAlchemy 0.4有什么新功能？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id1">首先要做什么</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id2">模块导入</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id3">对象关系映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id22">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id26">架构和反射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id28">SQL执行</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="migration_10.html" title="previous chapter">SQLAlchemy 1.0有哪些新特性？</a></li>
                <li><b>Next:</b>
                <a href="migration_08.html" title="next chapter">SQLAlchemy 0.8有哪些新特性？</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="变更和迁移">变更和迁移</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#sqlalchemy-0-9">SQLAlchemy 0.9 的新特性</a><ul>
<li><a class="reference internal" href="#id1">引言</a></li>
<li><a class="reference internal" href="#id6">平台支持</a><ul>
<li><a class="reference internal" href="#python-2-6-python-3-2to3">针对Python 2.6, 支持Python 3 (无需使用2to3).</a></li>
<li><a class="reference internal" href="#cpython-3">C扩展在Python 3中可用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm">行为变更 - ORM</a><ul>
<li><a class="reference internal" href="#migration-2824">复合属性现在在按属性基础上查询时作为它们的对象形式返回</a></li>
<li><a class="reference internal" href="#meth-query-query-select-from">:meth:`_query.Query.select_from`不再将子句应用于对应的实体</a></li>
<li><a class="reference internal" href="#relationship-viewonly-true-history">在“relationship ()”上使用”viewonly=True”将阻止 history 生效</a></li>
<li><a class="reference internal" href="#sql">关联代理SQL表达式的改进和修复</a></li>
<li><a class="reference internal" href="#none">关联代理缺失标量将返回 None</a></li>
<li><a class="reference internal" href="#attributes-get-history-db">attributes.get_history()现在默认情况下如果值不存在，则查询DB</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core">行为变更 - Core</a><ul>
<li><a class="reference internal" href="#id44">类型对象不再接受被忽略的关键字参数</a><ul>
<li><a class="reference internal" href="#id55">)</a></li>
<li><a class="reference internal" href="#id58">)</a><ul>
<li><a class="reference internal" href="#id83">加载类</a></li>
<li><a class="reference internal" href="#id90">仅加载</a></li>
<li><a class="reference internal" href="#id97">类指定通配符</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#text">``text()``新功能</a></li>
<li><a class="reference internal" href="#select">从SELECT中插入</a></li>
<li><a class="reference internal" href="#select-query-for-update">新的对于``select()``, ``Query()``的 ‘FOR UPDATE’ 支持</a></li>
<li><a class="reference internal" href="#feature-2867">本机浮点类型的浮点字符串转换精度可进行配置</a></li>
<li><a class="reference internal" href="#change-2824">针对ORM查询的列捆绑包</a></li>
<li><a class="reference internal" href="#id126">服务器端版本计数</a></li>
<li><a class="reference internal" href="#include-backrefs-false-validates"><code class="docutils literal notranslate"><span class="pre">include_backrefs</span> <span class="pre">=</span> <span class="pre">False``选项对于``&#64;validates</span></code></a></li>
<li><a class="reference internal" href="#postgresql-json">PostgreSQL JSON类型</a></li>
<li><a class="reference internal" href="#automap">Automap扩展</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar changelog-migration_09" >
        
<section id="sqlalchemy-0-9">
<h1>SQLAlchemy 0.9 的新特性<a class="headerlink" href="#sqlalchemy-0-9" title="Permalink to this heading">¶</a></h1>
<div class="admonition- admonition">
<p class="admonition-title">关于本文档</p>
<p>本文档描述的是SQLAlchemy 0.8版本已进行维护的变更情况，时间为2013年5月；
与SQLAlchemy 0.9版本（第一次生产发布于2013年12月30日）之间的变更。
文档更新时间: 2015年6月10日</p>
</div>
<section id="id1">
<h2>引言<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>本指南介绍了SQLAlchemy 0.9版的新特性，并记录了影响用户从SQLAlchemy 0.8系列迁移应用程序的变更。</p>
<p>请仔细查阅:ref:<a href="#id2"><span class="problematic" id="id3">`</span></a>behavioral_changes_orm_09`和:ref:<a href="#id4"><span class="problematic" id="id5">`</span></a>behavioral_changes_core_09`以获取可能具有向后不兼容的更改的相关信息。</p>
</section>
<section id="id6">
<h2>平台支持<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<section id="python-2-6-python-3-2to3">
<h3>针对Python 2.6, 支持Python 3 (无需使用2to3).<a class="headerlink" href="#python-2-6-python-3-2to3" title="Permalink to this heading">¶</a></h3>
<p>0.9版本中的第一项成就是消除了与2to3工具相关的Python 3兼容性依赖。为了更加直观，最低Python版本现在为2.6，它具有与Python 3兼容的高度交叉性。
现在所有的SQLAlchemy模块和单元测试都可以在任何Python 2.6及以上的版本中同样良好地解释运行，包括3.1和3.2解释器。</p>
<p><a href="#id7"><span class="problematic" id="id8">:ticket:`2671`</span></a></p>
</section>
<section id="cpython-3">
<h3>C扩展在Python 3中可用<a class="headerlink" href="#cpython-3" title="Permalink to this heading">¶</a></h3>
<p>C扩展已经支持Python3环境下编译和运行。</p>
<p><a href="#id9"><span class="problematic" id="id10">:ticket:`2161`</span></a></p>
</section>
</section>
<section id="orm">
<span id="behavioral-changes-orm-09"></span><h2>行为变更 - ORM<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h2>
<section id="migration-2824">
<span id="id11"></span><h3>复合属性现在在按属性基础上查询时作为它们的对象形式返回<a class="headerlink" href="#migration-2824" title="Permalink to this heading">¶</a></h3>
<p>使用:class:<a href="#id12"><span class="problematic" id="id13">`</span></a>_query.Query`和复合属性时，现在返回的是组成该复合属性的对象类型，而不是拆分为单个列。使用:ref:<a href="#id14"><span class="problematic" id="id15">`</span></a>mapper_composite`中设置的映射：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Vertex</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Vertex</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">[(Point(x=3, y=4), Point(x=5, y=6))]</span></pre></div>
</div>
<p>这个改变在代码期望将单个属性展开为单独的列时与原代码不兼容。要获得此行为，请使用”.clauses”访问器:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Vertex</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">clauses</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Vertex</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">[(3, 4, 5, 6)]</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#change-2824"><span class="std std-ref">针对ORM查询的列捆绑包</span></a></p>
</div>
<p><a href="#id16"><span class="problematic" id="id17">:ticket:`2824`</span></a></p>
</section>
<section id="meth-query-query-select-from">
<span id="migration-2736"></span><h3>:meth:<a href="#id18"><span class="problematic" id="id19">`</span></a>_query.Query.select_from`不再将子句应用于对应的实体<a class="headerlink" href="#meth-query-query-select-from" title="Permalink to this heading">¶</a></h3>
<p>:meth:<a href="#id20"><span class="problematic" id="id21">`</span></a>_query.Query.select_from`方法在最近的版本中已被广泛应用，它是控制:class:<a href="#id22"><span class="problematic" id="id23">`</span></a>_query.Query`对象“从何处选择”的手段，通常用于控制如何呈现JOIN.</p>
<p>考虑下面的例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">User</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">select_stmt</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">select_stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ed&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>预期上面的语句会返回如下SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">id_1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<p>如果我们想要交换JOIN操作中左侧和右侧的元素，我们可以使用:data:<a href="#id24"><span class="problematic" id="id25">`</span></a>_query.Query.select_from`方法来实现:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
    <span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">select_stmt</span><span class="p">)</span>
    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">select_stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;ed&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>但在0.8及以下的版本，上述使用:data:<a href="#id26"><span class="problematic" id="id27">`</span></a>_query.Query.select_from`的示例会将”select_stmt”应用于**替换**“User”实体，因为它从与“User”兼容的“user”表中选择：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="c1">-- SQLAlchemy 0.8及以下版本...</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1_id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">id_1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<p>以上代码很难移植并且故意设定了这种行为。但现在，此行为可以使用一个被称为:meth:<cite>_query.Query.select_entity_from`的新方法来实现。这是一个较少使用的行为，在当前SQLAlchemy中大致等同于从自定义:func:</cite>.aliased`构造中选择：</p>
<blockquote>
<div><p>select_stmt = select([User]).where(User.id == 7)
user_from_stmt = aliased(User, select_stmt.alias())</p>
<p>q = session.query(user_from_stmt).filter(user_from_stmt.name == “ed”)</p>
</div></blockquote>
<p>因此，在SQLAlchemy 0.9中，与“select_stmt”有关的查询将产生我们期望的SQL。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="c1">-- SQLAlchemy 0.9</span>
<span class="k">SELECT</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">id_1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<p>从SQLAlchemy 0.8.2版本开始，:meth:<a href="#id28"><span class="problematic" id="id29">`</span></a>_query.Query.select_entity_from`方法将可用，因此依赖于旧行为的应用程序首先可以过渡到该方法，并确保所有测试继续正常运行，然后升级为0.9，而不会出现问题。</p>
<p><a href="#id30"><span class="problematic" id="id31">:ticket:`2736`</span></a></p>
</section>
<section id="relationship-viewonly-true-history">
<span id="migration-2833"></span><h3>在“relationship ()”上使用”viewonly=True”将阻止 history 生效<a class="headerlink" href="#relationship-viewonly-true-history" title="Permalink to this heading">¶</a></h3>
<p>:func:<a href="#id32"><span class="problematic" id="id33">`</span></a>_orm.relationship`上的”viewonly”标志用于防止对目标属性的更改在Flush过程中产生任何影响。这是通过消除在Flush过程中考虑属性来实现的。在过去，即使对属性进行更改，将仍然将父对象注册为“dirty”并触发潜在的Flush。更改是“viewonly”标志现在也防止为目标属性设置history。像backrefs和用户定义的事件之类的属性事件仍然可以正常运作。</p>
<p>这个改变如下面所示：</p>
<blockquote>
<div><p>from sqlalchemy import Column, Integer, ForeignKey, create_engine
from sqlalchemy.orm import backref, relationship, Session
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import inspect</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”
id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”</p>
<p>id = Column(Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))
a = relationship(“A”, backref=backref(“bs”, viewonly=True))</p>
</dd>
</dl>
<p>e = create_engine(“sqlite://”)
Base.metadata.create_all(e)</p>
<p>a = A()
b = B()</p>
<p>sess = Session(e)
sess.add_all([a, b])
sess.commit()</p>
<p>b.a = a</p>
<p>assert b in sess.dirty</p>
<p># before 0.9.0
# assert a in sess.dirty
# assert inspect(a).attrs.bs.history.has_changes()</p>
<p># after 0.9.0
assert a not in sess.dirty
assert not inspect(a).attrs.bs.history.has_changes()</p>
</div></blockquote>
<p><a href="#id34"><span class="problematic" id="id35">:ticket:`2833`</span></a></p>
</section>
<section id="sql">
<span id="migration-2751"></span><h3>关联代理SQL表达式的改进和修复<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h3>
<p>现在对于从标量关系的标量值到关联代理的“==”和“！=”运算符，会生成更完整的SQL表达式，，将会考虑当与“None”进行比较时，“关联”行是否存在。</p>
<p>考虑以下映射：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)</p>
<p>b_id = Column(Integer, ForeignKey(“b.id”), primary_key=True)
b = relationship(“B”)
b_value = association_proxy(“b”, “value”)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”
id = Column(Integer, primary_key=True)
value = Column(String)</p>
</dd>
</dl>
</div></blockquote>
<p>从以前开始，以下查询：</p>
<blockquote>
<div><p>s.query(A).filter(A.b_value == None).all()</p>
</div></blockquote>
<p>将产生以下SQL：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_b_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NULL</span><span class="p">)</span></pre></div>
</div>
<p>但是现在，在SQLAlchemy 0.9中，它将生成：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_b_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NULL</span><span class="p">))</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NULL</span></pre></div>
</div>
<p>区别是SQLAlchemy 0.9不仅检查“b.value”，还检查当某些父行没有关联行时的情况。因此对于使用此类比较以及一些父行没有关联行的系统，它将产生与早期版本不同的结果。</p>
<p>更为重要的是，“has()”运算符已经得到了增强，现在您可以仅针对一个带有单个条件的标量列值调用它，而不需要其他标准，它将产生检查是否存在关联行的标准：</p>
<blockquote>
<div><p>s.query(A).filter(A.b_value.has()).all()</p>
</div></blockquote>
<p>输出：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_b_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="mi">1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">b_id</span><span class="p">)</span></pre></div>
</div>
<p>这相当于``A.b.has()``，但允许直接查询“b_value”。</p>
<p><a href="#id36"><span class="problematic" id="id37">:ticket:`2751`</span></a></p>
</section>
<section id="none">
<span id="migration-2810"></span><h3>关联代理缺失标量将返回 None<a class="headerlink" href="#none" title="Permalink to this heading">¶</a></h3>
<p>从标量属性到标量的关联代理现在将返回``None``，如果该代理对象不存在。这与缺失的多对一关系返回None相同，应该返回代理值。例如：</p>
<blockquote>
<div><p>from sqlalchemy import *
from sqlalchemy.orm import *
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.associationproxy import association_proxy</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)
b = relationship(“B”, uselist=False)</p>
<p>bname = association_proxy(“b”, “name”)</p>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”</p>
<p>id = Column(Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))
name = Column(String)</p>
</dd>
</dl>
<p>a1 = A()</p>
<p># this is how m2o’s always have worked
assert a1.b is None</p>
<p># but prior to 0.9, this would raise AttributeError,
# now returns None just like the proxied value.
assert a1.bname is None</p>
</div></blockquote>
<p><a href="#id38"><span class="problematic" id="id39">:ticket:`2810`</span></a></p>
</section>
<section id="attributes-get-history-db">
<span id="change-2787"></span><h3>attributes.get_history()现在默认情况下如果值不存在，则查询DB<a class="headerlink" href="#attributes-get-history-db" title="Permalink to this heading">¶</a></h3>
<p>关于:func:<cite>.attributes.get_history`的bugfix允许一个基于列的属性查询未加载的值，假设“passive”标志保持默认值为“PASSIVE_OFF”。以前，这个标志不会被采纳。此外，还添加了一个新方法 :meth:</cite>.AttributeState.load_history`来补充 :attr:<a href="#id40"><span class="problematic" id="id41">`</span></a>.AttributeState.history`属性，它将为未加载的属性发出loader可调用的历史版本。</p>
<p>这是如下代码的变化：</p>
<blockquote>
<div><p>from sqlalchemy import Column, Integer, String, create_engine, inspect
from sqlalchemy.orm import Session, attributes
from sqlalchemy.ext.declarative import declarative_base</p>
<p>Base = declarative_base()</p>
<dl class="simple">
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”
id = Column(Integer, primary_key=True)
data = Column(String)</p>
</dd>
</dl>
<p>e = create_engine(“sqlite://”, echo=True)
Base.metadata.create_all(e)</p>
<p>sess = Session(e)</p>
<p>a1 = A(data=”a1”)
sess.add(a1)
sess.commit()  # a1 is now expired</p>
<p># history doesn’t emit loader callables
assert inspect(a1).attrs.data.history == (None, None, None)</p>
<p># in 0.8, this would fail to load the unloaded state.
assert attributes.get_history(a1, “data”) == (</p>
<blockquote>
<div><p>(),
[</p>
<blockquote>
<div><p>“a1”,</p>
</div></blockquote>
<p>],
(),</p>
</div></blockquote>
<p>)</p>
<p># load_history() is now equivalent to get_history() with
# passive=PASSIVE_OFF ^ INIT_OK
assert inspect(a1).attrs.data.load_history() == (</p>
<blockquote>
<div><p>(),
[</p>
<blockquote>
<div><p>“a1”,</p>
</div></blockquote>
<p>],
(),</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p><a href="#id42"><span class="problematic" id="id43">:ticket:`2787`</span></a></p>
</section>
</section>
<section id="core">
<span id="behavioral-changes-core-09"></span><h2>行为变更 - Core<a class="headerlink" href="#core" title="Permalink to this heading">¶</a></h2>
<section id="id44">
<h3>类型对象不再接受被忽略的关键字参数<a class="headerlink" href="#id44" title="Permalink to this heading">¶</a></h3>
<p>在0.8系列之前，大多数类型对象都接受任意关键字参数，其会被默默地忽略：</p>
<blockquote>
<div><p>from sqlalchemy import Date, Integer</p>
<p># storage_format argument here has no effect on any backend;
# it needs to be on the SQLite-specific type
d = Date(storage_format=”%(day)02d.%(month)02d.%(year)04d”)</p>
<p># display_width argument here has no effect on any backend;
# it needs to be on the MySQL-specific type
i = Integer(display_width=5)</p>
</div></blockquote>
<p>这是一个很老的bug，在0.8系列中添加了一个不受支持的警告，但由于没有人将Python与“-W”标志一起运行，因此大多数情况下并没有出现警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ python -W always::DeprecationWarning ~/dev/sqlalchemy/test.py
/Users/classic/dev/sqlalchemy/test.py:5: SADeprecationWarning: Passing arguments to
type object constructor &lt;class &#39;sqlalchemy.types.Date&#39;&gt; is deprecated
  d = Date(storage_format=&quot;%(day)02d.%(month)02d.%(year)04d&quot;)
/Users/classic/dev/sqlalchemy/test.py:9: SADeprecationWarning: Passing arguments to
type object constructor &lt;class &#39;sqlalchemy.types.Integer&#39;&gt; is deprecated
  i = Integer(display_width=5)</pre></div>
</div>
<p>自0.9系列开始，”catch all”构造函数已从:class:<a href="#id45"><span class="problematic" id="id46">`</span></a>.TypeEngine`移除，因此这些无意义的参数不再被接受。</p>
<p>正确的方法是使用特定于方言的类型，如”storage_format”和”display_width”等方言特定参数应该使用特定于方言的类型。</p>
<blockquote>
<div><p>from sqlalchemy.dialects.sqlite import DATE
from sqlalchemy.dialects.mysql import INTEGER</p>
<p>d = DATE(storage_format=”%(day)02d.%(month)02d.%(year)04d”)</p>
<p>i = INTEGER(display_width=5)</p>
</div></blockquote>
<p>如果想使用不特定于方言的类型呢？我们使用:meth:<a href="#id47"><span class="problematic" id="id48">`</span></a>.TypeEngine.with_variant`方法:</p>
<blockquote>
<div><p>from sqlalchemy import Date, Integer
from sqlalchemy.dialects.sqlite import DATE
from sqlalchemy.dialects.mysql import INTEGER</p>
<dl class="simple">
<dt>d = Date().with_variant(</dt><dd><p>DATE(storage_format=”%(day)02d.%(month)02d.%(year)04d”), “sqlite”</p>
</dd>
</dl>
<p>)</p>
<p>i = Integer().with_variant(INTEGER(display_width=5), “mysql”)</p>
</div></blockquote>
<p>:meth:<a href="#id49"><span class="problematic" id="id50">`</span></a>.TypeEngine.with_variant`不是新功能，它已经在SQLAlchemy0.7.2中添加了。因此，在0.8系列上运行的代码可以更正为使用这种方法，并在升级到0.9之前进行测试。</p>
<p><strong>Original</strong></p>
<p>为了在多元素路径中沿用某种加载样式，必须使用”_all()”方式：</p>
<blockquote>
<div><p>query(User).options(joinedload_all(“orders.items.keywords”))</p>
</div></blockquote>
<p><strong>新方式</strong></p>
<p>现在，加载程序选项可以链式使用，因此可以对每个链接应用相同的”joinedload(x)”方法，而不需要通过点或多个属性名来连接长路径。</p>
<blockquote>
<div><p>query(User).options(joinedload(“orders”).joinedload(“items”).joinedload(“keywords”))</p>
</div></blockquote>
<p><strong>原方式</strong></p>
<p>设置基于子类的路径上的选项需要将路径中的所有链接都拼写为类绑定属性，因为需要调用:meth:<a href="#id51"><span class="problematic" id="id52">`</span></a>.PropComparator.of_type`方法。如下所示：</p>
<p><a href="#id53"><span class="problematic" id="id54">``</span></a>`
session.query(Company).options(</p>
<blockquote>
<div><p>subqueryload_all(Company.employees.of_type(Engineer), Engineer.machines)</p>
</div></blockquote>
<section id="id55">
<h4>)<a class="headerlink" href="#id55" title="Permalink to this heading">¶</a></h4>
<p><strong>新方法</strong></p>
<p>路径中只有确实需要:meth:<a href="#id56"><span class="problematic" id="id57">`</span></a>.PropComparator.of_type`的元素需要设置为类绑定属性，字符串名称可以在之后恢复使用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<dl class="simple">
<dt>session.query(Company).options(</dt><dd><p>subqueryload(Company.employees.of_type(Engineer)).subqueryload(“machines”)</p>
</dd>
</dl>
</section>
<section id="id58">
<h4>)<a class="headerlink" href="#id58" title="Permalink to this heading">¶</a></h4>
<p><strong>旧方法</strong></p>
<p>在长路径中设置最后一个链接上的加载器选项使用了一种语法，看起来很像它应该为路径中的所有链接设置选项，这会引起混乱:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>query(User).options(subqueryload(“orders.items.keywords”))
<a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a></p>
<p><strong>新方法</strong></p>
<p>现在可以使用:func:<a href="#id63"><span class="problematic" id="id64">`</span></a>.defaultload`为路径中的条目拼写路径，其中现有的加载器风格不应更改。更详细，但目的更清晰:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>query(User).options(defaultload(“orders”).defaultload(“items”).subqueryload(“keywords”))
<a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a></p>
<p>仍然可以利用点形式，特别是在跳过几个路径元素的情况下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>query(User).options(defaultload(“orders.items”).subqueryload(“keywords”))
<a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a></p>
<p><strong>旧方法</strong></p>
<p>路径上的:func:<a href="#id73"><span class="problematic" id="id74">`</span></a>.defer`选项需要为每个列的完整路径拼写:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>query(User).options(defer(“orders.description”), defer(“orders.isopen”))
<a href="#id75"><span class="problematic" id="id76">``</span></a><a href="#id77"><span class="problematic" id="id78">`</span></a></p>
<p><strong>新方法</strong></p>
<p>到达目标路径的单个:class:<cite>_orm.Load`对象可以反复调用:meth:`_orm.Load.defer</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>query(User).options(defaultload(“orders”).defer(“description”).defer(“isopen”))
<a href="#id79"><span class="problematic" id="id80">``</span></a><a href="#id81"><span class="problematic" id="id82">`</span></a></p>
<section id="id83">
<h5>加载类<a class="headerlink" href="#id83" title="Permalink to this heading">¶</a></h5>
<p>可以直接使用:class:<a href="#id84"><span class="problematic" id="id85">`</span></a>_orm.Load`类提供“绑定”的目标，尤其是存在多个父实体的情况下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>from sqlalchemy.orm import Load</p>
<p>query(User, Address).options(Load(Address).joinedload(“entries”))
<a href="#id86"><span class="problematic" id="id87">``</span></a><a href="#id88"><span class="problematic" id="id89">`</span></a></p>
</section>
<section id="id90">
<h5>仅加载<a class="headerlink" href="#id90" title="Permalink to this heading">¶</a></h5>
<p>新选项:func:<a href="#id91"><span class="problematic" id="id92">`</span></a>.load.only`实现了“除…外延迟所有”样式的加载，仅加载给定的列，并推迟其余的列:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>from sqlalchemy.orm import load_only</p>
<p>query(User).options(load_only(“name”, “fullname”))</p>
<p># 明确指定父实体
query(User, Address).options(Load(User).load_only(“name”, “fullname”))</p>
<p># 指定路径
query(User).options(joinedload(User.addresses).load_only(“email_address”))
<a href="#id93"><span class="problematic" id="id94">``</span></a><a href="#id95"><span class="problematic" id="id96">`</span></a></p>
</section>
<section id="id97">
<h5>类指定通配符<a class="headerlink" href="#id97" title="Permalink to this heading">¶</a></h5>
<p>使用:class:<cite>_orm.Load</cite>，可以使用通配符为给定实体上的所有关系（或可能是列）设置加载，而不影响其他实体:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p># 惰性加载所有User关系
query(User).options(Load(User).lazyload(“*”))</p>
<p># 未延迟所有User列
query(User).options(Load(User).undefer(“*”))</p>
<p># 惰性加载所有地址关系
query(User).options(defaultload(User.addresses).lazyload(“*”))</p>
<p># 未延迟所有Address列
query(User).options(defaultload(User.addresses).undefer(“*”))
<a href="#id98"><span class="problematic" id="id99">``</span></a><a href="#id100"><span class="problematic" id="id101">`</span></a></p>
<p><a href="#id102"><span class="problematic" id="id103">:ticket:`1418`</span></a></p>
</section>
</section>
</section>
<section id="text">
<span id="feature-2877"></span><h3><a href="#id104"><span class="problematic" id="id105">``</span></a>text()``新功能<a class="headerlink" href="#text" title="Permalink to this heading">¶</a></h3>
<p>:func:<a href="#id106"><span class="problematic" id="id107">`</span></a>_expression.text`构造获得了新的方法:</p>
<ul>
<li><p>:meth:<a href="#id108"><span class="problematic" id="id109">`</span></a>_expression.TextClause.bindparams`允许灵活地设置绑定参数类型和值:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 设置值</span></pre></div>
</div>
<dl class="simple">
<dt>stmt = text(</dt><dd><p>“SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp”</p>
</dd>
</dl>
<p>).bindparams(name=”ed”, timestamp=datetime(2012, 11, 10, 15, 12, 35))</p>
<p># 设置类型和/或值
stmt = (</p>
<blockquote>
<div><p>text(“SELECT id, name FROM user WHERE name=:name AND timestamp=:timestamp”)
.bindparams(bindparam(“name”, value=”ed”), bindparam(“timestamp”, type_=DateTime()))
.bindparam(timestamp=datetime(2012, 11, 10, 15, 12, 35))</p>
</div></blockquote>
<p>)</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">columns`取代了:func:`_expression.text`的``typemap``选项，返回一个新构造`()</span></code>.TextAsFrom``:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 将text()转换为alias()，并附加一个.c集合：</span></pre></div>
</div>
<p>stmt = text(“SELECT id, name FROM user”).columns(id=Integer, name=String)
stmt = stmt.alias()</p>
<dl class="simple">
<dt>stmt = select([addresses]).select_from(</dt><dd><p>addresses.join(stmt), addresses.c.user_id == stmt.c.id</p>
</dd>
</dl>
<p>)</p>
<p># 或转换为cte()：
stmt = text(“SELECT id, name FROM user”).columns(id=Integer, name=String)
stmt = stmt.cte(“x”)</p>
<dl class="simple">
<dt>stmt = select([addresses]).select_from(</dt><dd><p>addresses.join(stmt), addresses.c.user_id == stmt.c.id</p>
</dd>
</dl>
<p>)</p>
</li>
</ul>
<p><a href="#id110"><span class="problematic" id="id111">:ticket:`2877`</span></a></p>
</section>
<section id="select">
<span id="feature-722"></span><h3>从SELECT中插入<a class="headerlink" href="#select" title="Permalink to this heading">¶</a></h3>
<p>经过多年毫无意义的拖延，这个比较小的语法特性现在已经添加，而且也被回退到了0.8.3中，因此在0.9中实际上并不“新”。<code class="xref py py-func docutils literal notranslate"><span class="pre">from_select()</span></code>，其中它将被用于渲染一个“INSERT .. SELECT”构造:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">from</span> <span class="pre">sqlalchemy.sql</span> <span class="pre">import</span> <span class="pre">table,</span> <span class="pre">column</span>
<span class="pre">t1</span> <span class="pre">=</span> <span class="pre">table(&quot;t1&quot;,</span> <span class="pre">column(&quot;a&quot;),</span> <span class="pre">column(&quot;b&quot;))</span>
<span class="pre">t2</span> <span class="pre">=</span> <span class="pre">table(&quot;t2&quot;,</span> <span class="pre">column(&quot;x&quot;),</span> <span class="pre">column(&quot;y&quot;))</span>
<span class="pre">print(t1.insert().from_select([&quot;a&quot;,</span> <span class="pre">&quot;b&quot;],</span> <span class="pre">t2.select().where(t2.c.y</span> <span class="pre">==</span> <span class="pre">5)))</span>
<span class="pre">`</span></code></p>
<p>该构造体已足够智能化，以适应ORM对象，例如类和:class:<a href="#id112"><span class="problematic" id="id113">`</span></a>_query.Query`对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;ed&quot;</span><span class="p">)</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">from_select</span><span class="p">((</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span></pre></div>
</div>
<p>生成:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">INSERT</span> <span class="pre">INTO</span> <span class="pre">addresses</span> <span class="pre">(id,</span> <span class="pre">email_address)</span>
<span class="pre">SELECT</span> <span class="pre">users.id</span> <span class="pre">AS</span> <span class="pre">users_id,</span> <span class="pre">users.name</span> <span class="pre">AS</span> <span class="pre">users_name</span>
<span class="pre">FROM</span> <span class="pre">users</span> <span class="pre">WHERE</span> <span class="pre">users.name</span> <span class="pre">=</span> <span class="pre">:name_1</span>
<span class="pre">`</span></code></p>
<p><a href="#id114"><span class="problematic" id="id115">:ticket:`722`</span></a></p>
</section>
<section id="select-query-for-update">
<span id="feature-github-42"></span><h3>新的对于``select()``, <a href="#id116"><span class="problematic" id="id117">``</span></a>Query()``的 ‘FOR UPDATE’ 支持<a class="headerlink" href="#select-query-for-update" title="Permalink to this heading">¶</a></h3>
<p>在Core和ORM中尝试简化在``SELECT``语句中指定 ‘’FOR UPDATE’’ 子句的规范化，
并增加对于 PostgreSQL 和 Oracle 支持的’’FOR UPDATE OF’’ SQL的支持。</p>
<p>使用核心:meth:<cite>_expression.GenerativeSelect.with_for_update</cite>，可以单独指定
选项，例如``FOR SHARE``和``NOWAIT``，而不是链接到任意字符串代码:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="p">])</span><span class="o">.</span><span class="n">with_for_update</span><span class="p">(</span><span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nowait</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="n">table</span><span class="p">)</span></pre></div>
</div>
<p>对于Posgtresql，上述语句会像这样呈现：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">SELECT</span> <span class="pre">table.a,</span> <span class="pre">table.b</span> <span class="pre">FROM</span> <span class="pre">table</span> <span class="pre">FOR</span> <span class="pre">SHARE</span> <span class="pre">OF</span> <span class="pre">table</span> <span class="pre">NOWAIT</span>
<span class="pre">`</span></code></p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">with_for_update</span></code>，
其行为方式相同。该方法取代了:meth:<cite>_query.Query.with_lockmode`方法，该方法是使用一个与正常的``FOR UPDATE``子句翻译不同的系统翻译``FOR UPDATE``子句的。
目前， ``lockmode``字符串参数仍然被: meth:</cite>.Session.refresh` 方法接受。</p>
</section>
<section id="feature-2867">
<span id="id118"></span><h3>本机浮点类型的浮点字符串转换精度可进行配置<a class="headerlink" href="#feature-2867" title="Permalink to this heading">¶</a></h3>
<p>每当DBAPI返回Python浮点类型需要转换为Python <code class="docutils literal notranslate"><span class="pre">Decimal()</span></code>
时，SQLAlchemy必须做出一个必要的中间步骤，即将浮点值转换为字符串。
此字符串转换的规模以前是硬编码为10，现在可以进行配置。
设置是通过对包含``decimal_return_scale``参数的:class:<cite>.Numeric`和:class:</cite>.Float`类型，所有SQL或方言特定的后代类型使用。如果类型支持``.scale`` 参数（例如:class:<cite>.Numeric`和某些浮点类型，例如:class:</cite>.mysql.DOUBLE`），则``.scale``的值将用作默认值``.decimal_return_scale``。如果同时缺少``.scale``和``.decimal_return_scale``，则会使用默认值10。例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.mysql</span> <span class="kn">import</span> <span class="n">DOUBLE</span> <span class="kn">import</span> <span class="nn">decimal</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;data&quot;</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;double_value&quot;</span><span class="p">,</span> <span class="n">mysql</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">(</span><span class="n">decimal_return_scale</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">asdecimal</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
<span class="p">)</span>

<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span>
    <span class="n">double_value</span><span class="o">=</span><span class="mf">45.768392065789</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">double_value</span><span class="p">]))</span></pre></div>
</div>
<p>先前，这通常会被整理为Decimal（“45.7683920658”），例如截取到10个小数位。现在的结果
在请求的情况下得到12，因为MySQL可以支持这一点水平的精度</p>
<p><a href="#id119"><span class="problematic" id="id120">:ticket:`2867`</span></a></p>
</section>
<section id="change-2824">
<span id="id121"></span><h3>针对ORM查询的列捆绑包<a class="headerlink" href="#change-2824" title="Permalink to this heading">¶</a></h3>
<p>:class:<a href="#id122"><span class="problematic" id="id123">`</span></a>.Bundle`允许查询一组列，然后将这些列组成一个名称，该名称与查询返回的元组中的名称相匹配
列基本用法是1。允许在基于声明的基础上返回“组合”ORM列，而不是将它们展开为单个列和2。允许使用临时
列和返回类型在ORM中创建自定义结果集构造，而无需涉及映射类的更重量级的机制。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#migration-2824"><span class="std std-ref">复合属性现在在按属性基础上查询时作为它们的对象形式返回</span></a></p>
<p><a class="reference internal" href="../orm/queryguide/select.html#bundles"><span class="std std-ref">总结选定的属性（Bundles）</span></a></p>
</div>
<p><a href="#id124"><span class="problematic" id="id125">:ticket:`2824`</span></a></p>
</section>
<section id="id126">
<h3>服务器端版本计数<a class="headerlink" href="#id126" title="Permalink to this heading">¶</a></h3>
<p>ORM的版本控制功能（现在也在:ref:<a href="#id127"><span class="problematic" id="id128">`</span></a>mapper_version_counter`中记录）现在可以利用服务器端版本计数方案，
例如触发器或数据库系统列，以及条件编程方案越过version_id_counter函数本身。通过将值FALSE提供给``version_id_generator``参数，ORM将使用已设置的版本标识符，或者在发出INSERT或UPDATE时立即获取每行的版本标识符。当使用服务器生成的版本标识符时，强烈建议仅在支持强RETURNING支持的后端（PostgreSQL，SQL Server; Oracle还支持返回值，但cx_oracle驱动程序仅具有有限的支持），否则会向额外的SELECT语句添加重大的性能开销。 :ref:<a href="#id129"><span class="problematic" id="id130">`</span></a>server_side_version_counter`中提供的示例说明了如何使用PostgreSQL的xmin系统列将其与ORM的版本控制功能集成。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">server_side_version_counter</span></p>
</div>
<p><a href="#id131"><span class="problematic" id="id132">:ticket:`2793`</span></a></p>
</section>
<section id="include-backrefs-false-validates">
<span id="feature-1535"></span><h3><code class="docutils literal notranslate"><span class="pre">include_backrefs</span> <span class="pre">=</span> <span class="pre">False``选项对于``&#64;validates</span></code><a class="headerlink" href="#include-backrefs-false-validates" title="Permalink to this heading">¶</a></h3>
<p>函数:func:<cite>.validates`现在接受一个选项``include_backrefs = True`</cite>，它将跳过仅从backref发出的验证器的情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="err">```</span></pre></div>
</div>
<p>from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.declarative import declarative_base</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)
bs = relationship(“B”, backref=”a”)</p>
<p>&#64;validates(“bs”)
def validate_bs(self, key, item):</p>
<blockquote>
<div><p>print(“A.bs validator”)
return item</p>
</div></blockquote>
</dd>
<dt>class B(Base):</dt><dd><p>__tablename__ = “b”</p>
<p>id = Column(Integer, primary_key=True)
a_id = Column(Integer, ForeignKey(“a.id”))</p>
<p>&#64;validates(“a”, include_backrefs=False)
def validate_a(self, key, item):</p>
<blockquote>
<div><p>print(“B.a validator”)
return item</p>
</div></blockquote>
</dd>
</dl>
<p>a1 = A()
a1.bs.append(B())  # prints only “A.bs validator”
<a href="#id133"><span class="problematic" id="id134">``</span></a><a href="#id135"><span class="problematic" id="id136">`</span></a></p>
<p><a href="#id137"><span class="problematic" id="id138">:ticket:`1535`</span></a></p>
</section>
<section id="postgresql-json">
<h3>PostgreSQL JSON类型<a class="headerlink" href="#postgresql-json" title="Permalink to this heading">¶</a></h3>
<p>PostgreSQL方言现在具有:class:<a href="#id139"><span class="problematic" id="id140">`</span></a>_postgresql.JSON`类型，以补充:class:<a href="#id141"><span class="problematic" id="id142">`</span></a>_postgresql.HSTORE`类型。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON" title="sqlalchemy.dialects.postgresql.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a></p>
</div>
<p><a href="#id143"><span class="problematic" id="id144">:ticket:`2581`</span></a></p>
</section>
<section id="automap">
<span id="feature-automap"></span><h3>Automap扩展<a class="headerlink" href="#automap" title="Permalink to this heading">¶</a></h3>
<p>在＊＊0.9.1＊＊的新扩展名为＊＊sqlalchemy.ext.automap＊＊。这是一个实验性的扩展，它扩展了声明性以及:class:<cite>.DeferredReflection`类的功能。基本上，该扩展提供了一个基类:class:</cite>.AutomapBase`，它根据给定的表元数据自动生成映射类和之间的关系。</p>
<p>通常，使用的:class:<a href="#id145"><span class="problematic" id="id146">`</span></a>_schema.MetaData`可能是通过反射产生的，但是并不要求使用反射。最基本的用法说明了如何:mod:<a href="#id147"><span class="problematic" id="id148">`</span></a>sqlalchemy.ext.automap`能够基于反射架构生成映射类，包括关系:</p>
<p>from sqlalchemy.ext.automap import automap_base
from sqlalchemy.orm import Session
from sqlalchemy import create_engine</p>
<p>Base = automap_base()</p>
<p># engine, suppose it has two tables ‘user’ and ‘address’ set up
engine = create_engine(“sqlite:///mydatabase.db”)</p>
<p># reflect the tables
Base.prepare(engine, reflect=True)</p>
<p># mapped classes are now created with names matching that of the table
# name.
User = Base.classes.user
Address = Base.classes.address</p>
<p>session = Session(engine)</p>
<p># rudimentary relationships are produced
session.add(Address(email_address=”<a class="reference external" href="mailto:foo&#37;&#52;&#48;bar&#46;com">foo<span>&#64;</span>bar<span>&#46;</span>com</a>”, user=User(name=”foo”)))
session.commit()</p>
<p># collection-based relationships are by default named “&lt;classname&gt;_collection”
print(u1.address_collection)</p>
<p>此外，:class:<a href="#id149"><span class="problematic" id="id150">`</span></a>.AutomapBase`类是一个声明性基类，并支持声明性所支持的所有功能。 “自动映射”功能可以与现有的已明确声明的架构一同使用，以生成关系和丢失的类。可以使用可调用函数放置命名方案和关系-生产例程。</p>
<p>希望:class:<cite>.AutomapBase`系统提供一种快速现代化的解决方案，即在现有数据库中自动生成一个简单且未加权重的对象模型。通过严格在映射器配置级别上处理问题，并与现有的Declarative类技术完全集成，:class:</cite>.AutomapBase`寻求为快速自动生成临时映射提供完全集成的方法。.</p>
<p>0.9版中，“eager_defaults”现在可以使用VERSIONING扩展来为这些值发出RETURNING语句，因此在后端有强大的RETURNING支持，特别是PostgreSQL的情况下，ORM可以与INSERT或UPDATE一起内联获取新生成的默认值和SQL表达式值。当target backend和“_schema.Table” 支持“implicit returning”时，“eager_defaults”在启用时会自动使用RETURNING。</p>
<p>子查询贪婪加载将为某些查询将DISTINCT应用于最内层SELECT中</p>
<p>为了减少子查询贪婪加载包含多对一关系时可能生成的重复行数，当连接的目标列不包含主键时（在加载多对一的情况下），将会在内部SELECT中应用DISTINCT关键字</p>
<p>也就是说，在从A到B的多对一上进行子查询加载时：</p>
<p>SELECT b.id AS b_id, b.name AS b_name, anon_1.b_id AS a_b_id FROM (SELECT DISTINCT a_b_id FROM a) AS anon_1 JOIN b ON b.id = anon_1.a_b_id</p>
<p>由于“a.b_id”是一个非唯一的外键，所以将使用DISTINCT关键字，使得冗余的“a.b_id”被消除。可以使用标记“distinct_target_key”无条件地打开或关闭特定的:func:<cite>_orm.relationship</cite>：</p>
<p>将该值设置为True表示无条件打开它，将该值设置为False表示无条件关闭它，将该值设置为None表示当目标SELECT针对不包括完整主键的列时特性发挥作用。在0.9中，“None”是默认值。该选项还在0.8中回退，“distinct_target_key”选项默认为“False”。</p>
<p>尽管此功能旨在通过消除重复行来帮助提高性能，但SQL中的“DISTINCT”关键字本身可能会产生负面影响。</p>
<p>当渴望默认时：“eager_defaults”可以将新创建的、默认和SQL表达式值与INSERT或UPDATE一起获取。现在，类型处理器可以呈现“文本绑定”值。更新了始发对象与 :class: 的事件传递机制。一个细小但广泛的更改是：列可以从ForeignKey中获取它们的类型。修改了 :class: <cite>.RowProxy</cite> 的行为，现在它有元素排序。Firebird“fdb”现在是默认的Firebird方言，“fdb”和“kinterbasdb”现在默认情况下将“retaining”设置为“False”。对于这些Flag，现在已经添加到create_engine方法中。</p>
<p>本次升级是为了解决开发旧版本的SQLAlchemy时出现的问题，以便更好地提升其性能。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="migration_10.html" title="previous chapter">SQLAlchemy 1.0有哪些新特性？</a>
        Next:
        <a href="migration_08.html" title="next chapter">SQLAlchemy 0.8有哪些新特性？</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:47:08

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


