<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    SQLAlchemy 0.8有哪些新特性？
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="变更和迁移" href="index.html" />
        <link rel="next" title="SQLAlchemy 0.7有什么新特性？" href="migration_07.html" />
        <link rel="prev" title="SQLAlchemy 0.9 的新特性" href="migration_09.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="变更和迁移">变更和迁移</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="migration_20.html">SQLAlchemy 2.0 - 主要迁移指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="whatsnew_20.html">SQLAlchemy 2.0 有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_20.html">2.0 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_14.html">1.4 版本更新历史</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9版本更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">版本记录</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_14.html">SQLAlchemy 1.4有哪些新内容？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">SQLAlchemy 1.3有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">SQLAlchemy 1.2有哪些新特性?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_11.html">SQLAlchemy 1.1新功能</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_10.html">SQLAlchemy 1.0有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_09.html">SQLAlchemy 0.9 的新特性</a></span></li>
<li class="selected"><span class="link-container"><strong>SQLAlchemy 0.8有哪些新特性？</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">介绍</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id2">平台支持</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#python-2-5">针对Python 2.5及以上版本</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm">新的ORM功能</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#orm-relationship">重写的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 机制</a></span></li>
<li><span class="link-container"><a class="reference external" href="#feature-orminspection-08">新的类/对象检查系统</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id10">可以将ORM类别用于核心构造</a></span></li>
<li><span class="link-container"><a class="reference external" href="#query-update-update-from">Query.update() 支持 UPDATE..FROM</a></span></li>
<li><span class="link-container"><a class="reference external" href="#rollback-begin-nested-dirty">rollback() 仅回滚begin_nested（）中的“dirty”对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="#dogpile-cache">缓存示例现在使用dogpile.cache</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#core">新的CORE功能</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id24">Core中完全可扩展的类型级运算符支持</a></span></li>
<li><span class="link-container"><a class="reference external" href="#insertvalues">支持Insert的多重VALUES</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id29">类型表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id32">Core检查系统</a></span></li>
<li><span class="link-container"><a class="reference external" href="#expression-select-correlate-except">新的方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#postgresql-hstore">PostgreSQL HSTORE 类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#postgresql-array">增强的 PostgreSQL ARRAY 类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlite-datetime">适用于 SQLite 的新可配置 DATE、TIME 类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="#collate-mysqlpostgresql-sqlite">在所有方言上支持“COLLATE”；特别是在 MySQL、PostgreSQL 和 SQLite 中</a></span></li>
<li><span class="link-container"><a class="reference external" href="#expression-update-expression-delete">为 <code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code> 启用“前缀”</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id43">行为变化</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id44">将“挂起”对象视为“孤立”对象的考虑更加积极</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-after-attach-before-attach">在对象关联到 Session 后发生 after_attach 事件，而不是在之前；添加 before_attach</a></span></li>
<li><span class="link-container"><a class="reference external" href="#select">查询现在会像 select() 一样自动关联</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id51">关联始终是上下文特定的</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-session-is-modified"><code class="xref py py-func docutils literal notranslate"><span class="pre">Session.is_modified()</span></code> 的行为已修复</a></span></li>
<li><span class="link-container"><a class="reference external" href="#schema-column-key-expression-select-apply-labels-expression-select-c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code> 在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.apply_labels()</span></code> 中使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Select.c</span></code> 属性时得到了尊重</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id60">单个父级警告现在为错误</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id63">为“列反映”添加“审核器”参数</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mysql">禁用 MySQL 的自动检测排序方式，大小写方式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id68">“未使用的列名称”警告现在变成异常</a></span></li>
<li><span class="link-container"><a class="reference external" href="#inspector-get-primary-keys-inspector-get-pk-constraint">Inspector.get_primary_keys() 被弃用，请使用 Inspector.get_pk_constraint</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id73">在大多数情况下，将不再启用大小写不敏感的结果行名称</a></span></li>
<li><span class="link-container"><a class="reference external" href="#instrumentationmanager">``InstrumentationManager``和替代类中间件是一个扩展</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id76">删除</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqlsoup">SQLSoup</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mutabletype">MutableType</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sqlalchemy-exceptions-sqlalchemy-exc">sqlalchemy.exceptions（数年来已是sqlalchemy.exc）</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">SQLAlchemy 0.7有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">SQLAlchemy 0.6 有哪些新变化?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">SQLAlchemy 0.5有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id1">主要文档更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id6">退化源</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id7">需求更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id8">ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id21">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id22">模式/类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id23">连接池不再默认为线程本地</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#args-args">*args已接受，不再接受*args</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id44">删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id77">已重命名或已移动</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id86">已弃用</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">SQLAlchemy 0.4有什么新功能？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id1">首先要做什么</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id2">模块导入</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id3">对象关系映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id22">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id26">架构和反射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id28">SQL执行</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="migration_09.html" title="previous chapter">SQLAlchemy 0.9 的新特性</a></li>
                <li><b>Next:</b>
                <a href="migration_07.html" title="next chapter">SQLAlchemy 0.7有什么新特性？</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="变更和迁移">变更和迁移</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#sqlalchemy-0-8">SQLAlchemy 0.8有哪些新特性？</a><ul>
<li><a class="reference internal" href="#id1">介绍</a></li>
<li><a class="reference internal" href="#id2">平台支持</a><ul>
<li><a class="reference internal" href="#python-2-5">针对Python 2.5及以上版本</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm">新的ORM功能</a><ul>
<li><a class="reference internal" href="#orm-relationship">重写的 <code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.relationship()</span></code> 机制</a></li>
<li><a class="reference internal" href="#feature-orminspection-08">新的类/对象检查系统</a></li>
<li><a class="reference internal" href="#id10">可以将ORM类别用于核心构造</a></li>
<li><a class="reference internal" href="#query-update-update-from">Query.update() 支持 UPDATE..FROM</a></li>
<li><a class="reference internal" href="#rollback-begin-nested-dirty">rollback() 仅回滚begin_nested（）中的“dirty”对象</a></li>
<li><a class="reference internal" href="#dogpile-cache">缓存示例现在使用dogpile.cache</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core">新的CORE功能</a><ul>
<li><a class="reference internal" href="#id24">Core中完全可扩展的类型级运算符支持</a></li>
<li><a class="reference internal" href="#insertvalues">支持Insert的多重VALUES</a></li>
<li><a class="reference internal" href="#id29">类型表达式</a></li>
<li><a class="reference internal" href="#id32">Core检查系统</a></li>
<li><a class="reference internal" href="#expression-select-correlate-except">新的方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_expression.Select.correlate_except()</span></code></a></li>
<li><a class="reference internal" href="#postgresql-hstore">PostgreSQL HSTORE 类型</a></li>
<li><a class="reference internal" href="#postgresql-array">增强的 PostgreSQL ARRAY 类型</a></li>
<li><a class="reference internal" href="#sqlite-datetime">适用于 SQLite 的新可配置 DATE、TIME 类型</a></li>
<li><a class="reference internal" href="#collate-mysqlpostgresql-sqlite">在所有方言上支持“COLLATE”；特别是在 MySQL、PostgreSQL 和 SQLite 中</a></li>
<li><a class="reference internal" href="#expression-update-expression-delete">为 <code class="xref py py-func docutils literal notranslate"><span class="pre">_expression.update()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">_expression.delete()</span></code> 启用“前缀”</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id43">行为变化</a><ul>
<li><a class="reference internal" href="#id44">将“挂起”对象视为“孤立”对象的考虑更加积极</a></li>
<li><a class="reference internal" href="#session-after-attach-before-attach">在对象关联到 Session 后发生 after_attach 事件，而不是在之前；添加 before_attach</a></li>
<li><a class="reference internal" href="#select">查询现在会像 select() 一样自动关联</a></li>
<li><a class="reference internal" href="#id51">关联始终是上下文特定的</a></li>
<li><a class="reference internal" href="#orm-session-is-modified"><code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.Session.is_modified()</span></code> 的行为已修复</a></li>
<li><a class="reference internal" href="#schema-column-key-expression-select-apply-labels-expression-select-c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_schema.Column.key</span></code> 在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_expression.Select.apply_labels()</span></code> 中使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">_expression.Select.c</span></code> 属性时得到了尊重</a></li>
<li><a class="reference internal" href="#id60">单个父级警告现在为错误</a></li>
<li><a class="reference internal" href="#id63">为“列反映”添加“审核器”参数</a></li>
<li><a class="reference internal" href="#mysql">禁用 MySQL 的自动检测排序方式，大小写方式</a></li>
<li><a class="reference internal" href="#id68">“未使用的列名称”警告现在变成异常</a></li>
<li><a class="reference internal" href="#inspector-get-primary-keys-inspector-get-pk-constraint">Inspector.get_primary_keys() 被弃用，请使用 Inspector.get_pk_constraint</a></li>
<li><a class="reference internal" href="#id73">在大多数情况下，将不再启用大小写不敏感的结果行名称</a></li>
<li><a class="reference internal" href="#instrumentationmanager">``InstrumentationManager``和替代类中间件是一个扩展</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id76">删除</a><ul>
<li><a class="reference internal" href="#sqlsoup">SQLSoup</a></li>
<li><a class="reference internal" href="#mutabletype">MutableType</a></li>
<li><a class="reference internal" href="#sqlalchemy-exceptions-sqlalchemy-exc">sqlalchemy.exceptions（数年来已是sqlalchemy.exc）</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar changelog-migration_08" >
        
<section id="sqlalchemy-0-8">
<h1>SQLAlchemy 0.8有哪些新特性？<a class="headerlink" href="#sqlalchemy-0-8" title="Permalink to this heading">¶</a></h1>
<div class="admonition- admonition">
<p class="admonition-title">关于本文档</p>
<p>本文档介绍了SQLAlchemy 0.7版本更新至2012年10月起的其他维护版本和即将于2013年初发布的SQLAlchemy 0.8版本之间的差异及其影响应用迁移。</p>
<p>文档日期：2012年10月25日
更新日期：2013年3月9日</p>
</div>
<section id="id1">
<h2>介绍<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>本指南介绍了SQLAlchemy 0.8版本的新功能，并记录了影响将应用程序从SQLAlchemy 0.7系列迁移到0.8的用户的更改。</p>
<p>SQLAlchemy版本正在逼近1.0版本，自从0.5版本以来，每个新版本都具有更少的重要使用更改。大多数采用现代0.7模式的应用程序应该能够移动到0.8版本，无需更改。使用0.6甚至0.5模式的应用程序也应该直接可以迁移到0.8版本，虽然较大的应用程序可能需要测试每个中间版本。</p>
</section>
<section id="id2">
<h2>平台支持<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<section id="python-2-5">
<h3>针对Python 2.5及以上版本<a class="headerlink" href="#python-2-5" title="Permalink to this heading">¶</a></h3>
<p>SQLAlchemy 0.8将针对Python 2.5及以上版本进行开发，将取消针对Python 2.4的兼容性支持。</p>
<p>内部将能够使用Python三元运算法（即“x if y else z”），这样可以改善与使用“y and x or z”引起的错误，同时支持上下文管理器（即“with:”），在某些情况下还可以支持try:/except:/else:块，这将有助于代码的可读性。</p>
<p>SQLAlchemy最终将取消对2.5版本的支持-当2.6版本成为基线时，SQLAlchemy将转移到使用2.6 / 3.3本地兼容性，并删除“2to3”工具的使用，并维护源代码，在Python 2和3同时运行。</p>
</section>
</section>
<section id="orm">
<h2>新的ORM功能<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h2>
<section id="orm-relationship">
<span id="feature-relationship-08"></span><h3>重写的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 机制<a class="headerlink" href="#orm-relationship" title="Permalink to this heading">¶</a></h3>
<p>0.8版具有更强大和更可行的系统，用于确定 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 在两个实体之间如何连接。新系统包括以下功能：</p>
<ul>
<li><p>当使用多个外键路径连接到目标时，在构建 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 时，不再需要 <code class="docutils literal notranslate"><span class="pre">primaryjoin</span></code> 参数。仅需要 <code class="docutils literal notranslate"><span class="pre">foreign_keys</span></code> 参数来指定应包括哪些列：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">child_id_one</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;child.id&quot;</span><span class="p">))</span>
    <span class="n">child_id_two</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;child.id&quot;</span><span class="p">))</span>

    <span class="n">child_one</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="n">child_id_one</span><span class="p">)</span>
    <span class="n">child_two</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="n">child_id_two</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;child&quot;</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
</li>
<li><p>现在支持自引用，复合外部键的关系，其中**一列指向本身**。典型案例如下所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Folder</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;folder&quot;</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ForeignKeyConstraint</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;account_id&quot;</span><span class="p">,</span> <span class="s2">&quot;parent_id&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;folder.account_id&quot;</span><span class="p">,</span> <span class="s2">&quot;folder.folder_id&quot;</span><span class="p">]</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">account_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">folder_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

    <span class="n">parent_folder</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Folder&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;child_folders&quot;</span><span class="p">,</span> <span class="n">remote_side</span><span class="o">=</span><span class="p">[</span><span class="n">account_id</span><span class="p">,</span> <span class="n">folder_id</span><span class="p">]</span>
    <span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面的 <code class="docutils literal notranslate"><span class="pre">Folder</span></code> 引用了其父级 <code class="docutils literal notranslate"><span class="pre">Folder</span></code>，从 <code class="docutils literal notranslate"><span class="pre">account_id</span></code> 到自己，以及从 <code class="docutils literal notranslate"><span class="pre">parent_id</span></code> 到 <code class="docutils literal notranslate"><span class="pre">folder_id</span></code> 进行连接。当SQLAlchemy构造“自动连接”时，不能再假定“远程”端上的所有列都已被别名化，并且所有“本地”端的列都没有别名- <code class="docutils literal notranslate"><span class="pre">account_id</span></code> 列存在于两侧。因此，内部关系机制完全地重写以支持一个完全不同的系统，其中两个包含不同*注释*的 <code class="docutils literal notranslate"><span class="pre">account_id</span></code> 副本被生成，每个副本包含不同的内容以确定在语句中的角色。有关基本急切加载中的连接条件：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
<span class="w">    </span><span class="n">folder</span><span class="p">.</span><span class="n">account_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_account_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder</span><span class="p">.</span><span class="n">folder_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_folder_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder</span><span class="p">.</span><span class="n">parent_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_parent_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_name</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder_1</span><span class="p">.</span><span class="n">account_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_1_account_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder_1</span><span class="p">.</span><span class="n">folder_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_1_folder_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder_1</span><span class="p">.</span><span class="n">parent_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_1_parent_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">folder_1</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_1_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">folder</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">folder</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">folder_1</span>
<span class="w">    </span><span class="k">ON</span><span class="w"> </span><span class="n">folder_1</span><span class="p">.</span><span class="n">account_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">folder</span><span class="p">.</span><span class="n">account_id</span>
<span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="n">folder</span><span class="p">.</span><span class="n">folder_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">folder_1</span><span class="p">.</span><span class="n">parent_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">folder</span><span class="p">.</span><span class="n">folder_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">folder</span><span class="p">.</span><span class="n">account_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span></pre></div>
</div>
</li>
<li><p>以前很难实现的自定义连接条件，例如涉及函数和/或类型转换的条件，现在在大多数情况下可正常使用：</p>
<blockquote>
<div><dl>
<dt>class HostEntry(Base):</dt><dd><p>__tablename__ = “host_entry”</p>
<p>id = Column(Integer, primary_key=True)
ip_address = Column(INET)
content = Column(String(50))</p>
<p># relationship() 使用显式外键和 remote_side
parent_host = relationship(</p>
<blockquote>
<div><p>“HostEntry”,
primaryjoin=ip_address == cast(content, INET),
foreign_keys=content,
remote_side=ip_address,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 机制使用 SQLAlchemy 概念称为 <span class="xref std std-term">注释（annotations）</span> 。这些注释也可通过 <code class="xref py py-func docutils literal notranslate"><span class="pre">foreign()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">remote()</span></code> 函数明确提供给应用程序代码，作为提高高级配置的可读性或直接注入精确配置的手段，从而绕过通常的连接检查启发式算法：</p>
<blockquote>
<div><p>from sqlalchemy.orm import foreign, remote</p>
<dl>
<dt>class HostEntry(Base):</dt><dd><p>__tablename__ = “host_entry”</p>
<p>id = Column(Integer, primary_key=True)
ip_address = Column(INET)
content = Column(String(50))</p>
<p># relationship() 使用显式 foreign() 和 remote() 注释
# 而不是分开的参数
parent_host = relationship(</p>
<blockquote>
<div><p>“HostEntry”,
primaryjoin=remote(ip_address) == cast(foreign(content), INET),</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
</li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">:ticket:`1401`</span></a> <a href="#id5"><span class="problematic" id="id6">:ticket:`610`</span></a></p>
</section>
<section id="feature-orminspection-08">
<span id="id7"></span><h3>新的类/对象检查系统<a class="headerlink" href="#feature-orminspection-08" title="Permalink to this heading">¶</a></h3>
<p>许多SQLAlchemy用户正在编写需要检查映射类的属性的系统，包括能够获取主键列、对象关系、普通属性等等，通常用于构建数据封送系统，如JSON/XML转换方案和当然还有表单库等等。</p>
<p>最初， <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 和 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 模型是原始检查点，具有良好记录的系统。虽然ORM模型也是完全可检查的，但这从来不是完全稳定和受支持的特性，用户倾向于不知道如何获取此信息。</p>
<p>0.8现在为此提供了一致，稳定且完全记录的API，包括一组可用于映射类别，实例，属性和其他核心和ORM结构的检查系统。这个系统的入口点是核心级 <a class="reference internal" href="../core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> 函数。在大多数情况下，正在检查的对象是SQLAlchemy系统的一部分，例如 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapper</span></code>，<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.InstanceState" title="sqlalchemy.orm.InstanceState"><code class="xref py py-class docutils literal notranslate"><span class="pre">InstanceState</span></code></a>，<a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a>。在某些情况下，已添加具有提供检查API的作业的新对象，在特定上下文中，例如 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp" title="sqlalchemy.orm.util.AliasedInsp"><code class="xref py py-class docutils literal notranslate"><span class="pre">AliasedInsp</span></code></a> 和 <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.AttributeState" title="sqlalchemy.orm.AttributeState"><code class="xref py py-class docutils literal notranslate"><span class="pre">AttributeState</span></code></a>。</p>
<p>以下是一些关键功能的说明：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;user&quot;</span>
<span class="go">...     id = Column(Integer, primary_key=True)</span>
<span class="go">...     name = Column(String)</span>
<span class="go">...     name_syn = synonym(name)</span>
<span class="go">...     addresses = relationship(&quot;Address&quot;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 通用入口点是inspect()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># b在这种情况下是Mapper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;Mapper at 0x101521950; User&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Column namespace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">id</span>
<span class="go">Column(&#39;id&#39;, Integer(), table=&lt;user&gt;, primary_key=True, nullable=False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Mapper从.attrs中获取的属性</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;name_syn&#39;, &#39;addresses&#39;, &#39;id&#39;, &#39;name&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># .column_attrs，.relationships等过滤此集合</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">column_attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;id&#39;, &#39;name&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">list</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">relationships</span><span class="p">)</span>
<span class="go">[&lt;sqlalchemy.orm.properties.RelationshipProperty object at 0x1015212d0&gt;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 他们也是命名空间</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">column_attrs</span><span class="o">.</span><span class="n">id</span>
<span class="go">&lt;sqlalchemy.orm.properties.ColumnProperty object at 0x101525090&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">relationships</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">&lt;sqlalchemy.orm.properties.RelationshipProperty object at 0x1015212d0&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 将inspect()指向映射后的类级属性，返回属性本身</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x101521fd0&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 从这里可以获取mapper：</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">mapper</span>
<span class="go">&lt;Mapper at 0x101525810; Address&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 父检查器，在这种情况下是mapper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">parent</span>
<span class="go">&lt;Mapper at 0x101521950; User&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 表达式</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">expression</span><span class="p">)</span>
<div class='show_sql_print'><span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="c1"># inspect()适用于实例</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 它返回InstanceState</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;sqlalchemy.orm.state.InstanceState object at 0x10152bed0&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 类似的 attrs，指的是状态对象</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;id&#39;, &#39;name_syn&#39;, &#39;addresses&#39;, &#39;name&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 属性接口-从 attrs 中，您可以获得一个状态对象</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">id</span>
<span class="go">&lt;sqlalchemy.orm.state.AttributeState object at 0x10152bf90&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 此对象可以提供当前值...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">value</span>
<span class="go">3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ...目前的历史</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=[3], unchanged=(), deleted=())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># InstanceState 还可以提供会话状态信息</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 假设对象是持久的</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 现在我们可以始终获取主键身份</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 总是在 query.get() 中运行</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">identity</span>
<span class="go">(3,)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 映射器层面的密钥</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">identity_key</span>
<span class="go">(&lt;class &#39;__main__.User&#39;&gt;, (3,))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 会话中的状态</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">persistent</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">transient</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">deleted</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">detached</span>
<span class="go">(True, False, False, False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 拥有的会话</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">session</span>
<span class="go">&lt;sqlalchemy.orm.session.Session object at 0x101701150&gt;</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p><a href="#id8"><span class="problematic" id="id9">:ticket:`2208`</span></a></p>
</section>
<section id="id10">
<h3>可以将ORM类别用于核心构造<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>虽然 <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.filter" title="sqlalchemy.orm.Query.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.filter()</span></code></a> 中使用的SQL表达式，如 <code class="docutils literal notranslate"><span class="pre">User.id</span> <span class="pre">==</span> <span class="pre">5</span></code>，对于 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 等核心构造始终是兼容的，但映射的类本身在传递给 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate()</span></code></a> 时将无法识别。现在，新的SQL注册系统允许将映射类作为CORE中的FROM子句：</p>
<blockquote>
<div><p>from sqlalchemy import select</p>
<p>stmt = select([User]).where(User.id == 5)</p>
</div></blockquote>
<p>在上面的示例中，映射的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类将会被扩展为与其映射的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>。</p>
<p><a href="#id11"><span class="problematic" id="id12">:ticket:`2245`</span></a></p>
</section>
<section id="query-update-update-from">
<span id="change-orm-2365"></span><h3>Query.update() 支持 UPDATE..FROM<a class="headerlink" href="#query-update-update-from" title="Permalink to this heading">¶</a></h3>
<p>现在支持在 query.update() 中在更新 <code class="docutils literal notranslate"><span class="pre">SomeEntity</span></code> 时添加 FROM 子句（或等效的方式依赖于后端）添加至 <code class="docutils literal notranslate"><span class="pre">SomeOtherEntity</span></code>：</p>
<blockquote>
<div><dl class="simple">
<dt>query(SomeEntity).filter(SomeEntity.id == SomeOtherEntity.id).filter(</dt><dd><p>SomeOtherEntity.foo == “bar”</p>
</dd>
</dl>
<p>).update({“data”: “x”})</p>
</div></blockquote>
<p>特别地，如果更新的目标本地于在筛选的表上，或者如果父级和子级表是混合的，它们在查询中显式地连接，则形成联接继承实体的更新将受到支持。在下面的示例中，假设 <code class="docutils literal notranslate"><span class="pre">Engineer</span></code> 作为 <a href="#id13"><span class="problematic" id="id14">`</span></a>Person <a href="#id15"><span class="problematic" id="id16">``</span></a>的连续子类：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Engineer</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">Person</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;dilbert&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;engineer_data&quot;</span><span class="p">:</span> <span class="s2">&quot;java&quot;</span><span class="p">})</span></pre></div>
</div>
<p>将会产生：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">UPDATE</span><span class="w"> </span><span class="n">engineer</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">engineer_data</span><span class="o">=</span><span class="s1">&#39;java&#39;</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">person</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">person</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">engineer</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;dilbert&#39;</span></pre></div>
</div>
<p><a href="#id17"><span class="problematic" id="id18">:ticket:`2365`</span></a></p>
</section>
<section id="rollback-begin-nested-dirty">
<h3>rollback() 仅回滚begin_nested（）中的“dirty”对象<a class="headerlink" href="#rollback-begin-nested-dirty" title="Permalink to this heading">¶</a></h3>
<p>针对使用 <code class="docutils literal notranslate"><span class="pre">Session.begin_nested()</span></code> 的SAVEPOINT的用户，将在 <code class="docutils literal notranslate"><span class="pre">rollback()</span></code> 时仅过期那些自上次刷新后变脏的对象，而会话的其余部分仍然完好无损。这是因为ROLLBACK到SAVEPOINT并不会终止包含事务的隔离，因此除了那些没有在当前事务中刷新的更改之外，不需要过期。这将提高工作效率。</p>
<p><a href="#id19"><span class="problematic" id="id20">:ticket:`2452`</span></a></p>
</section>
<section id="dogpile-cache">
<h3>缓存示例现在使用dogpile.cache<a class="headerlink" href="#dogpile-cache" title="Permalink to this heading">¶</a></h3>
<p>缓存示例现在使用 <a class="reference external" href="https://dogpilecache.readthedocs.io/">dogpile.cache</a>。Dogpile.cache是Beaker缓存部分的重写，具有更简单，更快的操作以及分布式锁定支持。</p>
<p>请注意，Dogpile示例以及之前的Beaker示例所使用的SQLAlchemy API已略有改变，特别是在Beaker示例中需要进行以下更改：</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span><span class="gd">--- examples/beaker_caching/caching_query.py</span>
<span class="gi">+++ examples/beaker_caching/caching_query.py</span>
<span class="gu">@@ -222,7 +222,8 @@</span>

<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        if query._current_path:
<span class="gd">-            mapper, key = query._current_path[-2:]</span>
<span class="gi">+            mapper, prop = query._current_path[-2:]</span>
<span class="gi">+            key = prop.key</span>

<span class="w"> </span>            for cls in mapper.class_.__mro__:
<span class="w"> </span>                if (cls, key) in self._relationship_options:</pre></div>
</div>
<p><a href="#id22"><span class="problematic" id="id23">:ticket:`2589`</span></a></p>
</section>
</section>
<section id="core">
<h2>新的CORE功能<a class="headerlink" href="#core" title="Permalink to this heading">¶</a></h2>
<section id="id24">
<h3>Core中完全可扩展的类型级运算符支持<a class="headerlink" href="#id24" title="Permalink to this heading">¶</a></h3>
<p>到目前为止，Core从未具有为Column和其他表达式结构添加支持新SQL运算符的任何系统，除了 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op" title="sqlalchemy.sql.expression.ColumnOperators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.op()</span></code></a> 方法“只是足够”可以使其正常工作。在Core中还从未有过任何可以允许覆盖现有运算符行为的系统。迄今为止，唯一可以灵活地重新定义运算符的方式是使用ORM层，使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">column_property()</span></code> 并给定 <code class="docutils literal notranslate"><span class="pre">comparator_factory</span></code> 参数。因此，第三方库如GeoAlchemy被强制为ORM-centric，并依赖于一系列hack来应用新操作，以及使它们正确传播。</p>
<p>Core中的新运算符系统添加了一直缺失的一个钩子，即将新的和覆盖的运算符与*类型*关联起来。毕竟，实际上*不是*一个列，CAST运算符或SQL函数真正驱动可用的操作类型的种类。实现细节很少-只添加了一些额外的方法到核心 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> 类型，以便在核心中的 <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 对象中查看可选运算符集。新的或修订的操作可以与任何类型关联，无论是通过现有类型的子类化，使用 <a class="reference internal" href="../core/custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>，或通过将新的 <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator" title="sqlalchemy.types.TypeEngine.Comparator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Comparator</span></code></a> 对象附加到现有类型类“全局跨越。”</p>
<p>例如，要将logarithm支持添加到 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a> 类型：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="kn">import</span> <span class="n">Numeric</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">func</span>


<span class="k">class</span> <span class="nc">CustomNumeric</span><span class="p">(</span><span class="n">Numeric</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">comparator_factory</span><span class="p">(</span><span class="n">Numeric</span><span class="o">.</span><span class="n">Comparator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>可以像任何其他类型一样使用新类型：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;data&quot;</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">CustomNumeric</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">CustomNumeric</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span>
<span class="p">)</span>

<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span></pre></div>
</div>
<p>新功能立即提供的新特性包括对PostgreSQL’s HSTORE类型的支持，以及与PostgreSQL’s ARRAY类型相关的新操作。它还为现有类型铺平了道路，使其获得更多针对那些类型特定的更多的运算符，例如更多字符串，整数和日期运算符。</p>
<p><a href="#id25"><span class="problematic" id="id26">:ticket:`2547`</span></a></p>
</section>
<section id="insertvalues">
<span id="feature-2623"></span><h3>支持Insert的多重VALUES<a class="headerlink" href="#insertvalues" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.values" title="sqlalchemy.sql.expression.Insert.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.values()</span></code></a> 方法现在支持字典列表，这将呈现出multi-VALUES语句，例如 <code class="docutils literal notranslate"><span class="pre">VALUES</span> <span class="pre">(&lt;row1&gt;),</span> <span class="pre">(&lt;row2&gt;),</span> <span class="pre">...</span></code>。这仅涉及支持这种语法的后端，包括PostgreSQL，SQLite和MySQL。它与通常的 <code class="docutils literal notranslate"><span class="pre">executemany()</span></code> 样式的INSERT不同，它保持不变：</p>
<blockquote>
<div><dl>
<dt>users.insert().values(</dt><dd><dl class="simple">
<dt>[</dt><dd><p>{“name”: “some name”},
{“name”: “some other name”},
{“name”: “yet another name”},</p>
</dd>
</dl>
<p>]</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p><a href="#id27"><span class="problematic" id="id28">:ticket:`2623`</span></a></p>
</section>
<section id="id29">
<h3>类型表达式<a class="headerlink" href="#id29" title="Permalink to this heading">¶</a></h3>
<p>现在可以将SQL表达式与类型相对应。 历史上， <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 总是允许Python侧函数，其接收绑定参数以及结果行值，并在通过Python侧转换函数时将其传递到/从数据库。新功能允许在数据库方面进行类似功能，但是它要将SQL表达式与类型相关联：</p>
<blockquote>
<div><p>from sqlalchemy.types import String
from sqlalchemy import func, Table, Column, MetaData</p>
<dl class="simple">
<dt>class LowerString(String):</dt><dd><dl class="simple">
<dt>def bind_expression(self, bindvalue):</dt><dd><p>return func.lower(bindvalue)</p>
</dd>
<dt>def column_expression(self, col):</dt><dd><p>return func.lower(col)</p>
</dd>
</dl>
</dd>
</dl>
<p>metadata = MetaData()
test_table = Table(“test_table”, metadata, Column(“data”, LowerString))</p>
</div></blockquote>
<p>上述 <code class="docutils literal notranslate"><span class="pre">LowerString</span></code> 类型定义了一个SQL表达式，每当在SELECT语句的列子句中呈现“test_table.c.data”列时，就会发出该表达式：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">test_table</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">test_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;HI&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">lower</span><span class="p">(</span><span class="n">test_table</span><span class="p">.</span><span class="k">data</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">data</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">test_table</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">test_table</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">lower</span><span class="p">(:</span><span class="n">data_1</span><span class="p">)</span>
</div></pre></div>
</div>
<p>此功能也被新版本的GeoAlchemy广泛使用，以根据类型规则内联嵌入PostGIS表达式。</p>
<p><a href="#id30"><span class="problematic" id="id31">:ticket:`1534`</span></a></p>
</section>
<section id="id32">
<h3>Core检查系统<a class="headerlink" href="#id32" title="Permalink to this heading">¶</a></h3>
<p>在 <a class="reference internal" href="#feature-orminspection-08"><span class="std std-ref">新的类/对象检查系统</span></a> 中引入的 <a class="reference internal" href="../core/inspection.html#sqlalchemy.inspect" title="sqlalchemy.inspect"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect()</span></code></a> 函数，现在也适用于Core。应用于 <code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code> 它会产生 <a class="reference internal" href="../core/reflection.html#sqlalchemy.engine.reflection.Inspector" title="sqlalchemy.engine.reflection.Inspector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inspector</span></code></a> 对象：</p>
<blockquote>
<div><p>from sqlalchemy import inspect
from sqlalchemy import create_engine</p>
<p>engine = create_engine(“postgresql://scott:tiger&#64;localhost/test”)
insp = inspect(engine)    print(insp.get_table_names())</p>
</div></blockquote>
<p>它还可以应用于任何 <a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a>，它返回 <a class="reference internal" href="../core/foundation.html#sqlalchemy.sql.expression.ClauseElement" title="sqlalchemy.sql.expression.ClauseElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClauseElement</span></code></a> 本身，例如 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>、<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>、<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 等。这使得它可以在 Core 和 ORM 结构之间流畅地工作。</p>
</section>
<section id="expression-select-correlate-except">
<h3>新的方法 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a><a class="headerlink" href="#expression-select-correlate-except" title="Permalink to this heading">¶</a></h3>
<p>现在，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 有一个方法 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a>，它指定“对除特定选择之外的所有 FROM 子句进行关联”。它可用于映射场景，其中一个相关子查询应该正常关联，除了特定的目标可选择的子句：</p>
<blockquote>
<div><dl>
<dt>class SnortEvent(Base):</dt><dd><p>__tablename__ = “event”</p>
<p>id = Column(Integer, primary_key=True)
signature = Column(Integer, ForeignKey(“signature.id”))</p>
<p>signatures = relationship(“Signature”, lazy=False)</p>
</dd>
<dt>class Signature(Base):</dt><dd><p>__tablename__ = “signature”</p>
<p>id = Column(Integer, primary_key=True)</p>
<dl class="simple">
<dt>sig_count = column_property(</dt><dd><p>select([func.count(“*”)])
.where(SnortEvent.signature == id)
.correlate_except(SnortEvent)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="postgresql-hstore">
<h3>PostgreSQL HSTORE 类型<a class="headerlink" href="#postgresql-hstore" title="Permalink to this heading">¶</a></h3>
<p>现在可以使用 PostgreSQL 的 <code class="docutils literal notranslate"><span class="pre">HSTORE</span></code> 类型，例如 <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE" title="sqlalchemy.dialects.postgresql.HSTORE"><code class="xref py py-class docutils literal notranslate"><span class="pre">HSTORE</span></code></a>。该类型充分利用了新的运算符系统，为 HSTORE 类型提供了全面的运算符范围，包括索引访问、连接和包含方法，例如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">comparator_factory.has_key()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">comparator_factory.has_any()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">comparator_factory.matrix()</span></code>：</p>
<blockquote>
<div><p>from sqlalchemy.dialects.postgresql import HSTORE</p>
<dl class="simple">
<dt>data = Table(</dt><dd><p>“data_table”,
metadata,
Column(“id”, Integer, primary_key=True),
Column(“hstore_data”, HSTORE),</p>
</dd>
</dl>
<p>)</p>
<p>engine.execute(select([data.c.hstore_data[“some_key”]])).scalar()</p>
<p>engine.execute(select([data.c.hstore_data.matrix()])).scalar()</p>
</div></blockquote>
<p><a href="#id33"><span class="problematic" id="id34">:ticket:`2606`</span></a></p>
</section>
<section id="postgresql-array">
<h3>增强的 PostgreSQL ARRAY 类型<a class="headerlink" href="#postgresql-array" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY" title="sqlalchemy.dialects.postgresql.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 类型将接受一个名为“维度”的可选参数，将其固定为一定数量的维度，并在检索结果时大大提高效率：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 老方法，因为 PG 支持每行 N 维度：</span>
<span class="n">Column</span><span class="p">(</span><span class="s2">&quot;my_array&quot;</span><span class="p">,</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">ARRAY</span><span class="p">(</span><span class="n">Integer</span><span class="p">))</span>

<span class="c1"># 新方法，将在 DDL 中呈现带有正确数量的 [] 的 ARRAY，</span>
<span class="c1"># 由于我们不需要猜测要向哪里深入，因此将更有效地处理绑定和结果</span>
<span class="n">Column</span><span class="p">(</span><span class="s2">&quot;my_array&quot;</span><span class="p">,</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">ARRAY</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span></pre></div>
</div>
<p>该类型还引入了新运算符，使用新的特定于类型的 operator 框架。新操作包括索引访问：</p>
<blockquote>
<div><p>result = conn.execute(select([mytable.c.arraycol[2]]))</p>
</div></blockquote>
<p>在 SELECT 中的切片访问：</p>
<blockquote>
<div><p>result = conn.execute(select([mytable.c.arraycol[2:4]]))</p>
</div></blockquote>
<p>在 UPDATE 中的切片更新：</p>
<blockquote>
<div><p>conn.execute(mytable.update().values({mytable.c.arraycol[2:3]: [7, 8]}))</p>
</div></blockquote>
<p>自由数组字面量：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">postgresql</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])]))</span>
<span class="go">[1, 2, 3, 4, 5]</span></pre></div>
</div>
<p>数组连接，其中下面的右侧 “[4, 5, 6]” 被强制转换为数组文字：</p>
<blockquote>
<div><p>select([mytable.c.arraycol + [4, 5, 6]])</p>
</div></blockquote>
<p><a href="#id35"><span class="problematic" id="id36">:ticket:`2441`</span></a></p>
</section>
<section id="sqlite-datetime">
<h3>适用于 SQLite 的新可配置 DATE、TIME 类型<a class="headerlink" href="#sqlite-datetime" title="Permalink to this heading">¶</a></h3>
<p>SQLite 没有内置的 DATE、TIME 或 DATETIME 类型，而是提供了一些支持以字符串或整数格式存储日期和时间值的工具。在 0.8 中，SQLite 的日期和时间类型大大提高了配置性，包括“微秒”部分是可选的，以及几乎所有内容都可以配置。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;sometimestamp&quot;</span><span class="p">,</span> <span class="n">sqlite</span><span class="o">.</span><span class="n">DATETIME</span><span class="p">(</span><span class="n">truncate_microseconds</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">Column</span><span class="p">(</span>
    <span class="s2">&quot;sometimestamp&quot;</span><span class="p">,</span>
    <span class="n">sqlite</span><span class="o">.</span><span class="n">DATETIME</span><span class="p">(</span>
        <span class="n">storage_format</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%(year)04d%(month)02d%(day)02d</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="si">%(hour)02d%(minute)02d%(second)02d%(microsecond)06d</span><span class="s2">&quot;</span>
        <span class="p">),</span>
        <span class="n">regexp</span><span class="o">=</span><span class="s2">&quot;(\d</span><span class="si">{4}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{2}</span><span class="s2">)(\d</span><span class="si">{6}</span><span class="s2">)&quot;</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>
<span class="n">Column</span><span class="p">(</span>
    <span class="s2">&quot;somedate&quot;</span><span class="p">,</span>
    <span class="n">sqlite</span><span class="o">.</span><span class="n">DATE</span><span class="p">(</span>
        <span class="n">storage_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(month)02d</span><span class="s2">/</span><span class="si">%(day)02d</span><span class="s2">/</span><span class="si">%(year)04d</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">regexp</span><span class="o">=</span><span class="s2">&quot;(?P&lt;month&gt;\d+)/(?P&lt;day&gt;\d+)/(?P&lt;year&gt;\d+)&quot;</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span></pre></div>
</div>
<p>感谢 Nate Dub 在 Pycon 2012 上的 sprint。</p>
<p><a href="#id37"><span class="problematic" id="id38">:ticket:`2363`</span></a></p>
</section>
<section id="collate-mysqlpostgresql-sqlite">
<h3>在所有方言上支持“COLLATE”；特别是在 MySQL、PostgreSQL 和 SQLite 中<a class="headerlink" href="#collate-mysqlpostgresql-sqlite" title="Permalink to this heading">¶</a></h3>
<p>“collate”关键字在 MySQL 方言上被长期接受，现在已在所有 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> 类型上及任何后端上呈现：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">cast</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">somechar</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">collation</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">sometable</span><span class="p">.</span><span class="n">somechar</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">COLLATE</span><span class="w"> </span><span class="ss">&quot;utf8&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">sometable</span>
</div></pre></div>
</div>
<p><a href="#id39"><span class="problematic" id="id40">:ticket:`2276`</span></a></p>
</section>
<section id="expression-update-expression-delete">
<h3>为 <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.update" title="sqlalchemy.sql.expression.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a>、<a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.delete" title="sqlalchemy.sql.expression.delete"><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></a> 启用“前缀”<a class="headerlink" href="#expression-update-expression-delete" title="Permalink to this heading">¶</a></h3>
<p>面向 MySQL，可以在任何这些结构中呈现前缀。“a=1”这样的比较就变成了“a IN (1,)”。
例如：</p>
<blockquote>
<div><p>stmt = table.delete().prefix_with(“LOW_PRIORITY”, dialect=”mysql”)</p>
<p>stmt = table.update().prefix_with(“LOW_PRIORITY”, dialect=”mysql”)</p>
</div></blockquote>
<p>该方法是新添加的，另外加入了一些已经存在的方法，
如 <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a>、<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 和 <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query" title="sqlalchemy.orm.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a></p>
<p><a href="#id41"><span class="problematic" id="id42">:ticket:`2431`</span></a></p>
</section>
</section>
<section id="id43">
<h2>行为变化<a class="headerlink" href="#id43" title="Permalink to this heading">¶</a></h2>
<p>legacy_is_orphan_addition：</p>
<section id="id44">
<h3>将“挂起”对象视为“孤立”对象的考虑更加积极<a class="headerlink" href="#id44" title="Permalink to this heading">¶</a></h3>
<p>这是 0.8 系列的一个迟到的添加，但是希望新行为通常在更广泛的情况下更一致和直观。ORM 从至少版本 0.4 开始就包含行为，使得“挂起”的对象（即它与 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 关联，但尚未插入到数据库中的对象）在成为“孤儿”时，在断开与引用它的父对象的关系（在配置的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 上使用“delete-orphan”级联时）时会自动从 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 中删除，这种行为旨在大约类似于持久（即已插入）对象的行为，其中 ORM 将拦截分离事件并为基于分离事件的孤儿对象发出 DELETE。</p>
<p>该行为适用于从属于多个父级都指定“delete-orphan”级联的任何父级都指定“delete-orphan”级联并且规模为一对多或多对多的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>；这是一种尴尬而又无法预知地使用用例（受到一定限制），但尽管如此，该行为仍然希望在对象被部分地关联到要求的父级时能够更一致地操作，而不是需要所有父级都必须置于一个已知的状态。</p>
<p>发生更改的行为适用于以下对象：</p>
<blockquote>
<div><dl>
<dt>class UserKeyword(Base):</dt><dd><p>__tablename__ = “user_keyword”
user_id = Column(Integer, ForeignKey(“user.id”), primary_key=True)
keyword_id = Column(Integer, ForeignKey(“keyword.id”), primary_key=True)</p>
<dl class="simple">
<dt>user = relationship(</dt><dd><p>User, backref=backref(“user_keywords”, cascade=”all, delete-orphan”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>keyword = relationship(</dt><dd><p>“Keyword”, backref=backref(“user_keywords”, cascade=”all, delete-orphan”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>在以前的行为中，在所有父对象上均未放置该挂起的对象时，该对象将被删除，并且我的结果不同，如果该挂起的对象已与任何父级关联，将重新关联 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 。</p>
<p>无论如何，您仍然可以刷新未与所有必需的父项关联的对象（即，如果该对象在首次关联时未与那些父项关联，或者如果该对象被强制删除，但是它后来又通过后续附加事件重新关联了 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>，但仍未完全关联）在此情况下，预计数据库会发出完整性错误，因为可能存在未填充的 NOT NULL 外键列。ORM 做出的决定是让这些 INSERT 尝试发生，基于这样的审判，一个只与某些父级部分关联但已积极关联到其中某些父级的对象更经常是用户错误，而不是意向性遗漏，此时忽略 INSERT 操作是更常见的用户错误，而不是应该默默地跳过–在这里默默跳过 INSERT 将使这种类型的用户错误非常难以调试。</p>
<p>对于可能依赖这种行为的应用程序，可以通过 mapper 选项将旧行为重新启用“legacy_is_orphan”。</p>
<p>新行为使以下测试用例适用：</p>
<blockquote>
<div><p>from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, backref
from sqlalchemy.ext.declarative import declarative_base</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”
id = Column(Integer, primary_key=True)
name = Column(String(64))</p>
</dd>
<dt>class UserKeyword(Base):</dt><dd><p>__tablename__ = “user_keyword”
user_id = Column(Integer, ForeignKey(“user.id”), primary_key=True)
keyword_id = Column(Integer, ForeignKey(“keyword.id”), primary_key=True)</p>
<dl class="simple">
<dt>user = relationship(</dt><dd><p>User, backref=backref(“user_keywords”, cascade=”all, delete-orphan”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>keyword = relationship(</dt><dd><p>“Keyword”, backref=backref(“user_keywords”, cascade=”all, delete-orphan”)</p>
</dd>
</dl>
<p>)</p>
<p># 取消注释以启用旧行为
# __mapper_args__ = {“legacy_is_orphan”: True}</p>
</dd>
<dt>class Keyword(Base):</dt><dd><p>__tablename__ = “keyword”
id = Column(Integer, primary_key=True)
keyword = Column(“keyword”, String(64))</p>
</dd>
</dl>
<p>from sqlalchemy import create_engine
from sqlalchemy.orm import Session</p>
<p># note we’re using PostgreSQL to ensure that referential integrity
# is enforced, for demonstration purposes.
e = create_engine(“postgresql://scott:tiger&#64;localhost/test”, echo=True)</p>
<p>Base.metadata.drop_all(e)
Base.metadata.create_all(e)</p>
<p>session = Session(e)</p>
<p>u1 = User(name=”u1”)
k1 = Keyword(keyword=”k1”)</p>
<p>session.add_all([u1, k1])</p>
<p>uk1 = UserKeyword(keyword=k1, user=u1)</p>
<p># 在以前的行为中，如果在此处调用了 session.flush()，
# 则此操作将成功，但是如果没有调用 session.flush()，
# 操作将因完整性错误而失败。
# session.flush()
del u1.user_keywords[0]</p>
<p>session.commit()</p>
</div></blockquote>
<p><a href="#id45"><span class="problematic" id="id46">:ticket:`2655`</span></a></p>
</section>
<section id="session-after-attach-before-attach">
<h3>在对象关联到 Session 后发生 after_attach 事件，而不是在之前；添加 before_attach<a class="headerlink" href="#session-after-attach-before-attach" title="Permalink to this heading">¶</a></h3>
<p>使用 after_attach 的事件处理程序现在可以假定给定实例与给定的 Session 关联：</p>
<blockquote>
<div><p>&#64;event.listens_for(Session, “after_attach”)
def after_attach(session, instance):</p>
<blockquote>
<div><p>assert instance in session</p>
</div></blockquote>
</div></blockquote>
<p>某些用例需要它按此方式工作。但是，另一些用例要求该项尚未成为会话的一部分，例如，当查询旨在加载某些用于实例的必要状态时，它会首先发出 autoflush，并且将在未执行 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 的任何关联事件之前更改结果。这些用例应使用新的“before_attach”事件：</p>
<blockquote>
<div><p>&#64;event.listens_for(Session, “before_attach”)
def before_attach(session, instance):</p>
<blockquote>
<div><dl class="simple">
<dt>instance.some_necessary_attribute = (</dt><dd><p>session.query(Widget).filter_by(instance.widget_name).first()</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</div></blockquote>
<p><a href="#id47"><span class="problematic" id="id48">:ticket:`2464`</span></a></p>
</section>
<section id="select">
<h3>查询现在会像 select() 一样自动关联<a class="headerlink" href="#select" title="Permalink to this heading">¶</a></h3>
<p>以前，必须调用 <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate" title="sqlalchemy.orm.Query.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.correlate()</span></code></a> 才能使列子查询或 WHERE 子查询与父级关联 :</p>
<blockquote>
<div><dl class="simple">
<dt>subq = (</dt><dd><p>session.query(Entity.value)
.filter(Entity.id == Parent.entity_id)
.correlate(Parent)
.as_scalar()</p>
</dd>
</dl>
<p>)
session.query(Parent).filter(subq == “some value”)</p>
</div></blockquote>
<p>这与普通的“select()”构造相反行为，后者默认情况下将自动关联。在 0.8 中，如果选择语句处于此上下文中，则选择语句将仅在实际使用该上下文时从 FROM 子句中省略“相关(即保留)”目标。此外，无法自己指定一个在一个封闭的选择语句中被放置作为 FROM 的选择语句来“关联”（即，省略）FROM 子句。</p>
<p>此更改仅使呈现 SQL 更佳，这样即使在选择语句用法正确的情况下也不可能呈现非法 SQL，其中没有足够的 FROM 对象相对于所选择的项目：</p>
<blockquote>
<div><p>from sqlalchemy.sql import table, column, select</p>
<p>t1 = table(“t1”, column(“x”))
t2 = table(“t2”, column(“y”))
s = select([t1, t2]).correlate(t1)</p>
<p>print(s)</p>
</div></blockquote>
<p>在此更改之前，上面的代码将返回:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t2</span></pre></div>
</div>
<p>由于 t1 在任何 FROM 子句中都没有被引用，这是非法的 SQL。</p>
<p>现在，在没有封闭的 SELECT 中，它将返回：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span></pre></div>
</div>
<p>在 SELECT 中，关联行为与期望相同：</p>
<blockquote>
<div><p>s2 = select([t1, t2]).where(t1.c.x == t2.c.y).where(t1.c.x == s)
print(s2)</p>
</div></blockquote>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">t2</span><span class="p">)</span></pre></div>
</div>
<p>此更改不应影响任何现有应用程序，因为关联行为对于正确构建的表达式保持相同。只有测试场景中依赖于关联 SELECT 的非法字符串输出的应用程序会看到任何更改。</p>
<p><a href="#id49"><span class="problematic" id="id50">:ticket:`2668`</span></a></p>
<p>correlation_context_specific:</p>
</section>
<section id="id51">
<h3>关联始终是上下文特定的<a class="headerlink" href="#id51" title="Permalink to this heading">¶</a></h3>
<p>为了允许更广泛的关联方案，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate()</span></code></a> 和 <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate" title="sqlalchemy.orm.Query.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.correlate()</span></code></a> 的行为略有更改，以便仅在语句在该上下文中实际使用时，才从选择语句的 FROM 子句中省略“关联”目标。此外，无法自己指定一个在封闭的 SELECT 中作为一个 FROM 语句被放置的选择语句来“关联”（即，省略）FROM 子句。</p>
<p>此更改仅使呈现 SQL 更佳，在正确构建的表达式中，关联行为仍完全相同，包括“名字”和“键”方面的所有行为相同，包括呈现 SQL 仍然使用：&lt;tablename&gt;_&lt;colname&gt;该重点在于防止 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a> 内容呈现为“SELECT”语句，以使 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a> 中使用的特殊/非 ASCII 字符没有任何问题。</p>
<p><a href="#id52"><span class="problematic" id="id53">:ticket:`2668`</span></a></p>
<p>metadata_create_drop_tables:
.:meth:<cite>_schema.MetaData.create_all</cite> 和 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.drop_all" title="sqlalchemy.schema.MetaData.drop_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.drop_all()</span></code></a> 现在将尊重空列表作为这样的
—————————————————————-</p>
<p>方法 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.create_all" title="sqlalchemy.schema.MetaData.create_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.create_all()</span></code></a> 和 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.drop_all" title="sqlalchemy.schema.MetaData.drop_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.drop_all()</span></code></a> 现在将接受一个空的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象列表，并且不会发出任何 CREATE 或 DROP 语句。以前，空列表与传递“None”集合相同，并且 CREATE/DROP 将无条件地发出。</p>
<p>这是一个错误修复，但某些应用程序可能已经依赖于以前的行为。</p>
<p><a href="#id54"><span class="problematic" id="id55">:ticket:`2664`</span></a></p>
</section>
<section id="orm-session-is-modified">
<h3><code class="xref py py-func docutils literal notranslate"><span class="pre">is_modified()</span></code> 的行为已修复<a class="headerlink" href="#orm-session-is-modified" title="Permalink to this heading">¶</a></h3>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.is_modified()</span></code> 方法接受一个参数“被动”，基本上不应该必要的情况下，所有情况下都应该是 “True” 的值 - 当其保留在其默认值“False”时，它会显示数据库，通常会触发 autoflush，它本身会更改结果。在 0.8 中，“被动”参数将无效，并且未加载的属性将永远不会检查其记录，因为按定义，未加载的属性上不能有待处理的状态更改。</p>
<p><a href="#id56"><span class="problematic" id="id57">:ticket:`2320`</span></a></p>
</section>
<section id="schema-column-key-expression-select-apply-labels-expression-select-c">
<h3><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a> 在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.apply_labels()</span></code> 中使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.c" title="sqlalchemy.sql.expression.Select.c"><code class="xref py py-class docutils literal notranslate"><span class="pre">c</span></code></a> 属性时得到了尊重<a class="headerlink" href="#schema-column-key-expression-select-apply-labels-expression-select-c" title="Permalink to this heading">¶</a></h3>
<p>表达式系统的用户知道，<code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.apply_labels()</span></code> 将表名添加到每个列名之前，影响可从 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.c" title="sqlalchemy.sql.expression.Select.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Select.c</span></code></a> 中使用的名称：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">table1</span><span class="p">])</span><span class="o">.</span><span class="n">apply_labels</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">table1_col1</span>
<span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">table1_col2</span></pre></div>
</div>
<p>在 0.8 之前，如果 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 具有不同的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a>，则此键将被忽略，相对于未使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.apply_labels()</span></code> 时的不一致：</p>
<blockquote>
<div><p># 在 0.8 之前
table1 = Table(“t1”, metadata, Column(“col1”, Integer, key=”column_one”))
s = select([table1])
s.c.column_one  # 可以像这样访问
s.c.col1  # 将引发 AttributeError</p>
<p>s = select([table1]).apply_labels()
s.c.table1_column_one  # 将引发 AttributeError
s.c.table1_col1  # 可以像这样访问</p>
</div></blockquote>
<p>在 0.8 中，<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a> 在两种情况下都会被尊重：</p>
<blockquote>
<div><p># 与 0.8 一起使用
table1 = Table(“t1”, metadata, Column(“col1”, Integer, key=”column_one”))
s = select([table1])
s.c.column_one  # 有效
s.c.col1  # AttributeError</p>
<p>s = select([table1]).apply_labels()
s.c.table1_column_one  # 有效
s.c.table1_col1  # AttributeError</p>
</div></blockquote>
<p>所有其他的“name”和“key”行为都是相同的，包括呈现的 SQL 仍然使用形式“&lt; tablename&gt; _ &lt;colname&gt;”–重点是防止 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a> 内容被呈现为“SELECT”语句，从而避免了使用 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.key" title="sqlalchemy.schema.Column.key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.key</span></code></a> 中的特殊/非 ASCII 字符可能会出现的问题。</p>
<p><a href="#id58"><span class="problematic" id="id59">:ticket:`2397`</span></a></p>
</section>
<section id="id60">
<h3>单个父级警告现在为错误<a class="headerlink" href="#id60" title="Permalink to this heading">¶</a></h3>
<p>由于某种原因，如果 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 是一对多或多对多关系，并且指定了“cascade=’all, delete-orphan’”，这是一种尴尬但仍然支持的用例（具有限制条件），如果关系没有指定 <code class="docutils literal notranslate"><span class="pre">single_parent=True</span></code> 选项，则现在将引发错误而不是警告。
以前只会发出警告，但是几乎立即会在属性系统中因为警告而失败。</p>
<p><a href="#id61"><span class="problematic" id="id62">:ticket:`2405`</span></a></p>
</section>
<section id="id63">
<h3>为“列反映”添加“审核器”参数<a class="headerlink" href="#id63" title="Permalink to this heading">¶</a></h3>
<p>在 0.7 中添加了一个名为“column_reflect”的新事件，以便可以在反射每个列时添加增量。我们将此事件搞错了，因为事件没有提供任何方式来获取正在使用的当前“Inspector”和“Connection”，在需要数据库中的其他信息时。在这个新事件不被广泛使用的情况下，我们将直接将“审核器”参数添加到其中：</p>
<blockquote>
<div><p>&#64;event.listens_for(Table, “column_reflect”)
def listen_for_col(inspector, table, column_info):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
</div></blockquote>
<p><a href="#id64"><span class="problematic" id="id65">:ticket:`2418`</span></a></p>
</section>
<section id="mysql">
<h3>禁用 MySQL 的自动检测排序方式，大小写方式<a class="headerlink" href="#mysql" title="Permalink to this heading">¶</a></h3>
<p>MySQL 方言为了连接所有可能的排序方式花费了两次调用，特别是消耗大量的时间，第一次在 <code class="docutils literal notranslate"><span class="pre">Engine</span></code> 连接的第一次，获取所有可能的排序方式，以及大小写方式的信息。这些集合不用于 SQLAlchemy 的任何功能，因此将更改这些调用不再自动发出。如果需要，可能会依赖于“engin.dialect” 中存在这些集合的应用程序需要直接调用“_detect_collations()”和“_detect_casing()”。</p>
<p><a href="#id66"><span class="problematic" id="id67">:ticket:`2404`</span></a></p>
</section>
<section id="id68">
<h3>“未使用的列名称”警告现在变成异常<a class="headerlink" href="#id68" title="Permalink to this heading">¶</a></h3>
<p>在“insert()”或“update()”构造中引用不存在的列将引发错误，而不是警告：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t1</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s2">&quot;t1&quot;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="n">t1</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 引发 &quot;Unconsumed column names: z&quot;</span></pre></div>
</div>
<p><a href="#id69"><span class="problematic" id="id70">:ticket:`2415`</span></a></p>
</section>
<section id="inspector-get-primary-keys-inspector-get-pk-constraint">
<h3>Inspector.get_primary_keys() 被弃用，请使用 Inspector.get_pk_constraint<a class="headerlink" href="#inspector-get-primary-keys-inspector-get-pk-constraint" title="Permalink to this heading">¶</a></h3>
<p>这两种方法在“Inspector”上是冗余的，其中“get_primary_keys()”将返回与“get_pk_constraint()”相同（不包括约束的名称）的信息：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">insp</span><span class="o">.</span><span class="n">get_primary_keys</span><span class="p">()</span>
<span class="go">[&quot;a&quot;, &quot;b&quot;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">insp</span><span class="o">.</span><span class="n">get_pk_constraint</span><span class="p">()</span>
<span class="go">{&quot;name&quot;:&quot;pk_constraint&quot;, &quot;constrained_columns&quot;:[&quot;a&quot;, &quot;b&quot;]}</span></pre></div>
</div>
<p><a href="#id71"><span class="problematic" id="id72">:ticket:`2422`</span></a></p>
</section>
<section id="id73">
<h3>在大多数情况下，将不再启用大小写不敏感的结果行名称<a class="headerlink" href="#id73" title="Permalink to this heading">¶</a></h3>
<p>对于大多数数据库/方言，添加一个新的配置 - <code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.case_sensitive</span></code> 来控制大小写是否保留为结果行名称。该选项指示对结果行名称进行适当大小写，或仅对结果行名称进行小写或大写，具体取决于方言的处理方式。但是，几乎所有版本的 SQLite 都不能保留大小写，而要么只使用大写名称，要么只是小写名称。因此，对于 SQLite，case_sensitive=False 现在是默认设置，并且对于其他方言是 True。标准的 INI 文件系列目前未引用此设置，但是可以通过传递“sqlalchemy.create_engine（<em>args， *</em> kwargs）”参数来使用此选择。</p>
<p>An error has occured parsing your request. Please try again. If this issue persists, contact support.一个非常老的行为，即``RowProxy``中的列名始终是不区分大小写比较：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;FOO&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;Foo&quot;</span><span class="p">]</span>
<span class="go">True</span></pre></div>
</div>
<p>这是为了一些早期需要这种行为的方言，如Oracle和Firebird，但现代使用中，我们有更精确的方法来处理这两个平台的不区分大小写行为。</p>
<p>从现在开始，只有通过传递参数```case_sensitive=False```到```create_engine()```以可选方式使用此行为，否则从该行请求的列名必须匹配大小写。</p>
</section>
<section id="instrumentationmanager">
<h3><a href="#id74"><span class="problematic" id="id75">``</span></a>InstrumentationManager``和替代类中间件是一个扩展<a class="headerlink" href="#instrumentationmanager" title="Permalink to this heading">¶</a></h3>
<p>类``sqlalchemy.orm.interfaces.InstrumentationManager``
已经转移到了``sqlalchemy.ext.instrumentation.InstrumentationManager``。
为了让少数需要使用现有或非常规类中间件系统的安装受益，
已构建“替代中间件”系统，通常很少使用。这个系统的复杂性已经导出到一个``ext.``模块中。直到一旦导入，通常是当第三方库导入``InstrumentationManager``时，它才会被注入回到``sqlalchemy.orm``中，通过``ExtendedInstrumentationRegistry``用替代默认的``InstrumentationFactory``。</p>
</section>
</section>
<section id="id76">
<h2>删除<a class="headerlink" href="#id76" title="Permalink to this heading">¶</a></h2>
<section id="sqlsoup">
<h3>SQLSoup<a class="headerlink" href="#sqlsoup" title="Permalink to this heading">¶</a></h3>
<p>SQLSoup是SQLAlchemy ORM上的一个备选接口。SQLSoup现已移到它自己的项目中，并单独进行文档/发布；见https://bitbucket.org/zzzeek/sqlsoup。</p>
<p>SQLSoup是一个非常简单的工具，也可以受益于那些对它的使用风格感兴趣的贡献者。</p>
<p><a href="#id77"><span class="problematic" id="id78">:ticket:`2262`</span></a></p>
</section>
<section id="mutabletype">
<h3>MutableType<a class="headerlink" href="#mutabletype" title="Permalink to this heading">¶</a></h3>
<p>在SQLAlchemy ORM内部已删除旧的“可变”系统。这指的是应用于类型如``PickleType``和有条件的``TypeDecorator``的``MutableType``接口，并且自从SQLAlchemy很早的版本以来一直提供了一种检测所谓的“可变”数据结构（如JSON结构和拾取对象）变化的方法。然而，实现从未合理，强迫单元工作以非常低效的方式进行，导致在刷新期间进行了昂贵的对象扫描。在0.7中，引入了`sqlalchemy.ext.mutable &lt;<a class="reference external" href="https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html">https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html</a>&gt;`_扩展，以便用户定义的数据类型可以在更改发生时适当地向工作单元发送事件。</p>
<p>今天，预计使用``MutableType``的人很少，因为多年来已经警告过其低效性。</p>
<p><a href="#id79"><span class="problematic" id="id80">:ticket:`2442`</span></a></p>
</section>
<section id="sqlalchemy-exceptions-sqlalchemy-exc">
<h3>sqlalchemy.exceptions（数年来已是sqlalchemy.exc）<a class="headerlink" href="#sqlalchemy-exceptions-sqlalchemy-exc" title="Permalink to this heading">¶</a></h3>
<p>我们留下了一个别名``sqlalchemy.exceptions``，以试图使一些尚未升级到使用``sqlalchemy.exc``的非常老的库稍微容易一些。然而，一些用户仍然被困惑了，因此在0.8中完全删除它以消除任何混淆。</p>
<p><a href="#id81"><span class="problematic" id="id82">:ticket:`2433`</span></a></p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="migration_09.html" title="previous chapter">SQLAlchemy 0.9 的新特性</a>
        Next:
        <a href="migration_07.html" title="next chapter">SQLAlchemy 0.7有什么新特性？</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:30:54

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


