<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    SQLAlchemy 1.0有哪些新特性？
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="变更和迁移" href="index.html" />
        <link rel="next" title="SQLAlchemy 0.9 的新特性" href="migration_09.html" />
        <link rel="prev" title="SQLAlchemy 1.1新功能" href="migration_11.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="变更和迁移">变更和迁移</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="migration_20.html">SQLAlchemy 2.0 - 主要迁移指南</a></span></li>
<li><span class="link-container"><a class="reference external" href="whatsnew_20.html">SQLAlchemy 2.0 有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_20.html">2.0 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_14.html">1.4 版本更新历史</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_13.html">1.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_12.html">1.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_11.html">1.1 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_10.html">1.0 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_09.html">0.9版本更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_08.html">0.8 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_06.html">0.6 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_05.html">0.5 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_04.html">0.4 变更日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_03.html">0.3 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_02.html">0.2 更新日志</a></span></li>
<li><span class="link-container"><a class="reference external" href="changelog_01.html">版本记录</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_14.html">SQLAlchemy 1.4有哪些新内容？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_13.html">SQLAlchemy 1.3有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_12.html">SQLAlchemy 1.2有哪些新特性?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_11.html">SQLAlchemy 1.1新功能</a></span></li>
<li class="selected"><span class="link-container"><strong>SQLAlchemy 1.0有哪些新特性？</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">引言</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm">新功能和改进-ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sessioninsert-update-api">新的Session批量INSERT/UPDATE API</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id4">新的性能范例套件</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">“烘培”查询</a></span></li>
<li><span class="link-container"><a class="reference external" href="#declarative-mixins-declared-attr">提高declarative mixins，“&#64;declared_attr”和相关功能</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm25">ORM完整对象获取的速度提高了25%</a></span></li>
<li><span class="link-container"><a class="reference external" href="#keyedtuple">新的KeyedTuple实现速度大大提高</a></span></li>
<li><span class="link-container"><a class="reference external" href="#feature-slots">结构性内存使用的显著改进</a></span></li>
<li><span class="link-container"><a class="reference external" href="#updateexecutemany">在刷新中，UPDATE语句会使用executemany()批量批处理</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-get-bind">Session.get_bind()现在可以处理更广泛的继承场景</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session-get-bind-mapper">Session.get_bind()现在通过所有相关的查询用例接收Mapper</a></span></li>
<li><span class="link-container"><a class="reference external" href="#info">.info词典改进</a></span></li>
<li><span class="link-container"><a class="reference external" href="#columnpropertyorder-by">ColumnProperty结构与别名以及order_by较好地生成</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#core">新功能和改进-Core</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#limit-offsetsql">选择/查询LIMIT/OFFSET可以指定为任意的SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="#use-alter">除了在生成整体性的外键约束时指定use_alter标志外</a></span></li>
<li><span class="link-container"><a class="reference external" href="#resultproxy">ResultProxy的“自动关闭”现在是“软关闭”</a></span></li>
<li><span class="link-container"><a class="reference external" href="#check-column-0-name">CHECK约束现在支持命名约定中的”column_0_name”标记</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3341">引用未附加列的约束可以在列关联到表时自动附加到表上</a></span></li>
<li><span class="link-container"><a class="reference external" href="#insert-from-select-pythonsql">“INSERT FROM SELECT”现在包括Python和SQL表达式默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#column-server-defaults">Column Server Defaults现在呈现为文字值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#uniqueconstraint">``UniqueConstraint``现在是数据表反射过程的一部分</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#postgresql">PostgreSQL</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mysql">MySQL</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id108">新系统安全发出参数化警告</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#key-behavioral-changes-orm">Key Behavioral Changes - ORM</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#meth-query-query-update">：meth:`_query.Query.update`现在可以将字符串名称解析为映射属性名称</a></span></li>
<li><span class="link-container"><a class="reference external" href="#none">在将带有None值的对象与关系比较时发出警告</a></span></li>
<li><span class="link-container"><a class="reference external" href="#containsequals">“否定contains或equals”关系比较将使用属性的当前值而不是数据库值</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#id125">主要变更 - 流程管理</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#query-update">query.update()现在解析字符串名称以映射属性名称</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id133">当将对象与None值进行比较时发出警告</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id139">已删除的对象全部深度解绑过程已更正</a></span></li>
<li><span class="link-container"><a class="reference external" href="#on">单表继承类型的所有ON子句都被添加到条件语句中</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id145">退役事件钩子已被删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="#bundleapi">出于自定义行加载器被用于新Bundle功能的API更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="#synchronize-session-evaluate-query-update">具有“synchronize_session = ‘evaluate’”的query.update（）引发具有多表更新的异常</a></span></li>
<li><span class="link-container"><a class="reference external" href="#resurrect">已删除“Resurrect”事件</a></span></li>
<li><span class="link-container"><a class="reference external" href="#python">使用多值插入时为每个行单独调用Python端默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3163">无法从该事件的运行程序中添加或删除事件侦听器</a></span></li>
<li><span class="link-container"><a class="reference external" href="#insert-from-selectinline-true">INSERT…FROM SELECT构造现在暗示“inline = True”</a></span></li>
<li><span class="link-container"><a class="reference external" href="#autoload-with-autoload-true"><code class="docutils literal notranslate"><span class="pre">autoload_with``现在意味着``autoload</span> <span class="pre">=</span> <span class="pre">True</span></code></a></span></li>
<li><span class="link-container"><a class="reference external" href="#dbapihandle-error">DBAPI异常包装和handle_error（）事件改进</a></span></li>
<li><span class="link-container"><a class="reference external" href="#foreignkeyconstraint-columnscolumncollection">ForeignKeyConstraint.columns现在是ColumnCollection</a></span></li>
<li><span class="link-container"><a class="reference external" href="#metadata-sorted-tables">MetaData.sorted_tables访问器是“确定性的”</a></span></li>
<li><span class="link-container"><a class="reference external" href="#null-false-true">null（），false（）和true（）常量不再是单例</a></span></li>
<li><span class="link-container"><a class="reference external" href="#postgresql-oracle">PostgreSQL / Oracle在报告临时表/视图名称时具有不同的方法</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#dialect-improvements-and-changes-postgresql">Dialect Improvements and Changes - PostgreSQL</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#enum">ENUM类型的创建/删除规则彻底改写</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id219">PostgreSQL表选项</a></span></li>
<li><span class="link-container"><a class="reference external" href="#pginspector-get-enums-postgresql">PGInspector.get_enums()方法与PostgreSQL语言配合使用</a></span></li>
<li><span class="link-container"><a class="reference external" href="#postgresql-dialectmaterialized-views-foreign-tables">PostgreSQL dialect反映Materialized Views，Foreign Tables</a></span></li>
<li><span class="link-container"><a class="reference external" href="#change-3264">MySQL内部“没有此表”异常未传递到事件处理程序</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mysql-connectorraise-on-warnings">改变了MySQL-Connector的“raise_on_warnings”默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="#mysqltruefalse">MySQL布尔符号“true”、“false”再次有效</a></span></li>
<li><span class="link-container"><a class="reference external" href="#drizzle">Drizzle方言现在是一个外部方言</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sqlite">方言改进和变化 - SQLite</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sqliteuniqueforeign-key">SQLite有名和无名UNIQUE和FOREIGN KEY约束将检查和反射</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#sql-server">方言改进和变化 - SQL Server</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#sql-serverpyodbc">使用基于主机名的SQL Server连接需要PyODBC驱动程序名称</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sql-server-2012-varcharnvarcharvarbinary">SQL Server 2012大文本/二进制类型呈现为VARCHAR、NVARCHAR、VARBINARY</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#oracle">方言改进和变化 - Oracle</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#oraclecte">改进了Oracle中CTE的支持</a></span></li>
<li><span class="link-container"><a class="reference external" href="#ddloracle">DDL的新Oracle关键字</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="migration_09.html">SQLAlchemy 0.9 的新特性</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_08.html">SQLAlchemy 0.8有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_07.html">SQLAlchemy 0.7有什么新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_06.html">SQLAlchemy 0.6 有哪些新变化?</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html">SQLAlchemy 0.5有哪些新特性？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id1">主要文档更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id6">退化源</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id7">需求更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id8">ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id21">ORM扩展</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id22">模式/类型</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id23">连接池不再默认为线程本地</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#args-args">*args已接受，不再接受*args</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id44">删除</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id77">已重命名或已移动</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_05.html#id86">已弃用</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html">SQLAlchemy 0.4有什么新功能？</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id1">首先要做什么</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id2">模块导入</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id3">对象关系映射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id22">SQL表达式</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id26">架构和反射</a></span></li>
<li><span class="link-container"><a class="reference external" href="migration_04.html#id28">SQL执行</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="migration_11.html" title="previous chapter">SQLAlchemy 1.1新功能</a></li>
                <li><b>Next:</b>
                <a href="migration_09.html" title="next chapter">SQLAlchemy 0.9 的新特性</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="变更和迁移">变更和迁移</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#sqlalchemy-1-0">SQLAlchemy 1.0有哪些新特性？</a><ul>
<li><a class="reference internal" href="#id1">引言</a></li>
<li><a class="reference internal" href="#orm">新功能和改进-ORM</a><ul>
<li><a class="reference internal" href="#sessioninsert-update-api">新的Session批量INSERT/UPDATE API</a></li>
<li><a class="reference internal" href="#id4">新的性能范例套件</a></li>
<li><a class="reference internal" href="#id5">“烘培”查询</a></li>
<li><a class="reference internal" href="#declarative-mixins-declared-attr">提高declarative mixins，“&#64;declared_attr”和相关功能</a></li>
<li><a class="reference internal" href="#orm25">ORM完整对象获取的速度提高了25%</a></li>
<li><a class="reference internal" href="#keyedtuple">新的KeyedTuple实现速度大大提高</a></li>
<li><a class="reference internal" href="#feature-slots">结构性内存使用的显著改进</a></li>
<li><a class="reference internal" href="#updateexecutemany">在刷新中，UPDATE语句会使用executemany()批量批处理</a></li>
<li><a class="reference internal" href="#session-get-bind">Session.get_bind()现在可以处理更广泛的继承场景</a></li>
<li><a class="reference internal" href="#session-get-bind-mapper">Session.get_bind()现在通过所有相关的查询用例接收Mapper</a></li>
<li><a class="reference internal" href="#info">.info词典改进</a></li>
<li><a class="reference internal" href="#columnpropertyorder-by">ColumnProperty结构与别名以及order_by较好地生成</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core">新功能和改进-Core</a><ul>
<li><a class="reference internal" href="#limit-offsetsql">选择/查询LIMIT/OFFSET可以指定为任意的SQL表达式</a></li>
<li><a class="reference internal" href="#use-alter">除了在生成整体性的外键约束时指定use_alter标志外</a></li>
<li><a class="reference internal" href="#resultproxy">ResultProxy的“自动关闭”现在是“软关闭”</a></li>
<li><a class="reference internal" href="#check-column-0-name">CHECK约束现在支持命名约定中的”column_0_name”标记</a></li>
<li><a class="reference internal" href="#change-3341">引用未附加列的约束可以在列关联到表时自动附加到表上</a></li>
<li><a class="reference internal" href="#insert-from-select-pythonsql">“INSERT FROM SELECT”现在包括Python和SQL表达式默认值</a></li>
<li><a class="reference internal" href="#column-server-defaults">Column Server Defaults现在呈现为文字值</a></li>
<li><a class="reference internal" href="#uniqueconstraint">``UniqueConstraint``现在是数据表反射过程的一部分</a><ul>
<li><a class="reference internal" href="#postgresql">PostgreSQL</a></li>
<li><a class="reference internal" href="#mysql">MySQL</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id108">新系统安全发出参数化警告</a></li>
</ul>
</li>
<li><a class="reference internal" href="#key-behavioral-changes-orm">Key Behavioral Changes - ORM</a><ul>
<li><a class="reference internal" href="#meth-query-query-update">：meth:`_query.Query.update`现在可以将字符串名称解析为映射属性名称</a></li>
<li><a class="reference internal" href="#none">在将带有None值的对象与关系比较时发出警告</a></li>
<li><a class="reference internal" href="#containsequals">“否定contains或equals”关系比较将使用属性的当前值而不是数据库值</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id125">主要变更 - 流程管理</a><ul>
<li><a class="reference internal" href="#query-update">query.update()现在解析字符串名称以映射属性名称</a></li>
<li><a class="reference internal" href="#id133">当将对象与None值进行比较时发出警告</a></li>
<li><a class="reference internal" href="#id139">已删除的对象全部深度解绑过程已更正</a></li>
<li><a class="reference internal" href="#on">单表继承类型的所有ON子句都被添加到条件语句中</a></li>
<li><a class="reference internal" href="#id145">退役事件钩子已被删除</a></li>
<li><a class="reference internal" href="#bundleapi">出于自定义行加载器被用于新Bundle功能的API更改</a></li>
<li><a class="reference internal" href="#synchronize-session-evaluate-query-update">具有“synchronize_session = ‘evaluate’”的query.update（）引发具有多表更新的异常</a></li>
<li><a class="reference internal" href="#resurrect">已删除“Resurrect”事件</a></li>
<li><a class="reference internal" href="#python">使用多值插入时为每个行单独调用Python端默认值</a></li>
<li><a class="reference internal" href="#change-3163">无法从该事件的运行程序中添加或删除事件侦听器</a></li>
<li><a class="reference internal" href="#insert-from-selectinline-true">INSERT…FROM SELECT构造现在暗示“inline = True”</a></li>
<li><a class="reference internal" href="#autoload-with-autoload-true"><code class="docutils literal notranslate"><span class="pre">autoload_with``现在意味着``autoload</span> <span class="pre">=</span> <span class="pre">True</span></code></a></li>
<li><a class="reference internal" href="#dbapihandle-error">DBAPI异常包装和handle_error（）事件改进</a></li>
<li><a class="reference internal" href="#foreignkeyconstraint-columnscolumncollection">ForeignKeyConstraint.columns现在是ColumnCollection</a></li>
<li><a class="reference internal" href="#metadata-sorted-tables">MetaData.sorted_tables访问器是“确定性的”</a></li>
<li><a class="reference internal" href="#null-false-true">null（），false（）和true（）常量不再是单例</a></li>
<li><a class="reference internal" href="#postgresql-oracle">PostgreSQL / Oracle在报告临时表/视图名称时具有不同的方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dialect-improvements-and-changes-postgresql">Dialect Improvements and Changes - PostgreSQL</a><ul>
<li><a class="reference internal" href="#enum">ENUM类型的创建/删除规则彻底改写</a></li>
<li><a class="reference internal" href="#id219">PostgreSQL表选项</a></li>
<li><a class="reference internal" href="#pginspector-get-enums-postgresql">PGInspector.get_enums()方法与PostgreSQL语言配合使用</a></li>
<li><a class="reference internal" href="#postgresql-dialectmaterialized-views-foreign-tables">PostgreSQL dialect反映Materialized Views，Foreign Tables</a></li>
<li><a class="reference internal" href="#change-3264">MySQL内部“没有此表”异常未传递到事件处理程序</a></li>
<li><a class="reference internal" href="#mysql-connectorraise-on-warnings">改变了MySQL-Connector的“raise_on_warnings”默认值</a></li>
<li><a class="reference internal" href="#mysqltruefalse">MySQL布尔符号“true”、“false”再次有效</a></li>
<li><a class="reference internal" href="#drizzle">Drizzle方言现在是一个外部方言</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sqlite">方言改进和变化 - SQLite</a><ul>
<li><a class="reference internal" href="#sqliteuniqueforeign-key">SQLite有名和无名UNIQUE和FOREIGN KEY约束将检查和反射</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sql-server">方言改进和变化 - SQL Server</a><ul>
<li><a class="reference internal" href="#sql-serverpyodbc">使用基于主机名的SQL Server连接需要PyODBC驱动程序名称</a></li>
<li><a class="reference internal" href="#sql-server-2012-varcharnvarcharvarbinary">SQL Server 2012大文本/二进制类型呈现为VARCHAR、NVARCHAR、VARBINARY</a></li>
</ul>
</li>
<li><a class="reference internal" href="#oracle">方言改进和变化 - Oracle</a><ul>
<li><a class="reference internal" href="#oraclecte">改进了Oracle中CTE的支持</a></li>
<li><a class="reference internal" href="#ddloracle">DDL的新Oracle关键字</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar changelog-migration_10" >
        
<section id="sqlalchemy-1-0">
<h1>SQLAlchemy 1.0有哪些新特性？<a class="headerlink" href="#sqlalchemy-1-0" title="Permalink to this heading">¶</a></h1>
<div class="admonition- admonition">
<p class="admonition-title">关于本文档</p>
<p>本文档描述SQLAlchemy 0.9版本至2014年5月维护在进行中的发布
与于2015年4月发布的SQLAlchemy版本1.0之间的更改。</p>
<p>最新更新时间：2015年6月9日</p>
</div>
<section id="id1">
<h2>引言<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>该指南介绍了SQLAlchemy 1.0版本中的新特性，同时记录了影响用户将应用程序从SQLAlchemy 0.9系列迁移到1.0的更改。</p>
<p>请仔细查看行为更改部分，以确定是否存在潜在的不兼容行为更改。</p>
</section>
<section id="orm">
<h2>新功能和改进-ORM<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h2>
<section id="sessioninsert-update-api">
<h3>新的Session批量INSERT/UPDATE API<a class="headerlink" href="#sessioninsert-update-api" title="Permalink to this heading">¶</a></h3>
<p>创建了一系列新的:class:<cite>.Session</cite> 方法，这些方法直接提供了向队列操作单元中的插入和更新语句发送钩子的功能。在正确使用的情况下，这个专家级的系统可以允许ORM-mappings生成批量插入和更新语句，并分组进行执行，以便让这些语句速度与核心的直接使用竞争。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">bulk_operations (批量操作)</span> - 引言和完整文档</p>
</div>
<p><a href="#id2"><span class="problematic" id="id3">:ticket:`3100`</span></a></p>
</section>
<section id="id4">
<h3>新的性能范例套件<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p>受到块操作 (bulk_operations) 特性的基准测试和FAQ的影响，增加了一个新的例子章节，其中包含了几个设计用于说明各种Core和ORM技术的相对性能特征的脚本。这些脚本根据用例进行组织，并打包在单一的控制台接口下，使得可以运行任意组合的演示，以便输出时间，Python概要结果和/或RunSnake概要展示。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">examples_performance (性能示例)</span></p>
</div>
</section>
<section id="id5">
<h3>“烘培”查询<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>“烘培”查询是一种不同寻常的新方法，它允许简单地构造和调用：class:<cite>_query.Query</cite> 对象，使用缓存，每次调用时都使用比Python函数调用开销减少75%以上的方法。通过指定:class:<cite>_query.Query</cite> 对象为一系列仅被调用一次的lambdas，查询作为预编译单元开头的映射变得可行：</p>
<blockquote>
<div><p>from sqlalchemy.ext import baked
from sqlalchemy import bindparam</p>
<p>bakery = baked.bakery()</p>
<dl>
<dt>def search_for_user(session, username, email=None):</dt><dd><p>baked_query = bakery(lambda session: session.query(User))
baked_query += lambda q: q.filter(User.name == bindparam(“username”))</p>
<p>baked_query += lambda q: q.order_by(User.id)</p>
<dl class="simple">
<dt>if email:</dt><dd><p>baked_query += lambda q: q.filter(User.email == bindparam(“email”))</p>
</dd>
</dl>
<p>result = baked_query(session).params(username=username, email=email).all()</p>
<p>return result</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">baked_toplevel</span></p>
</div>
<p><a href="#id6"><span class="problematic" id="id7">:ticket:`3054`</span></a></p>
</section>
<section id="declarative-mixins-declared-attr">
<span id="feature-3150"></span><h3>提高declarative mixins，“&#64;declared_attr”和相关功能<a class="headerlink" href="#declarative-mixins-declared-attr" title="Permalink to this heading">¶</a></h3>
<p>在:class:<a href="#id8"><span class="problematic" id="id9">`</span></a>.declared_attr`与声明式系统联合使用时，支持新的能力进行了重大的改进。</p>
<p>用:class:<a href="#id10"><span class="problematic" id="id11">`</span></a>.declared_attr`装饰的函数现在仅在生成基于冗余的列副本之后才会被调用。这意味着函数可以调用利用冗余建立的列，并将会接收与正确的:class:<a href="#id12"><span class="problematic" id="id13">`</span></a>_schema.Column`对象相关的引用：</p>
<blockquote>
<div><dl>
<dt>class HasFooBar(object):</dt><dd><p>foobar = Column(Integer)</p>
<p>&#64;declared_attr
def foobar_prop(cls):</p>
<blockquote>
<div><p>return column_property(“foobar: “ + cls.foobar)</p>
</div></blockquote>
</dd>
<dt>class SomeClass(HasFooBar, Base):</dt><dd><p>__tablename__ = “some_table”
id = Column(Integer, primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
<p>例如，上面的“SomeClass.foobar_prop”将用于“SomeClass”，而“SomeClass.foobar”将作为最终映射到“SomeClass”的:class:<a href="#id14"><span class="problematic" id="id15">`</span></a>_schema.Column`对象，而不是直接存在于“HasFooBar”上的未复制对象上。</p>
<p>:class:<a href="#id16"><span class="problematic" id="id17">`</span></a>.declared_attr`函数现在**记忆**它以类为基础返回的值，以使得对同一属性的重复调用返回相同的值。我们可以修改以下示例以说明这一点：</p>
<blockquote>
<div><dl>
<dt>class HasFooBar(object):</dt><dd><p>&#64;declared_attr
def foobar(cls):</p>
<blockquote>
<div><p>return Column(Integer)</p>
</div></blockquote>
<p>&#64;declared_attr
def foobar_prop(cls):</p>
<blockquote>
<div><p>return column_property(“foobar: “ + cls.foobar)</p>
</div></blockquote>
</dd>
<dt>class SomeClass(HasFooBar, Base):</dt><dd><p>__tablename__ = “some_table”
id = Column(Integer, primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
<p>以前，“SomeClass”将被映射为某个特定的“foobar”列的一个拷贝，但是无论属性被映射多少次，“foobar_prop”每次调用“foobar”都会生成一个不同的列。在声明式设置时间内，“SomeClass.foobar”的值现在已被记忆下来，因此即使属性被映射器映射之前，中间列值的值始终保持一致，而不管被调用多少次。</p>
<p>以上的两个行为应该有助于很多类型的映射器属性的声明式定义，这些属性可以导出自其他属性，其中:class:<a href="#id18"><span class="problematic" id="id19">`</span></a>.declared_attr`函数在类实际映射之前被本地存在。</p>
<p>对于一种较瘦的特例，希望构建一个声明性mixin，该mixin根据子类分别建立不同的列，添加了一个新的修饰符:attr:<cite>.declared_attr.cascading</cite>。使用这个修饰符，装饰的函数将为映射继承层次结构中的每个类单独调用。尽管这已经是类似于“__table_args__”和“__mapper_args__”等特殊属性的行为，对于默认情况下假定属性仅附加到基类并且只继承自子类的列和其他属性，可以应用单独的行为：</p>
<blockquote>
<div><dl>
<dt>class HasIdMixin(object):</dt><dd><p>&#64;declared_attr.cascading
def id(cls):</p>
<blockquote>
<div><dl class="simple">
<dt>if has_inherited_table(cls):</dt><dd><p>return Column(ForeignKey(“myclass.id”), primary_key=True)</p>
</dd>
<dt>else:</dt><dd><p>return Column(Integer, primary_key=True)</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>class MyClass(HasIdMixin, Base):</dt><dd><p>__tablename__ = “myclass”
# …</p>
</dd>
<dt>class MySubClass(MyClass):</dt><dd><p>“”” “””</p>
<p># …</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">mixin_inheritance_columns</span></p>
</div>
<p>最后，:class:<a href="#id20"><span class="problematic" id="id21">`</span></a>.AbstractConcreteBase`类已经重新进行了改进，以便可以在抽象基类中内联地设置第二个关系或其他映射器属性：</p>
<blockquote>
<div><p>from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import (</p>
<blockquote>
<div><p>declarative_base,
declared_attr,
AbstractConcreteBase,</p>
</div></blockquote>
<p>)</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class Something(Base):</dt><dd><p>__tablename__ = “something”
id = Column(Integer, primary_key=True)</p>
</dd>
<dt>class Abstract(AbstractConcreteBase, Base):</dt><dd><p>id = Column(Integer, primary_key=True)</p>
<p>&#64;declared_attr
def something_id(cls):</p>
<blockquote>
<div><p>return Column(ForeignKey(Something.id))</p>
</div></blockquote>
<p>&#64;declared_attr
def something(cls):</p>
<blockquote>
<div><p>return relationship(Something)</p>
</div></blockquote>
</dd>
<dt>class Concrete(Abstract):</dt><dd><p>__tablename__ = “cca”
__mapper_args__ = {“polymorphic_identity”: “cca”, “concrete”: True}</p>
</dd>
</dl>
</div></blockquote>
<p>上面的映射将设置一个带有“id”和“something_id”列的“cca”表，而“Concrete”还将具有一个名为“something”的关系。新功能是，“Abstract”还将具有针对基础的多态联接的独立配置关系“something”。</p>
<p><a href="#id22"><span class="problematic" id="id23">:ticket:`3150`</span></a> <a href="#id24"><span class="problematic" id="id25">:ticket:`2670`</span></a> <a href="#id26"><span class="problematic" id="id27">:ticket:`3149`</span></a> <a href="#id28"><span class="problematic" id="id29">:ticket:`2952`</span></a> <a href="#id30"><span class="problematic" id="id31">:ticket:`3050`</span></a></p>
</section>
<section id="orm25">
<h3>ORM完整对象获取的速度提高了25%<a class="headerlink" href="#orm25" title="Permalink to this heading">¶</a></h3>
<p>“loading.py”模块的机制以及标识图现在进行了多次内联，重构和裁减，以便使得加载的原始行现在以约快25%的速度填充了基于ORM的对象。假设有一个100万行的表，像下面这样的脚本可以说明被改进了的加载类型：</p>
<blockquote>
<div><p>import time
from sqlalchemy import Integer, Column, create_engine, Table
from sqlalchemy.orm import Session
from sqlalchemy.ext.declarative import declarative_base</p>
<p>Base = declarative_base()</p>
<dl>
<dt>class Foo(Base):</dt><dd><dl class="simple">
<dt>__table__ = Table(</dt><dd><p>“foo”,
Base.metadata,
Column(“id”, Integer, primary_key=True),
Column(“a”, Integer(), nullable=False),
Column(“b”, Integer(), nullable=False),
Column(“c”, Integer(), nullable=False),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>engine = create_engine(“mysql+mysqldb://scott:tiger&#64;localhost/test”, echo=True)</p>
<p>sess = Session(engine)</p>
<p>now = time.time()</p>
<p>#避免使用all()，以便减少一次性处理内存中一大堆完整对象的开销
for obj in sess.query(Foo).yield_per(100).limit(1000000):</p>
<blockquote>
<div><p>pass</p>
</div></blockquote>
<p>print(“总时间：%d” %（time.time() - now））</p>
</div></blockquote>
<p>本地MacBookPro运行19秒的0.9版现在运行14秒的1.0版。当对大量的行进行分批处理时，：meth:<cite>_query.Query.yield_per</cite> 是一个不错的选择，因为它避免了Python解释器一次性分配大量内存以获取所有对象及其指令的开销。没有：meth:<cite>_query.Query.yield_per</cite>，上述脚本在MacBookPro上的0.9版本为31秒，在1.0版本为26秒，额外的时间花费在设置很大的内存缓冲区上。</p>
</section>
<section id="keyedtuple">
<span id="feature-3176"></span><h3>新的KeyedTuple实现速度大大提高<a class="headerlink" href="#keyedtuple" title="Permalink to this heading">¶</a></h3>
<p>我们研究了:class:<a href="#id32"><span class="problematic" id="id33">`</span></a>.KeyedTuple`实现，以期提高以下查询的性能:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">Foo</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">Foo</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>使用:class:<cite>.KeyedTuple`类来替换Python的“collections.namedtuple()”，因为后者具有非常复杂的类型创建过程，而且跑大量的row，``collections.namedtuple()``的benchmark要比:class:</cite>.KeyedTuple`更慢。在获取几十万行时，<a href="#id34"><span class="problematic" id="id35">``</span></a>collections.namedtuple()``很快就超过了：class:<cite>.KeyedTuple</cite>，因为实例调用增加。</p>
<p>该怎么办？一个新型号既兼顾了两种方法的优点。对于“大小”（返回行数）和“编号”（返回不同查询的数量）对所有三个类型进行基准测试，新的“轻量级键值元组”无论是在哪种情况下，都优于另外两种类型，而是基于哪种方案，性能会略有不同:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">sourcecode</span><span class="p">::</span> <span class="n">text</span></pre></div>
</div>
<blockquote>
<div><p>size=10 num=10000                 #少数据多查询
namedtuple: 3.60302400589         # namedtuple 不行（失败了）
keyedtuple: 0.255059957504        # KeyedTuple非常快
lw keyed tuple: 0.582715034485    # lw keyed 比KeyedTuple慢
—————–
size=100 num=1000                 # &lt;—sweet spot
namedtuple: 0.365247011185
keyedtuple: 0.24896979332
lw keyed tuple: 0.0889317989349   #轻量级键值快于KeyedTuple!
—————–
size=10000 num=100
namedtuple: 0.572599887848
keyedtuple: 2.54251694679
lw keyed tuple: 0.613876104355
—————–
size=1000000 num=10               #少查询多数据
namedtuple: 5.79669594765         # namedtuple非常快
keyedtuple: 28.856498003          # KeyedTuple不行
lw keyed tuple: 6.74346804619     #轻量级键值快于namedtuple</p>
</div></blockquote>
<p><a href="#id36"><span class="problematic" id="id37">:ticket:`3176`</span></a></p>
</section>
<section id="feature-slots">
<span id="id38"></span><h3>结构性内存使用的显著改进<a class="headerlink" href="#feature-slots" title="Permalink to this heading">¶</a></h3>
<p>通过为许多内部对象更广泛地使用``__slots__``进行了结构性内存使用的改进。这种优化特别针对具有许多表和列的大型应用程序的基本内存大小，并减少了内存大小，包括事件监听内部，比较器对象和ORM属性等系统的部分。</p>
<p>一个基于heapy的bench可衡量启动时的Nova的大小差异，该bench利用了比应用程序中更大的对象，包括共享字典以及使用的它们的SVN外壳，以及打开的Gunicorn工作器：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#在heapy中报告，SQLAlchemy对象+关联的字典+弱引用相关对象以core of Nova导入为基础占用的总计数和总字节数：

    Before: total count 26477 total bytes 7975712
    After: total count 18181 total bytes 4236456

#报告Python模块空间的总体字节数在core of Nova导入的情况下：

    Before: Partition of a set of 355558 objects. Total size = 61661760 bytes.
    After: Partition of a set of 346034 objects. Total size = 57808016 bytes.</pre></div>
</div>
</section>
<section id="updateexecutemany">
<span id="feature-updatemany"></span><h3>在刷新中，UPDATE语句会使用executemany()批量批处理<a class="headerlink" href="#updateexecutemany" title="Permalink to this heading">¶</a></h3>
<p>UPDATE语句现在可以在ORM flush中批量处理为更高效的executemany()调用，类似于可以批量处理INSERT语句的方式；这将基于以下标准在flush中引发：</p>
<p>● 两个或更多UPDATE语句连续涉及要修改的相同列集合。</p>
<p>● 语句在SET子句中没有嵌入的SQL表达式。</p>
<p>●映射未使用:paramref:~.orm.mapper.version_id_col，或后端方言支持执行executemany()操作的“明确” rowcount；现在大多数DBAPI们都正确支持这个。</p>
</section>
<section id="session-get-bind">
<span id="bug-3035"></span><span id="feature-3178"></span><h3>Session.get_bind()现在可以处理更广泛的继承场景<a class="headerlink" href="#session-get-bind" title="Permalink to this heading">¶</a></h3>
<p>当一个查询或工作单元内的刷新进程试图定位与特定类相对应的数据库引擎时，将调用:meth:<a href="#id39"><span class="problematic" id="id40">`</span></a>.Session.get_bind`方法。方法已经改进，以处理各种面向继承的场景，包括以下：</p>
<p>● 绑定到Mixin或抽象类:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">SomeMixin</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;my_table&quot;</span>
    <span class="c1"># ...</span>


<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">binds</span><span class="o">=</span><span class="p">{</span><span class="n">SomeMixin</span><span class="p">:</span> <span class="n">some_engine</span><span class="p">})</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>● 根据表单独继承的具体子类绑定：</p>
<blockquote>
<div><dl>
<dt>class BaseClass(Base):</dt><dd><p>__tablename__ = “base”</p>
<p># …</p>
</dd>
<dt>class ConcreteSubClass(BaseClass):</dt><dd><p>__tablename__ = “concrete”</p>
<p># …</p>
<p>__mapper_args__ = {“concrete”: True}</p>
</dd>
</dl>
<p>session = Session(binds={base_table: some_engine, concrete_table: some_other_engine})</p>
</div></blockquote>
<p><a href="#id41"><span class="problematic" id="id42">:ticket:`3035`</span></a></p>
</section>
<section id="session-get-bind-mapper">
<span id="bug-3227"></span><h3>Session.get_bind()现在通过所有相关的查询用例接收Mapper<a class="headerlink" href="#session-get-bind-mapper" title="Permalink to this heading">¶</a></h3>
<p>一系列问题已得到修复，之前：meth:<cite>.Session.get_bind`并没有接收到主要的:class:`_orm.Mapper</cite>，即使该映射器是可用的（主要的映射器是单个映射器，或者也可以是第一个映射器，与:class:<cite>_query.Query`对象关联）。这个事情可以像还有一个参数:paramref:</cite>.Session.binds`一样运用到这个问题上，这个参数使映射器与一系列引擎相关联（尽管在这个用例中，即使在映射表对象获得了绑定时，大多数情况下仍会“工作”）。或者更具体地实现用户定义的:meth:<a href="#id43"><span class="problematic" id="id44">`</span></a>.Session.get_bind`方法来提供基于Mapper的一些选择引擎的方式，例如水平分片或所谓的“路由”会话，该会话路由查询到不同的后端。</p>
<p>这几个场景包括：</p>
<p>●:meth:<cite>_query.Query.count</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span></pre></div>
</div>
<dl>
<dt>●:meth:<cite>_query.Query.update`和:meth:`_query.Query.delete</cite>，都是针对UPDATE/DELETE的</dt><dd><p>语句以及由“fetch”策略使用的SELECT：</p>
<blockquote>
<div><dl class="simple">
<dt>session.query(User).filter(User.id == 15).update(</dt><dd><p>{“name”: “foob”}, synchronize_session=”fetch”</p>
</dd>
</dl>
<p>)</p>
<p>session.query(User).filter(User.id == 15).delete(synchronize_session=”fetch”)</p>
</div></blockquote>
</dd>
</dl>
<p>●针对单个列的查询:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>●针对间接映射对象（如:obj:<cite>.column_property</cite>）的SQL函数和其他表达：</p>
<blockquote>
<div><dl>
<dt>class User(Base):</dt><dd><p>…</p>
<p>score = column_property(func.coalesce(self.tables.users.c.name, None))</p>
</dd>
</dl>
<p>session.query(func.max(User.score)).scalar()</p>
</div></blockquote>
<p><a href="#id45"><span class="problematic" id="id46">:ticket:`3227`</span></a> <a href="#id47"><span class="problematic" id="id48">:ticket:`3242`</span></a> <a href="#id49"><span class="problematic" id="id50">:ticket:`1326`</span></a></p>
</section>
<section id="info">
<span id="feature-2963"></span><h3>.info词典改进<a class="headerlink" href="#info" title="Permalink to this heading">¶</a></h3>
<p>现在，<code class="xref py py-attr docutils literal notranslate"><span class="pre">Mapper.all_orm_descriptors`集合中检索的任何类型的对象。这包括：class:</span></code>.hybrid_property`和:func:<cite>.association_proxy</cite>。但是，由于这些对象是类绑定描述符，因此必须**分别**访问这些对象以获取属性。一下使用:attr:<a href="#id51"><span class="problematic" id="id52">`</span></a>_orm.Mapper.all_orm_descriptors`命名空间进行说明：</p>
<blockquote>
<div><dl>
<dt>class SomeObject(Base):</dt><dd><p># …</p>
<p>&#64;hybrid_property
def some_prop(self):</p>
<blockquote>
<div><p>return self.value + 5</p>
</div></blockquote>
</dd>
</dl>
<p>inspect(SomeObject).all_orm_descriptors.some_prop.info[“foo”] = “bar”</p>
</div></blockquote>
<p>它也可用作所有:class:<cite>.SchemaItem`对象（例如:class:`_schema.ForeignKey</cite>，<code class="xref py py-class docutils literal notranslate"><span class="pre">synonym</span></code>）的构造函数参数。</p>
<p><a href="#id53"><span class="problematic" id="id54">:ticket:`2971`</span></a></p>
<p><a href="#id55"><span class="problematic" id="id56">:ticket:`2963`</span></a></p>
</section>
<section id="columnpropertyorder-by">
<span id="bug-3188"></span><h3>ColumnProperty结构与别名以及order_by较好地生成<a class="headerlink" href="#columnpropertyorder-by" title="Permalink to this heading">¶</a></h3>
<p>已经修复了有关:func:<cite>.column_property`的各种问题，最具体的问题是与：func:</cite>.aliased`构造以及在0.9中引入的“order by label”的逻辑有关（参见：ref :<cite>migration_1068</cite>）。</p>
<p>给定以下映射:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;a.id&quot;</span><span class="p">))</span>


<span class="n">A</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">column_property</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">a_id</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">A</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>简单的情况下” A.b “出现两次将无法正确渲染:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">print</span><span class="p">(</span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">b</span><span class="p">))</span></pre></div>
</div>
<p>这将会排序错误的列：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">max</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">max_1</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">b</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span><span class="w"> </span><span class="n">a_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_1_id</span><span class="p">,</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">max</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">max_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_1</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span></pre></div>
</div>
<p>现在的输出是</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">max</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">max_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span><span class="w"> </span><span class="n">a_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_1_id</span><span class="p">,</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">max</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">max_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_1</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_2</span></pre></div>
</div>
<p>“order by标签”的各种场景也会存在排序失败的问题，例如如果映射是“多态性”的话：</p>
<blockquote>
<div><dl>
<dt>class A(Base):</dt><dd><p>__tablename__ = “a”</p>
<p>id = Column(Integer, primary_key=True)
type = Column(String)</p>
<p>__mapper_args__ = {“polymorphic_on”: type, “with_polymorphic”: “*”}</p>
</dd>
</dl>
</div></blockquote>
<p>在标签上命名的排序会标记失败，例如给定以下查询：：</p>
<blockquote>
<div><p>print(sess.query(A).filter(A.type == “foo”).order_by(A.b))</p>
</div></blockquote>
<p>现在会正确地按标记排序：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_id</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">type</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">a_type</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">max</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">max_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">a_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">a</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span></pre></div>
</div>
<p>这些问题的包括各种heisenbug，可能会破坏“aliased()”构造的状态，使标记逻辑再次失效；这些均已得到修复。</p>
<p><a href="#id57"><span class="problematic" id="id58">:ticket:`3148`</span></a> <a href="#id59"><span class="problematic" id="id60">:ticket:`3188`</span></a></p>
</section>
</section>
<section id="core">
<h2>新功能和改进-Core<a class="headerlink" href="#core" title="Permalink to this heading">¶</a></h2>
<section id="limit-offsetsql">
<span id="feature-3034"></span><h3>选择/查询LIMIT/OFFSET可以指定为任意的SQL表达式<a class="headerlink" href="#limit-offsetsql" title="Permalink to this heading">¶</a></h3>
<p>现在，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.limit" title="sqlalchemy.sql.expression.Select.limit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.limit()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.offset" title="sqlalchemy.sql.expression.Select.offset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.offset()</span></code></a> 方法接受任何SQL表达式作为参数，同时也适用于ORM:class:<a href="#id61"><span class="problematic" id="id62">`</span></a>_query.Query`对象。通常，这通常用于允许通过绑定参数传递完整SQL表达式，稍后可以将该参数替换为一个值：</p>
<blockquote>
<div><p>sel = select([table]).limit(bindparam(“mylimit”)).offset(bindparam(“myoffset”))</p>
</div></blockquote>
<p>不支持非整数LIMIT或OFFSET表达式的方言可能继续不支持这种行为。比第三方方言可能需要修改以便利用新的行为。目前使用“._limit”或“._offset”属性的方言将在访问这两个属性时继续为指定为简单整数值的限制/偏移量。如果指定了SQL表达式，则这两个属性将在访问时抛出一个:class:<cite>.CompileError</cite>。如果第三方方言希望支持新功能，它应该现在调用``._limit_clause``和``._offset_clause``属性来获取完整的SQL表达式，而不是整数值。</p>
</section>
<section id="use-alter">
<span id="feature-3282"></span><h3>除了在生成整体性的外键约束时指定use_alter标志外<a class="headerlink" href="#use-alter" title="Permalink to this heading">¶</a></h3>
<p>现在，<code class="xref py py-meth docutils literal notranslate"><span class="pre">ForeignKeyConstraint.use_alter()</span></code>。此外，外键约束现在不需要名称即可通过ALTER创建；只需要在DROP操作中需要名称。在DROP的情况下，如果没有名称，这个功能将确保只有显式名称的约束才会实际上包括在ALTER语句中。在不存在可解决的循环的情况下执行DROP，如果DROP无法继续，则该功能会输出简明和清晰的错误信息。</p>
<p>:paramref:<a href="#id63"><span class="problematic" id="id64">`</span></a>_schema.ForeignKeyConstraint.use_alter`和:paramref:<a href="#id65"><span class="problematic" id="id66">`</span></a>_schema.ForeignKey.use_alter`标志仍然存在，并且继续具有相同的效果来确定需要ALTER的约束，例如在CREATE/DROP场景中需要的约束。</p>
<p>从版本1.0.1开始，在SQLite的情况下，特殊逻辑会接管，如果在DROP过程中给定表存在一个无法解决的循环，则发出警告，而表已按**无序**排列删除，这通常对于SQLite来说是可以的，除非启用了约束。要解决警告并在SQLite数据库上进行至少部分排序，特别是在启用了约束的SQLite数据库上进行至少部分排序，请将“use_alter”标志重新应用于那些应显式省略拍摄的:class:<cite>_schema.ForeignKey`和:class:</cite>.ForeignKeyConstraint`对象。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">use_alter</span>-全新行为的完整描述。</p>
</div>
<p><a href="#id67"><span class="problematic" id="id68">:ticket:`3282`</span></a></p>
</section>
<section id="resultproxy">
<span id="change-3330"></span><h3>ResultProxy的“自动关闭”现在是“软关闭”<a class="headerlink" href="#resultproxy" title="Permalink to this heading">¶</a></h3>
<p>多个版本中，<a href="#id69"><span class="problematic" id="id70">:类:`_engine.ResultProxy`对象始终在提取所有结果行时自动关闭。这是为了允许在不需要显式“调用:meth:`_engine.ResultProxy.close`的情况下`使用对象；由于所有DBAPI资源都已被释放，该对象是安全的，可以丢弃。然而，对象保持严格的“关闭”状态，这意味着任何:meth:`_engine.ResultProxy.fetchone`</span></a>,`_engine.ResultProxy.fetchmany`或:meth:<cite>_engine.ResultProxy.fetchall`的后续调用都会引发</cite>:.ResourceClosedError`：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">(1, &#39;x&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">None  # indicates no more rows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">exception: ResourceClosedError</span></pre></div>
</div>
<p>这个行为与pep-249中的描述不一致，pep-249（Python的DBAPI接口）认为即使在结果已用完的情况下，也可以反复调用fetch方法。它也干扰了某些实现的result proxy的行为，如cy_oracle方言使用的:class:<cite>.BufferedColumnResultProxy</cite>。</p>
<p>为了解决这个问题，“关闭”的状态已经</p>
<p>被拆分为两个状态；”soft close” 和 “closed”。
“soft close”会释放DBAPI游标和连接，”close with result”对象将释放连接，但不会影响cursor。
:meth:<a href="#id71"><span class="problematic" id="id72">`</span></a>_engine.ResultProxy.close`不再被隐式调用，只有:meth:<a href="#id73"><span class="problematic" id="id74">`</span></a>_engine.ResultProxy._soft_close`被非公开地调用：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">(1, &#39;x&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">None  # 表示没有更多的数据</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">None  # 仍然是None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="go">异常: ResourceClosedError  # 现在会抛出这个异常</span></pre></div>
</div>
</section>
<section id="check-column-0-name">
<h3>CHECK约束现在支持命名约定中的”column_0_name”标记<a class="headerlink" href="#check-column-0-name" title="Permalink to this heading">¶</a></h3>
<p>“column_0_name”将从:class:<a href="#id75"><span class="problematic" id="id76">`</span></a>.CheckConstraint`表达式的第一个列派生:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ck&quot;</span><span class="p">:</span> <span class="s2">&quot;ck_</span><span class="si">%(table_name)s</span><span class="s2">_</span><span class="si">%(column_0_name)s</span><span class="s2">&quot;</span><span class="p">})</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>

<span class="n">CheckConstraint</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>将生成：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span>
<span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">ck_foo_value</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>此命名约定结合:class:<cite>.Boolean`或:class:</cite>.Enum`等:class:<a href="#id77"><span class="problematic" id="id78">`</span></a>.SchemaType`约束的约束也将使用所有CHECK约束约定。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/constraints.html#naming-check-constraints"><span class="std std-ref">命名CHECK约束</span></a></p>
<p><span class="xref std std-ref">naming_schematypes</span></p>
</div>
<p><a href="#id79"><span class="problematic" id="id80">:ticket:`3299`</span></a></p>
</section>
<section id="change-3341">
<span id="id81"></span><h3>引用未附加列的约束可以在列关联到表时自动附加到表上<a class="headerlink" href="#change-3341" title="Permalink to this heading">¶</a></h3>
<p>从版本0.8开始，<code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">UniqueConstraint</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>

<span class="n">uq</span> <span class="o">=</span> <span class="n">UniqueConstraint</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># 将自动附加到表</span>

<span class="k">assert</span> <span class="n">uq</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">constraints</span></pre></div>
</div>
<p>为了帮助声明式产生的某些情况，即使 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象尚未关联到 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 中，也可以让此自动附加逻辑执行；指定了附加到 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Constraint" title="sqlalchemy.schema.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constraint</span></code></a> 的列时，当 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象关联到 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 后， <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Constraint" title="sqlalchemy.schema.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constraint</span></code></a> 也会被添加:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">UniqueConstraint</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>

<span class="n">uq</span> <span class="o">=</span> <span class="n">UniqueConstraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">uq</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">constraints</span>  <span class="c1"># constraint自动附加</span></pre></div>
</div>
<p>以上功能是自1.0.0b3版本后的一个过晚的补丁。1.0.4版本的修复脚本为:ticket:<cite>3411</cite>。
如果约束引用了一组混合类型的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象和字符串列名，则忽略此逻辑。
因为我们尚未对:class:<a href="#id82"><span class="problematic" id="id83">`</span></a>_schema.Table`上的名称添加进行跟踪:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">UniqueConstraint</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>

<span class="n">uq</span> <span class="o">=</span> <span class="n">UniqueConstraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># 约束不会自动附加，因为我们没有跟踪任何情况</span>
<span class="c1"># 能够定位名称&#39;b&#39;在哪个时刻在表上可用</span>
<span class="k">assert</span> <span class="n">uq</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">constraints</span></pre></div>
</div>
<p>以上,列”a”被显式声明，但列”b”尚未显式声明；因此，在查询列”a”附加到表”t”之后，
查询不知道何时olumn “b”将被附加，约束将无法获取”b”，因此将不会进行自动附加的操作。因此，
如果约束使用任何字符串名称，则跳过自动添加-on-column-attach逻辑。</p>
<p>如果在:class:<a href="#id84"><span class="problematic" id="id85">`</span></a>_schema.Table`上下文中已经存在所需的 :class:<a href="#id86"><span class="problematic" id="id87">`</span></a>_schema.Column`对象，则原始的自动附加逻辑仍然适用。</p>
<blockquote>
<div><p>from sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint</p>
<p>m = MetaData()</p>
<p>a = Column(“a”, Integer)
b = Column(“b”, Integer)</p>
<p>t = Table(“t”, m, a, b)</p>
<p>uq = UniqueConstraint(a, “b”)</p>
<p># 约束自动附加，与较旧的版本相同
assert uq in t.constraints</p>
</div></blockquote>
<p><a href="#id88"><span class="problematic" id="id89">:ticket:`3341`</span></a>
<a href="#id90"><span class="problematic" id="id91">:ticket:`3411`</span></a></p>
</section>
<section id="insert-from-select-pythonsql">
<span id="feature-insert-from-select-defaults"></span><span id="change-2051"></span><h3>“INSERT FROM SELECT”现在包括Python和SQL表达式默认值<a class="headerlink" href="#insert-from-select-pythonsql" title="Permalink to this heading">¶</a></h3>
<p>现在，即使另有说明，:meth:<a href="#id92"><span class="problematic" id="id93">`</span></a>_expression.Insert.from_select`也会包括Python和SQL表达式默认值。
此前，约束并未包括在”INSERT FROM SELECT”中的默认值。</p>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">somefunction</span><span class="p">())</span>
<span class="p">)</span>

<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
<span class="n">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">from_select</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">stmt</span><span class="p">))</span></pre></div>
</div>
<p>将生成：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">somefunction</span><span class="p">()</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">somefunction_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">t</span></pre></div>
</div>
<p>可以使用:paramref:<a href="#id94"><span class="problematic" id="id95">`</span></a>.Insert.from_select.include_defaults`禁用此功能。</p>
<p><a href="#id96"><span class="problematic" id="id97">:ticket:`3184`</span></a></p>
</section>
<section id="column-server-defaults">
<h3>Column Server Defaults现在呈现为文字值<a class="headerlink" href="#column-server-defaults" title="Permalink to this heading">¶</a></h3>
<p>现在，在需要编译SQL表达式时，如果 :class:<a href="#id98"><span class="problematic" id="id99">`</span></a>.DefaultClause`设置的值是一个文字值，编译器会打开”literal binds”编译器标志。这使得嵌入到SQL中的文字值能够被编译器正确呈现，例如：</p>
<blockquote>
<div><p>from sqlalchemy import Table, Column, MetaData, Text
from sqlalchemy.schema import CreateTable
from sqlalchemy.dialects.postgresql import ARRAY, array
from sqlalchemy.dialects import postgresql</p>
<p>metadata = MetaData()</p>
<dl class="simple">
<dt>tbl = Table(</dt><dd><p>“derp”,
metadata,
Column(“arr”, ARRAY(Text), server_default=array([“foo”, “bar”, “baz”])),</p>
</dd>
</dl>
<p>)</p>
<p>print(CreateTable(tbl).compile(dialect=postgresql.dialect()))</p>
</div></blockquote>
<p>现在呈现：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">derp</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">arr</span><span class="w"> </span><span class="nb">TEXT</span><span class="p">[]</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="nb">ARRAY</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;bar&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;baz&#39;</span><span class="p">]</span>
<span class="p">)</span></pre></div>
</div>
<p>以前，文字值”foo”、“bar”和“baz”将呈现为绑定参数，这在DDL中是无用的。</p>
<p><a href="#id100"><span class="problematic" id="id101">:ticket:`3087`</span></a></p>
</section>
<section id="uniqueconstraint">
<span id="feature-3184"></span><h3><a href="#id102"><span class="problematic" id="id103">``</span></a>UniqueConstraint``现在是数据表反射过程的一部分<a class="headerlink" href="#uniqueconstraint" title="Permalink to this heading">¶</a></h3>
<p>使用``autoload=True``填充的:class:<cite>_schema.Table`对象现在将包括:class:</cite>.UniqueConstraint`和:class:<a href="#id104"><span class="problematic" id="id105">`</span></a>.Index`结构。 这对于PostgreSQL和MySQL有一些注意事项：</p>
<section id="postgresql">
<h4>PostgreSQL<a class="headerlink" href="#postgresql" title="Permalink to this heading">¶</a></h4>
<p>PostgreSQL的行为是这样的，当创建UNIQUE约束时，它隐含地同时创建了一个对应的唯一的索引。<code class="xref py py-meth docutils literal notranslate"><span class="pre">.,</span> <span class="pre">autoload=True)`()</span></code>
执行完整的表反射时， <code class="xref py py-class docutils literal notranslate"><span class="pre">Index`结构被检测到是与:class:</span></code>.UniqueConstraint`构造有关的，因此不会出现 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.indexes" title="sqlalchemy.schema.Table.indexes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.indexes</span></code></a>，只有:class:<cite>.UniqueConstraint`出现在 :attr:`_schema.Table.constraints</cite> 中。这种去重逻辑通过加入到查询”pg_index”时连接”pg_constraint”表来完成。</p>
</section>
<section id="mysql">
<h4>MySQL<a class="headerlink" href="#mysql" title="Permalink to this heading">¶</a></h4>
<p>MySQL在没有可区分UNIQUE索引和UNIQUE约束的概念。虽然在创建表和索引时支持这两种语法，但实际上不会对它们进行任何不同的存储。<code class="xref py py-meth docutils literal notranslate"><span class="pre">.,</span> <span class="pre">autoload=True)`()</span></code> 执行完整的表反射时，无论什么情况下，<code class="xref py py-class docutils literal notranslate"><span class="pre">Table`对象的一部分;该结构始终由</span> <span class="pre">:class:</span></code>.Index` 表示， <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.indexes" title="sqlalchemy.schema.Table.indexes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.indexes</span></code></a> 中存在包含“unique=True”的设置。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-index-reflection"><span class="std std-ref">PostgreSQL Index Reflection</span></a></p>
<p><a class="reference internal" href="../dialects/mysql.html#mysql-unique-constraints"><span class="std std-ref">MySQL / MariaDB Unique Constraints and Reflection</span></a></p>
</div>
<p><a href="#id106"><span class="problematic" id="id107">:ticket:`3184`</span></a></p>
</section>
</section>
<section id="id108">
<h3>新系统安全发出参数化警告<a class="headerlink" href="#id108" title="Permalink to this heading">¶</a></h3>
<p>长期以来，警告消息不能引用数据元素，这意味着某个特定函数可能会发出一个无限数量的唯一警告消息。 :class:<a href="#id109"><span class="problematic" id="id110">`</span></a>.Unicode`类型部分中的警告消息”Unicode type received non-unicode bind param value”就是这个问题的例子。将数据值放入该消息中将意味着在Python “__warningregistry__”中记录的模块，或在某些情况下是Python全局”warnings.onceregistry”中记录的模块，会不断增加新的unique警告消息。</p>
<p>这个改变在实际使用中利用了一个特殊的”string”类型，该类型有意改变了字符串的哈希方式，使得大量参数化消息仅使用一小组可能的哈希值进行哈希，以便例如”Unicode type received non-unicode bind param value”警告可被定制地仅限制发送一定数量的次数; 不再发送新的警告。因此，在执行此类操作时，您可能会看到以下警告:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: Got None for value of column user.id; this is unsupported
  for a relationship comparison and will not currently produce an
  IS comparison (but may in a future release)</pre></div>
</div>
<p>请注意，这种模式在大多数情况下已经被破坏了，特别是当我们没有将值发送到ORM中时，即没有设置属性，则 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> 等类似类型不再将通知我们。如果您的应用程序依赖于”NULL = NULL”在所有情况下都失败的事实，并且运行风险较高，则应该检查 :ticket:<a href="#id111"><span class="problematic" id="id112">`</span></a>3178`的解决方案。</p>
<p><a href="#id113"><span class="problematic" id="id114">:ticket:`3178`</span></a></p>
</section>
</section>
<section id="key-behavioral-changes-orm">
<h2>Key Behavioral Changes - ORM<a class="headerlink" href="#key-behavioral-changes-orm" title="Permalink to this heading">¶</a></h2>
<section id="meth-query-query-update">
<span id="bug-3228"></span><h3>：meth:<a href="#id115"><span class="problematic" id="id116">`</span></a>_query.Query.update`现在可以将字符串名称解析为映射属性名称<a class="headerlink" href="#meth-query-query-update" title="Permalink to this heading">¶</a></h3>
<p>方法:meth:<a href="#id117"><span class="problematic" id="id118">`</span></a>_query.Query.update`的文档说明指示给定的”values”字典是”一个使用属性名称为key的字典”，这暗示这些都是映射属性名称。 但不幸的是，该函数的设计更多考虑了属性和SQL表达式，而没有考虑字符串; 当字符串被传递时，这些字符串将直接通过，进入核心更新语句，而不考虑这些名称在映射类中的表示方式，这意味着该名称必须完全匹配表列，而不是该名称映射到该类上的属性名称。</p>
<p>现在，字符串名称已经解析为属性名称:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>上面是一个映射，其中列”user_name”映射为”name”。 以前，在:meth:<a href="#id119"><span class="problematic" id="id120">`</span></a>_query.Query.update`中传递字符串名称，必须这样写:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;user_name&quot;</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre></div>
</div>
<p>现在，传递的字符串将根据实体解析为属性名称:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre></div>
</div>
<p>通常最好直接使用属性，以避免任何模棱两可:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre></div>
</div>
<p>此更改还表示， 同义词和混合属性也可以通过字符串名称引用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="nd">@hybrid_property</span>
    <span class="k">def</span> <span class="nf">fullname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p><a href="#id121"><span class="problematic" id="id122">:ticket:`3228`</span></a></p>
</section>
<section id="none">
<span id="bug-3371"></span><h3>在将带有None值的对象与关系比较时发出警告<a class="headerlink" href="#none" title="Permalink to this heading">¶</a></h3>
<p>此更改是从1.0.1开始的新更改，一些用户正在执行基本上是这种形式的查询：</p>
<blockquote>
<div><p>session.query(Address).filter(Address.user == User(id=None))</p>
</div></blockquote>
<p>这种模式在SQLAlchemy中目前不受支持。对于所有版本，在查询标量或一对多关系时，如果尚未设置该值，则将返回“None”值。</p>
<p>例如，考虑上面定义的两个映射，一对多关系将定义如下：</p>
<blockquote>
<div><dl class="simple">
<dt>class User(Base):</dt><dd><p>__tablename__ = “user”
id = Column(Integer, primary_key=True)
addresses = relationship(“Address”, backref=”user”)</p>
</dd>
<dt>class Address(Base):</dt><dd><p>__tablename__ = “address”
id = Column(Integer, primary_key=True)
user_id = Column(Integer, ForeignKey(User.id))
email_address = Column(String)</p>
</dd>
</dl>
</div></blockquote>
<p>现在，如果链接到一个User对象，然后执行：</p>
<blockquote>
<div><p>session.query(Address).filter(Address.user == User(id=None))</p>
</div></blockquote>
<p>在所有版本中，将发出SQL语句：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">(</span><span class="k">None</span><span class="p">,)</span></pre></div>
</div>
<p>请注意，上述模式一直不符合SQL语义。 “WHERE？= address.user_id”类似于“WHERE NULL = address.user_id”，这不论如何都将产生“FALSE”。 此模式已经破坏了大多数情况，因为在关系数据库中，“缺失值”通常被视为NULL 。一个单独的模式是比如：：func:<cite>~sqlalchemy.sql.expression.or_</cite> (<cite>Address.user_id`==None，`Address.user``==``None</cite>)</p>
<p>但仍然有某些人知道这种模式，因为它可能已经存在于许多年前的某个应用项目中。 仍然支持此查询模式，但是现在会出现警告:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: Got None for value of column user.id; this is unsupported
for a relationship comparison and will not currently produce an
IS comparison (but may in a future release)</pre></div>
</div>
<p><a href="#id123"><span class="problematic" id="id124">:ticket:`3371`</span></a></p>
</section>
<section id="containsequals">
<span id="bug-3374"></span><h3>“否定contains或equals”关系比较将使用属性的当前值而不是数据库值<a class="headerlink" href="#containsequals" title="Permalink to this heading">¶</a></h3>
<p>此更改从1.0.1开始。现在，在查询将关系定向到目标对象的情况下，将动态地返回每次访问的默认返回值，而不是在首次访问时隐式设置属性状态，调用一个“设置”函数。上面的更改可见的结果是此时不再在__dict__对象上隐式修改值，并且与 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.attributes.get_history" title="sqlalchemy.orm.attributes.get_history"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_history()</span></code></a> 和相关函数的历史上也存在一些小行为变化。</p>
<p>给出一个没有状态的对象：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span></pre></div>
</div>
<p>如果我们访问一个未设置过的标量或一对多属性，SQLAlchemy的行为始终是返回“None”：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">someattr</span>
<span class="go">None</span></pre></div>
</div>
<p>实际上，这个“None”的值现在是该对象的状态的一部分，并且类似于专门设置属性，例如“obj.someattr = None”。但是，“get”操作的“set on get”行为在历史和事件方面会有所不同。当首次调用“get”并返回“None”时，不会发出任何属性事件。另外，如果查看历史记录，则会发现：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">someattr</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=(), unchanged=[None], deleted=())  # 0.9</span></pre></div>
</div>
<p>意思是属性始终为“None”，从未更改过。这是明确不同的，如果首先设置了该属性：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">someattr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">someattr</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=[None], unchanged=(), deleted=())  # 极旧的版本和最新版本都相同</span></pre></div>
</div>
<p>以上意味着，在要求“get”操作时存在使属性事件出现的不一致性。无论
将 None 值设置到属性上还是其他值，取决于 get 操作的表现方式。既而，对于一个“set”操作，现在永远不会实际上设置属性原本的“默认值”了。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">someattr</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">someattr</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=(), unchanged=(), deleted=())  # 1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">someattr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">someattr</span><span class="o">.</span><span class="n">history</span>
<span class="go">History(added=[None], unchanged=(), deleted=())</span></pre></div>
</div>
<p>上面所说的行为意味着，在“set”操作在关系上属性取代的情况下，始终会使用默认操作，而不是赋值操作，如果 None 也是值之一。</p>
</section>
</section>
<section id="id125">
<h2>主要变更 - 流程管理<a class="headerlink" href="#id125" title="Permalink to this heading">¶</a></h2>
<section id="query-update">
<span id="id126"></span><h3>query.update()现在解析字符串名称以映射属性名称<a class="headerlink" href="#query-update" title="Permalink to this heading">¶</a></h3>
<p>:meth:<a href="#id127"><span class="problematic" id="id128">`</span></a>_query.Query.update`的文档说明指出，给定的“values”字典是“一个使用属性名称为键的字典”，这暗示这些都是映射属性名称。 :meth:<a href="#id129"><span class="problematic" id="id130">`</span></a>_query.Query.update`的设计更多考虑了属性和SQL表达式，而不是字符串; 当字符串被传递时，这些字符串将直接通过核心更新语句，而不考虑这些名称在映射类中的表示方式，这意味着，该名称必须完全匹配表列，而不是该名称映射到该类上的属性名称。</p>
<p>现在，字符串名称已经解析为属性名称:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>邮件中指出，在 <a class="reference internal" href="../orm/queryguide/query.html#sqlalchemy.orm.Query.update" title="sqlalchemy.orm.Query.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.update()</span></code></a> 中传递字符串名称，必须这样写:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;user_name&quot;</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre></div>
</div>
<p>现在，传递的字符串将解析为属性名称:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre></div>
</div>
<p>通常地，建议直接使用属性来避免模棱两可的情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre></div>
</div>
<p>此更改还表示,synonyms和混合属性也可以按字符串名称引用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="nd">@hybrid_property</span>
    <span class="k">def</span> <span class="nf">fullname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fullname&quot;</span><span class="p">:</span> <span class="s2">&quot;moonbeam&quot;</span><span class="p">})</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p><a href="#id131"><span class="problematic" id="id132">:ticket:`3228`</span></a></p>
</section>
<section id="id133">
<span id="id134"></span><h3>当将对象与None值进行比较时发出警告<a class="headerlink" href="#id133" title="Permalink to this heading">¶</a></h3>
<p>这个改动从1.0.1开始。对于长时间以来的查询行为状态在:ref:<a href="#id135"><span class="problematic" id="id136">`</span></a>migration_3060`中被说明，对于一对多/多对一关系，设置关系绑定属性，可以覆盖为外键所设置的值。 建议使用传统的单列 NULL 值来列出这个模式。 但是，此更改仍支持此查询模式，但是现在会出现警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: Got None for value of column user.id; this is unsupported
for a relationship comparison and will not currently produce an
IS comparison (but may in a future release)</pre></div>
</div>
<p><a href="#id137"><span class="problematic" id="id138">:ticket:`3371`</span></a></p>
</section>
<section id="id139">
<span id="id140"></span><h3>已删除的对象全部深度解绑过程已更正<a class="headerlink" href="#id139" title="Permalink to this heading">¶</a></h3>
<p>此浅实例在:meth:<cite>.Session.expunge`中存在缺陷，导致在删除对象时出现一致性问题。即使在解绑之后，函数：func:</cite>.object_session`和:attr:<cite>.InstanceState.session`属性仍然会将对象视为属于 :class:</cite>.Session` 。</p>
<blockquote>
<div><p>assert inspect(u1).session is sess  #提交之前正常</p>
<p>sess.expunge(u1)</p>
<p>assert u1 not in sess
assert inspect(u1).session is None  #失败！</p>
</div></blockquote>
<p>请记住，“u1 not in sess”为True，而“inspect（u1）.session”仍然引用会话，同时删除操作之后的事务尚未进行完全脱离；通常，在提交事务后，完全分离会话。 这个问题也会影响使用“Session.expunge”的函数，例如“make_transient”。</p>
<p>看到“[链接名]：（..路径）”，不要修改英文的冒号！请区分术语和说明文本，不用翻译术语。不要破坏python sphinx文档相关语法标记。非常重要的是，不要将原文的标点符号转换成中文标点符号！</p>
<p>:ticket：<code class="docutils literal notranslate"><span class="pre">3139</span></code></p>
<p id="migration-yield-per-eager-loading">当使用yield_per时，禁止显式使用Joined/Subquery eager loading + 嵌套加载
————————————————– —————-</p>
<p>为了使:meth:<cite>_query.Query.yield_per`方法更容易使用，如果任何子查询急加载器，
或将使用集合的连接急加载器
在使用yield-per时生效，则会引发异常，因为这些当前不兼容
具有yield-per的急加载（子查询可以在理论上设置）。当
引发此错误时，可以将：func：</cite>.lazyload`选项发送到带有
asterisk</p>
<p>    q = sess.query(Object).options(lazyload（“*”）).yield_per(100)</p>
<p>或使用：meth:<cite>_query.Query.enable_eagerloads</cite></p>
<p>    q = sess.query(Object).enable_eagerloads(False).yield_per(100)</p>
<p>：func：<a href="#id141"><span class="problematic" id="id142">`</span></a>.lazyload`选项的优点是仍然可以使用附加的多对一
加入的装载程序选项:</p>
<p>    q = (
        sess.query（Object）
        .options（lazyload（“*”），joinedload（“some_manytoone”））
        .yield_per(100)
    )</p>
<p id="bug-3233">重复的连接采取措施的更改和修复
————————————————– ——-</p>
<p>此处的更改包括加入一个实体时，在没有基于关系的ON子句的情况下添加到同一表格或多个单表实体中的某些场景中
连接两次，以及连接多次到相同的目标关系。</p>
<p>从以下映射开始：：</p>
<p>    from sqlalchemy import Integer，Column，String，ForeignKey
    from sqlalchemy.orm import Session，relationship
    from sqlalchemy.ext.declarative import declarative_base</p>
<p>    Base = declarative_base（）</p>
<p>    class A（Base）：
        __tablename__ =“a”
        id = Column（Integer，primary_key = True）
        bs = relationship（“B”）</p>
<p>    class B（Base）：
        __tablename__ =“b”
        id = Column（Integer，primary_key = True）
        a_id =列（ForeignKey（“a.id”））</p>
<p>加入“A.bs”两次的查询：：</p>
<p>    print（s.query（A）。join（A.bs）。join（A.bs））</p>
<p>将呈现：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span></pre></div>
</div>
<p>    SELECT a.id AS a_id
    FROM a JOIN b ON a.id = b.a_id</p>
<p>该查询去重了冗余的“A.bs”，因为它试图支持以下情况之一：：func：<cite>.make_transient</cite></p>
<p>    s.query（A）。join（A.bs）。filter（B.foo ==“bar”）。reset_joinpoint（）。join（A.bs，B.cs）。filter（
        C.bar ==“bat”
    ））</p>
<p>也就是说，“A.bs”是“路径”的一部分。随着：ticket：<a href="#id143"><span class="problematic" id="id144">`</span></a>3367`到到达相同的终点点两次而不是
在较大的路径中，现在将产生警告：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span></pre></div>
</div>
<p>    SAWarning：路径连接目标A.bs已经被连接;跳过</p>
<p>更大的变化涉及当连接到一个实体时，在不使用
ON绑定路径。如果我们两次连接到“B”：</p>
<p>    打印（s.query（A）.join（B，B.a_id == A.id）。join（B，B.a_id == A.id））</p>
<p>在0.9中，这将呈现如下：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span></pre></div>
</div>
<p>    SELECT a.id AS a_id
    FROM a JOIN b ON b.a_id = a.id JOIN b AS b_1 ON b_1.a_id = a.id</p>
<p>这是有问题的，因为隐式别名是隐含的，并且在不
在不同的ON子句中的情况下产生不可预测的结果。</p>
<p>在1.0中，不会自动应用别名，并且我们得到：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span></pre></div>
</div>
<p>    SELECT a.id AS a_id
    FROM a JOIN b ON b.a_id = a.id JOIN b ON b.a_id = a.id</p>
<p>这将从数据库中抛出错误。虽然它可能很好
如果“重复连接目标”在我们从冗余关系vs中连接到两个对象时执行相同的操作
重复的非关系目标时，现在我们仅在更严重的情况下更改行为，其中
以前发生了隐式别名，而只对关系的情况进行警告。最终，在所有情况下，连接到同一个对象两次而不需要任何别名以进行消歧义的行为应该引发错误。</p>
<p>更改还影响单表继承目标。使用
以下映射：</p>
<p>    from sqlalchemy import Integer，Column，String，ForeignKey
    from sqlalchemy.orm import Session，relationship
    from sqlalchemy.ext.declarative import declarative_base</p>
<p>    Base = declarative_base（）</p>
<p>    class A（Base）：
        __tablename__ =“a”</p>
<p>        id = Column（Integer，primary_key = True）
        type = Column（String）</p>
<p>        __mapper_args__ = {“polymorphic_on”：type，“polymorphic_identity”：“a”}</p>
<p>    class ASub1(A)：
        __mapper_args__ = {“polymorphic_identity”：“asub1”}</p>
<p>    class ASub2（A）：
        __mapper_args__ = {“polymorphic_identity”：“asub2”}</p>
<p>    class B(Base)：
        __tablename__ =“b”</p>
<p>        id = Column（Integer，primary_key = True）</p>
<p>        a_id =列（Integer，ForeignKey（“a.id”））</p>
<p>        a = relationship（“A”,primaryjoin =“B.a_id == A.id”, backref =“b”）</p>
<p>    s = Session（）</p>
<p>    print（s.query（ASub1）。join（B，ASub1.b）。join（ASub2，B.a））</p>
<p>    print（s.query（ASub1）。join（B，ASub1.b）。join（ASub2，ASub2.id == B.a_id））</p>
<p>底部的两个查询等效，并且应该同时呈现相同的SQL 中Text嵌套的总数在ORM而不是Core表达式语言中递增。为此，应该使用函数：func：<cite>sa.orm.load_only</cite>：</p>
<p>    print（s.query（A.id，A.name，A.nickname，A.ordercount，
        B.id，B.name）。            join（A.b）.join（B，B.id == A.id）。            options（load_only（“name”））.join（B.c）            .all（））</p>
<p>单独使用” load_only”对于PostgreSQL来说并不是一个好的主意，因为它通常在客户端和服务器之间包装结果组，并且包装后的列名称已经被&quot; as&quot;重新命名，这会变成：SELECT <a href="#id249"><span class="problematic" id="id250">anon_1.some_name_</span></a> AS some_name_1，而不是：SELECT <a href="#id251"><span class="problematic" id="id252">some_name_</span></a>，可重载的SELECT之后，因此不一定会在结果组之后到达客户端。</p>
<p>。。 _migration_3222：</p>
</section>
<section id="on">
<h3>单表继承类型的所有ON子句都被添加到条件语句中<a class="headerlink" href="#on" title="Permalink to this heading">¶</a></h3>
<p>当连接到单表继承子类目标时，ORM总是添加了“单一表”条件，当连接关系时。
从以下映射开始：：</p>
<p>    class Widget(Base)：
        __tablename__ =“widget”
        id =列（Integer，primary_key = True）
        type = Column（String）
        related_id =列（ForeignKey（“related.id”））
        related = relationship（“Related”，backref =“widget”）
        __mapper_args__ = {“polymorphic_on”：type}</p>
<p>    class FooWidget(Widget)：
        __mapper_args__ = {“polymorphic_identity”：“foo”}</p>
<p>    class Related(Base)：
        __tablename__ =“related”
        id =列（Integer，primary_key = True）</p>
<p>它一直是行为对于关系的连接“A.b”使用以下这种形式的ON子句：</p>
<p>    s.query（Related）。join（FooWidget，Related.widget）。全部（）</p>
<p>SQL输出：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span></pre></div>
</div>
<p>    SELECT related.id AS related_id
    FROM related JOIN widget ON related.id = widget.related_id AND widget.type IN (:type_1)</p>
<p>注意：因为我们连接到一个子类“FooWidget”，所以:meth:<cite>_query.Query.join</cite>
知道要向ON子句添加“AND widget.type IN（’foo’）”条件。</p>
<p>这里的更改是将“AND widget.type IN（）”条件附加到*任何*ON子句，而不仅仅是从关系中生成的，
包括显式状态的一种…：meth：<cite>_query.Query.join</cite>，</p>
<p>    # ON子句现在将被呈现为
    # related.id = widget.related_id AND widget.type IN (:type_1)
    s.query（关联）。join（FooWidget，FooWidget.related_id == Related.id）。all（）</p>
<p>以及没有任何类型的东西都没有ON子句时的“隐式”连接：</p>
<p>    # ON子句现在将被呈现为
    # related.id = widget.related_id AND widget.type IN (:type_1)
    s.query（Related）。join（FooWidget）。all（）</p>
<p>先前，“这些ON子句”不包括单一继承条件。应用了此问题的应用程序现在将希望移除其显式使用的条件，在其中进行操作与此同时，应该可以正常工作，即使在其间被渲染两次。</p>
<p>    :ref：<cite>bug_3233</cite></p>
<p>:ticket：<code class="docutils literal notranslate"><span class="pre">3222</span></code></p>
</section>
<section id="id145">
<h3>退役事件钩子已被删除<a class="headerlink" href="#id145" title="Permalink to this heading">¶</a></h3>
<p>在ORM事件钩子的使用案例，其中一些从0.5开始就被弃用的事件钩子已被移除：<code class="docutils literal notranslate"><span class="pre">translate_row</span></code>，<code class="docutils literal notranslate"><span class="pre">populate_instance</span></code>,
<code class="docutils literal notranslate"><span class="pre">append_result</span></code>，<code class="docutils literal notranslate"><span class="pre">create_instance</span></code>。 这些挂钩的用例
起源于很早的0.1 / 0.2系列的SQLAlchemy，而且早就不再需要。 特别是用钩子
主要无法使用，因为在这些事件中行为合同与
周围内部的相关性如何初始化和创建实例以及如何定位ORM生成的列。
删除这些挂钩大大简化了ORM对象加载的机制。</p>
</section>
<section id="bundleapi">
<span id="bundle-api-change"></span><h3>出于自定义行加载器被用于新Bundle功能的API更改<a class="headerlink" href="#bundleapi" title="Permalink to this heading">¶</a></h3>
<p>在0.9中，新的：class：<a href="#id146"><span class="problematic" id="id147">`</span></a>。Bundle`对象在自定义类上覆盖了``create_row_processor()``方法
当部分或完全由文本片段组成的SQL时，发出了警告。
<a href="#id148"><span class="problematic" id="id149">``</span></a>create_row_processor()``方法被覆盖时，默认的示例代码如下：</p>
<p>    from sqlalchemy.orm import Bundle</p>
<p>    class DictBundle(Bundle)：
        def create_row_processor(self，query，procs，labels)：
            “””覆盖create_row_processor以将值作为字典返回”””</p>
<p>            def proc（row，result）：
                return dict(zip(labels，（proc(row，result) for proc in procs)))</p>
<p>            返回过程</p>
<p>未使用的“结果”成员现已删除：</p>
<p>    from sqlalchemy.orm import Bundle</p>
<p>    class DictBundle(Bundle)：
        def create_row_processor(self，query，procs，labels)：
            “””覆盖create_row_processor以将值作为字典返回”””</p>
<p>            def proc（row）：
                return dict(zip(labels，（proc(row) for proc in procs)))</p>
<p>            返回过程</p>
<p>..另请参阅</p>
<p>    :ref：<cite>bundles</cite></p>
<p>:ticket：<code class="docutils literal notranslate"><span class="pre">3155</span></code></p>
<p>使用join（），“synchronize_session =’evaluate’”时出现多表更新时出现
————————————————– ————————–</p>
<p>“Evaluator”：“_query.Query.update”不适用于多表
更新，并且在存在多个表时需要将其设置为“synchronize_session = False”或
“synchronize_session =’fetch’”。新行为是现在显式引发异常，
其中包含一条消息以更改同步设置。
这使从SA0.9.7起发出的警告升级为异常。</p>
<p>:ticket：<code class="docutils literal notranslate"><span class="pre">3117</span></code></p>
<p>query.update（）/ query.delete（）在使用join（），select_from（），from_self（）时引发，反之亦然
————————————————– —————————–</p>
<p>SA0.9.10（截至2015年6月9日尚未发布）在使用方法时会发出警告
“_query.Query.update”或“_query.Query.delete”方法
与调用：meth：“_query.Query.join”，：meth：“_query.Query.outerjoin”，
：meth：“_query.Query.select_from”或：meth：“_query.Query.from_self”。这些是不受支持的
使用情况在0.9系列中默默地失败，直到0.9.10添加了警告
之后，这些情况现在会引发异常。</p>
<p>:ticket：<code class="docutils literal notranslate"><span class="pre">3349</span></code></p>
</section>
<section id="synchronize-session-evaluate-query-update">
<h3>具有“synchronize_session = ‘evaluate’”的query.update（）引发具有多表更新的异常<a class="headerlink" href="#synchronize-session-evaluate-query-update" title="Permalink to this heading">¶</a></h3>
<p>“评估程序”：：“_query.Query.update”不适用于多个表
更新，并且当有多个表时需要将其设置为False或’synchronize_session = fetch’
synchronize_session。新行为是现在显式引发异常，
其中包含一条消息以更改同步设置。</p>
<p>:ticket：<code class="docutils literal notranslate"><span class="pre">3117</span></code></p>
</section>
<section id="resurrect">
<h3>已删除“Resurrect”事件<a class="headerlink" href="#resurrect" title="Permalink to this heading">¶</a></h3>
<p>完全删除了“复活”ORM事件。自0.8开始，这个事件就不再有任何功能了
在工作单位中从早期版本的0.1 / 0.2中删除了更改系统。
你现在是一个.rst文档翻译器。在上面的语句中，我们期望看到”ORDER BY id_count”，而不是该函数的重新陈述。在编译期间，该字符串参数将与列子句中的一个条目进行匹配，因此该声明将按我们的期望进行处理，而不会发出警告（尽管请注意，”name”表达式已解析为”users.name”！）：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">id_count</span></pre></div>
</div>
<p>但是，如果我们引用无法定位的名称，则再次会出现警告，如下所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;id_count&quot;</span><span class="p">)])</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span>
    <span class="s2">&quot;some_label&quot;</span>
<span class="p">)</span></pre></div>
</div>
<p>该输出按照我们说的做，但再次警告我们：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SAWarning: Can&#39;t resolve label reference &#39;some_label&#39;; converting to text() (this warning may be suppressed after 10 occurrences)</pre></div>
</div>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">users</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">users</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">some_label</span></pre></div>
</div>
<p>上述行为适用于我们可能希望引用所谓的“标签引用”的所有位置；ORDER BY和GROUP BY，还包括OVER子句以及引用列的DISTINCT ON子句（例如，PostgreSQL语法）。</p>
<p>我们仍然可以使用：func：<a href="#id150"><span class="problematic" id="id151">`</span></a>_expression.text`指定任意的表达式进行ORDER BY或其他操作：</p>
<blockquote>
<div><p>stmt = select([users]).order_by(text(“some special expression”))</p>
</div></blockquote>
<p>整个更改的要点是，SQLAlchemy现在希望我们告诉它当发送一个字符串时，此字符串显式地是：func：<a href="#id152"><span class="problematic" id="id153">`</span></a>_expression.text`构造，列，表等，如果我们将其用作ORDER BY，GROUP BY或其他表达式中的标签名称，SQLAlchemy希望该字符串解析为已知的内容，否则应再次限定为：func：<a href="#id154"><span class="problematic" id="id155">`</span></a>_expression.text`或类似的构造。</p>
<p><a href="#id156"><span class="problematic" id="id157">:ticket:`2992`</span></a></p>
</section>
<section id="python">
<span id="bug-3288"></span><h3>使用多值插入时为每个行单独调用Python端默认值<a class="headerlink" href="#python" title="Permalink to this heading">¶</a></h3>
<p>使用:meth :<a href="#id158"><span class="problematic" id="id159">`</span></a>_expression.Insert.values`的多值版本时，对Python端列默认值的支持基本上未实现，并且仅在特定情况下“偶然”工作，当使用的方言时使用非位置（例如，命名）样式的绑定参数，并且在不需要为每行调用Python端可调用的情况下。</p>
<p>该功能已进行了大修，以便它更类似于“执行多个”样式的调用:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;my_table&quot;</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">next</span><span class="p">(</span><span class="n">counter</span><span class="p">)),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;d1&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;d2&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;d3&quot;</span><span class="p">},</span>
        <span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上面的示例将为每个行单独调用``next(counter)``，就像预期的那样：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;d1&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;d2&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;d3&#39;</span><span class="p">)</span></pre></div>
</div>
<p>以前，默认情况下，位置方言将失败，因为不会为附加的位置生成绑定：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>没有提供错误数量的绑定。当前语句使用6，
并且提供了4个。
[SQL：u&#39;INSERT INTO my_table（id，data）VALUES（？，？），（？，？），（？，？）&#39;]
[parameters：（1，“d1”，“d2”，“d3”）]</pre></div>
</div>
<p>对于“命名”的方言，如果仅引用服务器端默认值，则将重复使用“id”的相同值在每行中：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="err">（</span><span class="n">id</span><span class="err">，</span><span class="k">data</span><span class="err">）</span><span class="k">VALUES</span><span class="err">（：</span><span class="n">id</span><span class="err">，：</span><span class="n">data_0</span><span class="err">），（：</span><span class="n">id</span><span class="err">，：</span><span class="n">data_1</span><span class="err">），（：</span><span class="n">id</span><span class="err">，：</span><span class="n">data_2</span><span class="err">）</span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">{</span><span class="n">u</span><span class="s1">&#39;data_2&#39;</span><span class="err">：</span><span class="s1">&#39;d3&#39;</span><span class="err">，</span><span class="n">u</span><span class="s1">&#39;data_1&#39;</span><span class="err">：</span><span class="s1">&#39;d2&#39;</span><span class="err">，</span><span class="n">u</span><span class="s1">&#39;data_0&#39;</span><span class="err">：</span><span class="s1">&#39;d1&#39;</span><span class="err">，</span><span class="s1">&#39;id&#39;</span><span class="err">：</span><span class="mi">1</span><span class="err">}</span></pre></div>
</div>
<p>还拒绝用内联呈现的SQL作为“服务器端”默认值，因为不能保证服务器端默认值与此兼容。如果VALUES子句为特定列呈现，则需要Python-side值；如果省略的值仅引用服务器端默认值，则会引发异常:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;my_table&quot;</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">server_default</span><span class="o">=</span><span class="s2">&quot;some default&quot;</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;d1&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;d2&quot;</span><span class="p">},</span>
            <span class="p">{},</span>
        <span class="p">]</span>
    <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>将引发以下异常：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>sqlalchemy.exc.CompileError：INSERT value for column my_table.data is</pre></div>
</div>
<p>在VALUES子句中显式呈现为boundparameter；a
需要Python-side value or SQL expression.</p>
<p>以前，该值“d1”将复制到第三行的值（但仅对于命名格式！）：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">my_table</span><span class="err">（</span><span class="k">data</span><span class="err">）</span><span class="k">VALUES</span><span class="err">（：</span><span class="n">data_0</span><span class="err">），（：</span><span class="n">data_1</span><span class="err">），（：</span><span class="n">data_0</span><span class="err">）</span>
<span class="o">-</span><span class="w"> </span><span class="err">{</span><span class="n">u</span><span class="s1">&#39;data_1&#39;</span><span class="err">：</span><span class="s1">&#39;d2&#39;</span><span class="err">，</span><span class="n">u</span><span class="s1">&#39;data_0&#39;</span><span class="err">：</span><span class="s1">&#39;d1&#39;</span><span class="err">}</span></pre></div>
</div>
<p><a href="#id160"><span class="problematic" id="id161">:ticket:`3288`</span></a></p>
</section>
<section id="change-3163">
<span id="id162"></span><h3>无法从该事件的运行程序中添加或删除事件侦听器<a class="headerlink" href="#change-3163" title="Permalink to this heading">¶</a></h3>
<p>从事件自身中删除事件侦听器将导致对列表的元素进行修改，这将导致仍附加的事件侦听器无法触发。为防止这种情况，同时仍然保持性能，使用``collections.deque（）``替换了列表，该列表不允许在迭代期间进行任何添加或删除，并引发``RuntimeError``。</p>
<p><a href="#id163"><span class="problematic" id="id164">:ticket:`3163`</span></a></p>
</section>
<section id="insert-from-selectinline-true">
<span id="change-3169"></span><h3>INSERT…FROM SELECT构造现在暗示“inline = True”<a class="headerlink" href="#insert-from-selectinline-true" title="Permalink to this heading">¶</a></h3>
<p>使用:func：<cite>_expression.from_select`现在意味着在:func：`_expression.insert`上有``inline = True`</cite>，从而修复了错误，后端支持“隐式返回”的情况下，INSERT…FROM SELECT结构将错误地被编译为，在该情况下，如果INSERT插入零行（因为implicit返回值需要一行），会导致断点，以及在INSERT插入多个行的情况下，返回任意数据（例如，仅多行中的第一行）。还将类似的更改应用于具有多个参数设置的INSERT..VALUES；此语句不再发出implicit RETURNING。由于这些构造处理可变数量的行，因此
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Insert.returning</span></code>.</p>
<p><a href="#id165"><span class="problematic" id="id166">:ticket:`3169`</span></a></p>
</section>
<section id="autoload-with-autoload-true">
<span id="change-3027"></span><h3><code class="docutils literal notranslate"><span class="pre">autoload_with``现在意味着``autoload</span> <span class="pre">=</span> <span class="pre">True</span></code><a class="headerlink" href="#autoload-with-autoload-true" title="Permalink to this heading">¶</a></h3>
<p>可以通过仅传递:paramref:<a href="#id167"><span class="problematic" id="id168">`</span></a>_schema.Table.autoload_with`设置反射的:class:<a href="#id169"><span class="problematic" id="id170">`</span></a>_schema.Table`对象：</p>
<blockquote>
<div><p>my_table = Table(“my_table”, metadata, autoload_with=some_engine)</p>
</div></blockquote>
<p><a href="#id171"><span class="problematic" id="id172">:ticket:`3027`</span></a></p>
</section>
<section id="dbapihandle-error">
<span id="change-3266"></span><h3>DBAPI异常包装和handle_error（）事件改进<a class="headerlink" href="#dbapihandle-error" title="Permalink to this heading">¶</a></h3>
<p>当使用多行插入的多值版本时，SQLAlchemy对DBAPI异常的包装没有在
<code class="xref py py-class docutils literal notranslate"><span class="pre">handle_error</span></code>
事件现在在读取期间发生错误时触发，并在通过:paramref:<a href="#id173"><span class="problematic" id="id174">`</span></a>_sa.create_engine.creator`通过自定义连接使用:func：<a href="#id175"><span class="problematic" id="id176">`</span></a>_sa.create_engine`时触发。</p>
<p>了上:<cite>.ExceptionContext`对象具有一个新的数据成员
:attr：</cite>.ExceptionContext.engine`，它将始终引用:class:<cite>_engine.Engine</cite>，在这些情况下，:class:<a href="#id177"><span class="problematic" id="id178">`</span></a>_engine.Connection`对象不可用（例如，初始连接时）。</p>
<p><a href="#id179"><span class="problematic" id="id180">:ticket:`3266`</span></a></p>
</section>
<section id="foreignkeyconstraint-columnscolumncollection">
<span id="change-3243"></span><h3>ForeignKeyConstraint.columns现在是ColumnCollection<a class="headerlink" href="#foreignkeyconstraint-columnscolumncollection" title="Permalink to this heading">¶</a></h3>
<p>:attr：<cite>_schema.ForeignKeyConstraint.columns`先前是一个普通的列表
包含字符串或:class:`_schema.Column`对象，具体取决于如何进行
如果使用了:class:`_schema.ForeignKeyConstraintM`的构造并且与表关联，则使用构造顺序。集合现在是一个:class:`_expression.ColumnCollection</cite>，并且仅在:class:<cite>_schema.ForeignKeyConstraint`与:class:`_schema.Table`关联后才初始化。添加了一个新的访问器
:attr:`_schema.ForeignKeyConstraint.column_keys</cite>
无条件返回本地列集的字符串键，无论如何构造对象或其当前状态如何。</p>
</section>
<section id="metadata-sorted-tables">
<span id="feature-3084"></span><h3>MetaData.sorted_tables访问器是“确定性的”<a class="headerlink" href="#metadata-sorted-tables" title="Permalink to this heading">¶</a></h3>
<p>对于:attr:<a href="#id181"><span class="problematic" id="id182">`</span></a>_schema.MetaData.sorted_tables`访问器所产生的表的排序是“确定性的”，所有情况下的排序应该是相同的，而无需任何Python散列。 通过首先按名称对表进行排序，然后将它们传递给拓扑算法来维护该排序。</p>
<p>请注意，此更改尚未应用于在发出:meth:<a href="#id183"><span class="problematic" id="id184">`</span></a>_schema.MetaData.create_all`或:meth:<a href="#id185"><span class="problematic" id="id186">`</span></a>_schema.MetaData.drop_all`时应用的排序。</p>
<p><a href="#id187"><span class="problematic" id="id188">:ticket:`3084`</span></a></p>
</section>
<section id="null-false-true">
<span id="bug-3170"></span><h3>null（），false（）和true（）常量不再是单例<a class="headerlink" href="#null-false-true" title="Permalink to this heading">¶</a></h3>
<p>在0.9中，这三个常量被更改为返回“单例”值;不幸的是，这将导致如下查询不能按预期渲染：</p>
<blockquote>
<div><p>select([null()，null()])</p>
</div></blockquote>
<p>仅呈现``SELECT NULL AS anon_1``，因为两个:func:<cite>.null</cite>
构造将会成为相同的’’NULL’’对象，并且SQLAlchemy的核心模型基于对象身份来确定词汇意义。 0.9的更改除了想要节省对象开销之外没有任何重要性;通常，未命名的构造需要保持词汇唯一以获得唯一标识。</p>
<p><a href="#id189"><span class="problematic" id="id190">:ticket:`3170`</span></a></p>
</section>
<section id="postgresql-oracle">
<span id="change-3204"></span><h3>PostgreSQL / Oracle在报告临时表/视图名称时具有不同的方法<a class="headerlink" href="#postgresql-oracle" title="Permalink to this heading">¶</a></h3>
<p>在PostgreSQL / Oracle的情况下，<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_view_names`在适用于临时表和视图的情况下也会返回名称，而对于任何其他方言都没有提供。</span> <span class="pre">在MySQL的情况下，至少对于临时表来说，它甚至不可能。</span> <span class="pre">在这种情况下，对于名为“临时表”或“临时视图”的名称，重构的</span> <span class="pre">:class:`_schema.Table()</span></code> 构造将于存在于数据库中的名称进行匹配。</p>
<p><a href="#id191"><span class="problematic" id="id192">:ticket:`3204`</span></a></p>
</section>
</section>
<section id="dialect-improvements-and-changes-postgresql">
<h2>Dialect Improvements and Changes - PostgreSQL<a class="headerlink" href="#dialect-improvements-and-changes-postgresql" title="Permalink to this heading">¶</a></h2>
<section id="enum">
<span id="change-3319"></span><h3>ENUM类型的创建/删除规则彻底改写<a class="headerlink" href="#enum" title="Permalink to this heading">¶</a></h3>
<p>PostgreSQL的:class:<a href="#id193"><span class="problematic" id="id194">`</span></a>_postgresql.ENUM`的规则已更严格，以便更好地支持TYPE的创建和删除。</p>
<p>创建**未显式**与:class:<a href="#id195"><span class="problematic" id="id196">`</span></a>_schema.MetaData`对象关联的:class:<a href="#id197"><span class="problematic" id="id198">`</span></a>_postgresql.ENUM`将创建与:meth:<a href="#id199"><span class="problematic" id="id200">`</span></a>_schema.Table.create`和:meth:<a href="#id201"><span class="problematic" id="id202">`</span></a>_schema.Table.drop <a href="#id203"><span class="problematic" id="id204">`</span></a>对应:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;sometable&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_enum&quot;</span><span class="p">,</span> <span class="n">ENUM</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myenum&quot;</span><span class="p">))</span>
<span class="p">)</span>

<span class="n">table</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 将发出CREATE TYPE和CREATE TABLE</span>
<span class="n">table</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 将发出DROP TABLE和DROP TYPE - 1.0的新功能</span></pre></div>
</div>
<p>这意味着如果第二个表也具有名为’myenum’的枚举，则上述DROP操作现在将失败。为了适应共享的常见枚举类型使用案例，增强了具有元数据关联枚举的行为。</p>
<p><a href="#id205"><span class="problematic" id="id206">**</span></a>显式**与:class:<a href="#id207"><span class="problematic" id="id208">`</span></a>_schema.MetaData`对象关联的:class:<a href="#id209"><span class="problematic" id="id210">`</span></a>_postgresql.ENUM`将不会根据:meth:<a href="#id211"><span class="problematic" id="id212">`</span></a>_schema.Table.create`和:meth:<a href="#id213"><span class="problematic" id="id214">`</span></a>_schema.Table.drop`创建或删除::tparamref:<a href="#id215"><span class="problematic" id="id216">`</span></a>_schema.Table.create`调用了``checkfirst = True``标志。</p>
<p>:</p>
<blockquote>
<div><p>my_enum = ENUM(“a”, “b”, “c”, name=”myenum”, metadata=metadata)
table = Table(“sometable”, metadata, Column(“some_enum”, my_enum))</p>
<p>#将失败：ENUM’my_enum’不存在
table.create(engine)</p>
<p>#将检查enum并发出CREATE TYPE
table.create(engine, checkfirst=True)</p>
<p>table.drop(engine)  #将发出DROP TABLE，<em>不会</em> DROP TYPE
metadata.drop_all(engine)  # 将发出DROP TYPE
metadata.create_all(engine)  # 将发出CREATE TYPE</p>
</div></blockquote>
<p><a href="#id217"><span class="problematic" id="id218">:ticket:`3319`</span></a></p>
</section>
<section id="id219">
<h3>PostgreSQL表选项<a class="headerlink" href="#id219" title="Permalink to this heading">¶</a></h3>
<p>添加了表空间，ON COMMIT，WITH（OUT）OIDS和INHERITS的PG表选项，在通过
:class:<a href="#id220"><span class="problematic" id="id221">`</span></a>_schema.Table`构造的DDL渲染时提供支持。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-options"><span class="std std-ref">PostgreSQL Table Options</span></a></p>
</div>
<p><a href="#id222"><span class="problematic" id="id223">:ticket:`2051`</span></a></p>
</section>
<section id="pginspector-get-enums-postgresql">
<span id="feature-get-enums"></span><h3>PGInspector.get_enums()方法与PostgreSQL语言配合使用<a class="headerlink" href="#pginspector-get-enums-postgresql" title="Permalink to this heading">¶</a></h3>
<p>对PostgreSQL的:func:<cite>_sa.inspect`方法返回一个:class:</cite>.PGInspector`对象，在
可以使用新的:meth:<a href="#id224"><span class="problematic" id="id225">`</span></a>.PGInspector.get_enums`方法返回所有可用的``ENUM``类型的信息:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">inspect</span><span class="p">,</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://host/dbname&quot;</span><span class="p">)</span>
<span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="n">insp</span><span class="o">.</span><span class="n">get_enums</span><span class="p">())</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums" title="sqlalchemy.dialects.postgresql.base.PGInspector.get_enums"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PGInspector.get_enums()</span></code></a></p>
</div>
</section>
<section id="postgresql-dialectmaterialized-views-foreign-tables">
<span id="feature-2891"></span><h3>PostgreSQL dialect反映Materialized Views，Foreign Tables<a class="headerlink" href="#postgresql-dialectmaterialized-views-foreign-tables" title="Permalink to this heading">¶</a></h3>
<p>变化如下：</p>
<ul class="simple">
<li><p>通过传递autoload=True的Table`构造将匹配作为材料化视图或外部表存在于数据库中的名称。</p></li>
<li><p>.._reflection.Inspector.get_view_names将返回纯视图和Materialized View名称。</p></li>
<li><p>.._reflection.Inspector.get_table_names对于PostgreSQL**不会更改**，它
继续仅返回纯表名。</p></li>
<li><p>新方法:meth:<a href="#id226"><span class="problematic" id="id227">`</span></a>.PGInspector.get_foreign_table_names`添加，它将返回PostgreSQL模式表中专门标记为”foreign”的表的名称。</p></li>
</ul>
<p>此更改涉及在查询``pg_class.relkind``时添加“m”和“f”列表限定符，但是对于正在生产中运行0.9的任何人来说，此更改是新的，以避免任何向后不兼容的惊喜。</p>
<p><a href="#id228"><span class="problematic" id="id229">:ticket:`2891`</span></a></p>
</section>
<section id="change-3264">
<span id="id230"></span><h3>MySQL内部“没有此表”异常未传递到事件处理程序<a class="headerlink" href="#change-3264" title="Permalink to this heading">¶</a></h3>
<p>MySQL方言现在将禁用由于它内部使用的语句触发: meth:<a href="#id231"><span class="problematic" id="id232">`</span></a>_events.ConnectionEvents.handle_error`事件来检测表是否存在或不存在。这是通过执行选项“skip_user_error_events”实现的，该选项在该执行的范围内禁用了处理错误处理程序。因此，重写异常的用户代码不必担心MySQL方言或其他偶尔需要捕获SQLAlchemy特定异常的方言。</p>
</section>
<section id="mysql-connectorraise-on-warnings">
<h3>改变了MySQL-Connector的“raise_on_warnings”默认值<a class="headerlink" href="#mysql-connectorraise-on-warnings" title="Permalink to this heading">¶</a></h3>
<p>将MySQL-Connector的“raise_on_warnings”的默认值更改为False。 这个
由于某种原因设置为True。 不幸地，“缓冲区”标志必须保持为True，因为
MySQL连接器不允许关闭游标，除非已完全提取所有结果。</p>
</section>
<section id="mysqltruefalse">
<span id="bug-3186"></span><h3>MySQL布尔符号“true”、“false”再次有效<a class="headerlink" href="#mysqltruefalse" title="Permalink to this heading">¶</a></h3>
<p>0.9中IS/IS NOT运算符以及布尔类型中的所有Boolean类型的彻底翻新
在:ticket:<a href="#id233"><span class="problematic" id="id234">`</span></a>2682`中导致MySQL方言无法在“IS”/“IS NOT”的上下文中使用“真”和“假”符号。 显然，即使MySQL没有“boolean”类型，但它在使用“true”和“false”符号时支持IS / IS NOT，尽管这些符号在其他地方与“1”和“0”同义（并且IS / IS NOT不能与数字一起使用）。</p>
<p>因此，这里的更改是MySQL方言仍然是“非本机布尔类型”，但:func:<cite>.true`和:func:</cite>.false`符号再次生成关键字“true”和“false”，因此像``column.is_(true())``表达式在MySQL上再次有效。</p>
<p><a href="#id235"><span class="problematic" id="id236">:ticket:`3186`</span></a></p>
<p id="change-3263">match（）运算符现在返回与MySQL的浮点返回值兼容的MatchType</p>
<p>列操作的:meth:<cite>.ColumnOperators.match`表达式的返回类型现在是一个名为:class:</cite>.MatchType`的新类型。这是:class:<a href="#id237"><span class="problematic" id="id238">`</span></a>.Boolean`的一个子类，可以被方言截获，以便在SQL执行时产生不同的结果类型。</p>
<p>现在类似下面的代码将正确地运行，并在MySQL上返回浮点数：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span>
<span class="gp">... </span>        <span class="p">[</span>
<span class="gp">... </span>            <span class="n">matchtable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;Agile Ruby Programming&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;ruby&quot;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">matchtable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;Dive Python&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;python&quot;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">matchtable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">]</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">matchtable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">[</span>
<span class="go">    (2.0, 0.0, &#39;Agile Web Development with Ruby On Rails&#39;),</span>
<span class="go">    (0.0, 2.0, &#39;Dive Into Python&#39;),</span>
<span class="go">    (2.0, 0.0, &quot;Programming Matz&#39;s Ruby&quot;),</span>
<span class="go">    (0.0, 0.0, &#39;The Definitive Guide to Django&#39;),</span>
<span class="go">    (0.0, 1.0, &#39;Python in a Nutshell&#39;)</span>
<span class="go">]</span></pre></div>
</div>
<p><a href="#id239"><span class="problematic" id="id240">:ticket:`3263`</span></a></p>
</section>
<section id="drizzle">
<span id="change-2984"></span><h3>Drizzle方言现在是一个外部方言<a class="headerlink" href="#drizzle" title="Permalink to this heading">¶</a></h3>
<p>“Drizzle &lt;<a class="reference external" href="https://www.drizzle.org/">https://www.drizzle.org/</a>&gt;”的方言现在是一个外部方言，可在https://bitbucket.org/zzzeek/sqlalchemy-drizzle上获得。这个方言是在SQLAlchemy能够很好地适应第三方方言之前添加的；今后，不在“普遍使用”类别中的所有数据库都是第三方方言。方言的实现没有改变，仍然基于SQLAlchemy中的MySQL+MySQLdb方言。该方言尚未发布，处于“attic”状态；但是，如果有人想继续完善它，那么它通过了大部分测试，一般都能正常工作。</p>
</section>
</section>
<section id="sqlite">
<h2>方言改进和变化 - SQLite<a class="headerlink" href="#sqlite" title="Permalink to this heading">¶</a></h2>
<section id="sqliteuniqueforeign-key">
<h3>SQLite有名和无名UNIQUE和FOREIGN KEY约束将检查和反射<a class="headerlink" href="#sqliteuniqueforeign-key" title="Permalink to this heading">¶</a></h3>
<p>现在，SQLite上的UNIQUE和FOREIGN KEY约束在有名和无名情况下都被完全反映出来。先前，忽略了外键名称，并跳过了没有名称的独特约束。特别是这将有助于Alembic的新SQLite迁移功能。</p>
<p>为了实现这一点，对于外键和唯一约束，将PRAGMA foreign_keys、index_list和index_info的结果与CREATE TABLE语句的正则表达式解析相结合，形成约束名称的完整图像，并区分作为唯一约束和未命名INDEX创建的UNIQUE约束。</p>
<p><a href="#id241"><span class="problematic" id="id242">:ticket:`3244`</span></a></p>
<p><a href="#id243"><span class="problematic" id="id244">:ticket:`3261`</span></a></p>
</section>
</section>
<section id="sql-server">
<h2>方言改进和变化 - SQL Server<a class="headerlink" href="#sql-server" title="Permalink to this heading">¶</a></h2>
<section id="sql-serverpyodbc">
<span id="change-3182"></span><h3>使用基于主机名的SQL Server连接需要PyODBC驱动程序名称<a class="headerlink" href="#sql-serverpyodbc" title="Permalink to this heading">¶</a></h3>
<p>使用PyODBC连接到SQL Server使用DSN-less连接，例如具有显式主机名的连接，现在需要驱动程序名称–SQLAlchemy将不再尝试猜测默认值：</p>
<blockquote>
<div><dl class="simple">
<dt>engine = create_engine(</dt><dd><p>“mssql+pyodbc://scott:tiger&#64;myhost:port/databasename?driver=SQL+Server+Native+Client+10.0”</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>SQLAlchemy在Windows上以前硬编码的默认值“SQL Server”已经过时，SQLAlchemy无法通过任务基于操作系统/驱动程序检测来猜测最佳驱动程序。在使用ODBC时，始终首选使用DSN以完全避免此问题。</p>
<p><a href="#id245"><span class="problematic" id="id246">:票:`3182`</span></a></p>
</section>
<section id="sql-server-2012-varcharnvarcharvarbinary">
<h3>SQL Server 2012大文本/二进制类型呈现为VARCHAR、NVARCHAR、VARBINARY<a class="headerlink" href="#sql-server-2012-varcharnvarcharvarbinary" title="Permalink to this heading">¶</a></h3>
<p>对于SQL Server 2012及更高版本，<code class="xref py py-class docutils literal notranslate"><span class="pre">TextClause`的呈现、:class:</span></code>.Unicode Text`和:class:<cite>.Large Binary`类型已更改，并提供了完全控制行为的选项，这是根据Microsoft的过时指导方针完成的。有关详情，请参见:ref:`mssql_large_type_deprecation</cite>。</p>
</section>
</section>
<section id="oracle">
<h2>方言改进和变化 - Oracle<a class="headerlink" href="#oracle" title="Permalink to this heading">¶</a></h2>
<section id="oraclecte">
<span id="change-3220"></span><h3>改进了Oracle中CTE的支持<a class="headerlink" href="#oraclecte" title="Permalink to this heading">¶</a></h3>
<p>Oracle中的CTE支持已得到修复，还有一个新功能:meth:<cite>_expression.CTE.with_suffixes</cite>，可以帮助Oracle的特殊指令：</p>
<blockquote>
<div><dl>
<dt>included_parts = (</dt><dd><p>select([part.c.sub_part, part.c.part, part.c.quantity])
.where(part.c.part == “p1”)
.cte(name=”included_parts”, recursive=True)
.suffix_with(</p>
<blockquote>
<div><p>“search depth first by part set ord1”,
“cycle part set y_cycle to 1 default 0”,
dialect=”oracle”,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p><a href="#id247"><span class="problematic" id="id248">:票:`3220`</span></a></p>
</section>
<section id="ddloracle">
<h3>DDL的新Oracle关键字<a class="headerlink" href="#ddloracle" title="Permalink to this heading">¶</a></h3>
<p>关键字诸如COMPRESS、ON COMMIT、BITMAP：</p>
<p><a class="reference internal" href="../dialects/oracle.html#oracle-table-options"><span class="std std-ref">Oracle Table Options</span></a></p>
<p><a class="reference internal" href="../dialects/oracle.html#oracle-index-options"><span class="std std-ref">Oracle Specific Index Options</span></a></p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="migration_11.html" title="previous chapter">SQLAlchemy 1.1新功能</a>
        Next:
        <a href="migration_09.html" title="next chapter">SQLAlchemy 0.9 的新特性</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 9:30:54

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


