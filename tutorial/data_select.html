<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    使用SELECT语句
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="使用数据" href="data.html" />
        <link rel="next" title="使用UPDATE和DELETE语句" href="data_update.html" />
        <link rel="prev" title="使用 INSERT 语句" href="data_insert.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy统一教程">SQLAlchemy统一教程</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="engine.html">建立连接 - Engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="dbapi_transactions.html">使用事务和DBAPI</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata.html">使用数据库元数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="data.html">使用数据</a></span><ul>
<li><span class="link-container"><a class="reference external" href="data_insert.html">使用 INSERT 语句</a></span></li>
<li><span class="link-container"><a class="reference external" href="data_insert.html#returning">使用 RETURNING 检查插入结果</a></span></li>
<li><span class="link-container"><a class="reference external" href="data_insert.html#tutorial-insert-from-select">插入…从选择操作</a></span></li>
<li class="selected"><span class="link-container"><strong>使用SELECT语句</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#select-sql">select() SQL表达式构造</a></span></li>
<li><span class="link-container"><a class="reference external" href="#from">设置列和FROM语句</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#orm">选择ORM实体和列</a></span></li>
<li><span class="link-container"><a class="reference external" href="#sql">从带标签的SQL表达式中进行选择</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-select-arbitrary-text">使用文本列表达式选择</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#where">WHERE 子句</a></span></li>
<li><span class="link-container"><a class="reference external" href="#fromjoin">显式FROM子句和JOIN</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#on">设置ON子句</a></span></li>
<li><span class="link-container"><a class="reference external" href="#outer-full-join">OUTER 和 FULL  join</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#order-by-group-by-having">ORDER BY, GROUP BY, HAVING</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#order-by">ORDER BY</a></span></li>
<li><span class="link-container"><a class="reference external" href="#group-by-having">使用 GROUP BY / HAVING 的聚合函数</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-order-by-label">按照标签排序或分组</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#tutorial-using-aliases">使用别名</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#tutorial-orm-entity-aliases">ORM实体别名</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#ctes">子查询和公共表达式CTEs</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id19">公共表达式语句 (CTEs)</a></span></li>
<li><span class="link-container"><a class="reference external" href="#orm-ctes">ORM实体子查询/CTEs</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm-orm-aliased-user-address-sql-fromclause-class-sql-alias-orm-aliased-class-sql-select-schema-table-scalar-and-correlated-subqueries">在ORM中，  <code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code> ` User`` 或 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类)与代表行源的任何  <code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code>  的   :class:` _sql.Alias`  相关联。下面的示例说明如何使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code> ，生成的   :class:` _sql.Select`  构造最终导出与同一映射   <code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code>  相关的行。Scalar and Correlated Subqueries</a></span></li>
<li><span class="link-container"><a class="reference external" href="data_update.html">使用UPDATE和DELETE语句</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="orm_data_manipulation.html">使用ORM操作数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm_related_objects.html">使用 ORM 相关对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="further_reading.html">更多阅读</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="data_insert.html" title="previous chapter">使用 INSERT 语句</a></li>
                <li><b>Next:</b>
                <a href="data_update.html" title="next chapter">使用UPDATE和DELETE语句</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy统一教程">SQLAlchemy统一教程</a></li>
                    <ul><li><a href="data.html" title="使用数据">使用数据</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#select">使用SELECT语句</a><ul>
<li><a class="reference internal" href="#select-sql">select() SQL表达式构造</a></li>
<li><a class="reference internal" href="#from">设置列和FROM语句</a><ul>
<li><a class="reference internal" href="#orm">选择ORM实体和列</a></li>
<li><a class="reference internal" href="#sql">从带标签的SQL表达式中进行选择</a></li>
<li><a class="reference internal" href="#tutorial-select-arbitrary-text">使用文本列表达式选择</a></li>
</ul>
</li>
<li><a class="reference internal" href="#where">WHERE 子句</a></li>
<li><a class="reference internal" href="#fromjoin">显式FROM子句和JOIN</a><ul>
<li><a class="reference internal" href="#on">设置ON子句</a></li>
<li><a class="reference internal" href="#outer-full-join">OUTER 和 FULL  join</a></li>
</ul>
</li>
<li><a class="reference internal" href="#order-by-group-by-having">ORDER BY, GROUP BY, HAVING</a><ul>
<li><a class="reference internal" href="#order-by">ORDER BY</a></li>
<li><a class="reference internal" href="#group-by-having">使用 GROUP BY / HAVING 的聚合函数</a></li>
<li><a class="reference internal" href="#tutorial-order-by-label">按照标签排序或分组</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-using-aliases">使用别名</a><ul>
<li><a class="reference internal" href="#tutorial-orm-entity-aliases">ORM实体别名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctes">子查询和公共表达式CTEs</a><ul>
<li><a class="reference internal" href="#id19">公共表达式语句 (CTEs)</a></li>
<li><a class="reference internal" href="#orm-ctes">ORM实体子查询/CTEs</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#orm-orm-aliased-user-address-sql-fromclause-class-sql-alias-orm-aliased-class-sql-select-schema-table-scalar-and-correlated-subqueries">在ORM中，  <code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.aliased()</span></code> ` User`` 或 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类)与代表行源的任何  <code class="xref py py-class docutils literal notranslate"><span class="pre">_sql.FromClause</span></code>  的   :class:` _sql.Alias`  相关联。下面的示例说明如何使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">_orm.aliased()</span></code> ，生成的   :class:` _sql.Select`  构造最终导出与同一映射   <code class="xref py py-class docutils literal notranslate"><span class="pre">_schema.Table</span></code>  相关的行。Scalar and Correlated Subqueries</a><ul>
<li><a class="reference internal" href="#union-union-all">UNION，UNION ALL 和其他集合操作</a><ul>
<li><a class="reference internal" href="#id22">使用联合查询选择ORM实体</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id23">存在子查询</a></li>
<li><a class="reference internal" href="#tutorial-functions">使用SQL功能</a><ul>
<li><a class="reference internal" href="#id25">函数有返回类型</a></li>
<li><a class="reference internal" href="#id26">内置函数有预配置的返回类型</a><ul>
<li><a class="reference internal" href="#upper-lower-sqlalchemy-sqlalchemy-python-sqlalchemy">对于简单的函数，如 <code class="docutils literal notranslate"><span class="pre">upper</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lower</span></code>，通常不太重要，因为可以在不需要SQLAlchemy在处理方面进行特殊类型处理的情况下从数据库接收字符串值，SQLAlchemy的类型强制转换规则通常也可以正确猜测意图；Python <code class="docutils literal notranslate"><span class="pre">+</span></code> 操作符也可以在大多数情况下使用，因为SQLAlchemy通常可以发现合适的类型。窗口函数</a><ul>
<li><a class="reference internal" href="#within-group-filter">WITHIN GROUP, FILTER和特殊修改器</a></li>
<li><a class="reference internal" href="#tutorial-functions-table-valued">表值函数</a></li>
<li><a class="reference internal" href="#tutorial-functions-column-valued">列值函数 - 表值函数作为标量列</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#postgresqloracle">PostgreSQL和Oracle支持的一种特殊语法是指向“表值函数作为标量列”的语法。数据类型转换与强制转换</a><ul>
<li><a class="reference internal" href="#type-coerce-python">type_coerce() - 一个仅限于Python的“转换”</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar tutorial-data_select" >
        
<section class="core-header orm-dependency" id="select">
<span id="tutorial-selecting-data"></span><h1>使用SELECT语句<a class="headerlink" href="#select" title="Permalink to this heading">¶</a></h1>
<p>在Core和ORM中，  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  方法传递，在ORM中通过  :meth:` _orm.Session.execute`  方法传递, SELECT语句将发出，并通过返回的 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> 对象获得结果行。</p>
<div class="orm-header docutils container">
<p><strong>ORM读者</strong> - 此处的内容同样适用于Core和ORM，并提及了基本的ORM变体用例。
但是还有更多专门针对ORM的功能可用;
这些在   <a class="reference internal" href="../orm/queryguide/index.html"><span class="std std-ref">ORM 查询指南</span></a>  中有详细说明。</p>
</div>
<section id="select-sql">
<h2>select() SQL表达式构造<a class="headerlink" href="#select-sql" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  相同的方式构建语句，使用一种生成式方法，</p>
</div></blockquote>
<p>其中每个方法都将更多的状态构建到对象中。与其他SQL构造一样，它可以在原地转化为字符串：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">{printsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">WHERE user_account.name = :name_1</span></pre></div>
</div>
<p>与所有其他级别的语句级SQL构造一样，要实际运行语句，我们需要将其传递给执行方法。
由于SELECT语句返回行，我们始终可以迭代结果对象以获取 :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>_engine.Row ` 对象：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     for row in conn.execute(stmt):</span>
<span class="go">...         print(row)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;spongebob&#39;</span><span class="p">,)</span>
</div><span class="go">(1, &#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>在使用ORM时，特别是对临近ORM实体的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造进行操作时，
我们将希望使用  <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  方法执行它；
使用这种方法，我们继续从结果中获取 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象，但是这些行现在有能力包含
完整的实体，例如 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类的实例，作为每个行中的单个元素：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for row in session.execute(stmt):</span>
<span class="go">...         print(row)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;spongebob&#39;</span><span class="p">,)</span>
</div><span class="go">(User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;),)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<aside class="topic">
<p class="topic-title">从表格和ORM类中的select()问题</p>
<p>尽管无论我们调用 <code class="docutils literal notranslate"><span class="pre">select(user_table)</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">select(User)</span></code> 所生成的SQL
看起来都是相同的，但在更一般的情况下，它们不一定会渲染为相同的内容，因为ORM映射类
可以映射到表格以外的其他类型的 “可选择”对象。针对ORM实体的 <code class="docutils literal notranslate"><span class="pre">select()</span></code> 也表明应该在结果中返回ORM映射实例，
这不是从   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象中选择时的情况。</p>
</aside>
<p>接下来的几节将更详细地讨论SELECT构造。</p>
</section>
<section id="from">
<span id="tutorial-selecting-columns"></span><h2>设置列和FROM语句<a class="headerlink" href="#from" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 函数接受位置元素，代表任意数量的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 和 / 或  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 表达式，</p>
</div></blockquote>
<p>以及广泛可兼容的对象，这些对象解析成要从中SELECT的SQL表达式列表，这些表达式将作为结果集中的列返回。
这些元素还在更简单的情况下用于创建FROM子句，
该子句是由传递的列和类似于表格的表达式自动推断出来的。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<span class="go">{printsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span></pre></div>
</div>
<p>在使用Core方法从单个列中进行SELECT时，可以直接访问  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.c</span></code>  访问器中的 :class:` _schema.Column`对象，
FROM子句将从这些列所代表的所有 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 和其他 :class:<a href="#id3"><span class="problematic" id="id4">`</span></a>_sql.FromClause ` 对象推断出来：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
<span class="go">{printsql}SELECT user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span></pre></div>
</div>
<p>或者 使用任何   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a>  的  :c:` .FromClause.c`   集合，例如  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> ，可以指定多个列：使用一个字符串名字元组来调用   :func:` _sql.select` ：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">]))</span>
<span class="go">{printsql}SELECT user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.0: </span>向 :attr`.FromClause.c` 集合中添加了元组访问的能力。</p>
</div>
<section id="orm">
<h3>选择ORM实体和列<a class="headerlink" href="#orm" title="Permalink to this heading">¶</a></h3>
<p>ORM实体，例如我们的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类以及列映射属性，例如 <code class="docutils literal notranslate"><span class="pre">User.name</span></code>，同样参与SQL表达式语言系统中的表和列。下面我们看一下从 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体中进行SELECT的示例，它最终呈现的方式与我们直接使用 <code class="docutils literal notranslate"><span class="pre">user_table</span></code> 相同:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>当我们使用 ORM 的  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  方法执行像上述语句这样的语句时，有一个重要的区别，即当我们从完整实体（比如 ` <cite>User`</cite>）进行选择时，与 <code class="docutils literal notranslate"><span class="pre">user_table</span></code> 相比，<strong>实体本身作为每一行的单个元素返回</strong>。也就是说，当我们从上述语句获取行时，由于只有 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体在要获取的列表中，我们会得到包含 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类实例的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>  对象，该对象只有一个元素:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="p">...</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">(User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;),)</span></pre></div>
</div>
<p>以上的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>  只有一个元素，表示 ` <cite>User`</cite> 实体：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>一个非常推荐的方便方法是使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.scalars()</span></code>  方法直接执行相同的操作；该方法将返回一个   :class:` _result.ScalarResult`  对象，该对象会一次性返回每一行的第一个“列”，在本例中是 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类的实例:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>或者，我们可以作为结果行中不同的元素选择ORM实体的单个列，通过使用类绑定属性；当传递给诸如   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  这样的构造时，它们会解析为每个属性所代表的   :class:` _schema.Column`  或其他SQL表达式:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>当我们使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  调用*此*语句时，我们现在会收到每个值对应于单独列或其他SQL表达式的结果行的每个元素：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">[...] (){stop}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">(&#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>这些方法也可以混合使用，在下面的示例中，我们将 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体的 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性作为行的第一个元素来选择，并将其与完整的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 实体合并为第二个元素：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.name, address.id, address.email_address, address.user_id</span>
<span class="go">FROM user_account, address</span>
<span class="go">WHERE user_account.id = address.user_id ORDER BY address.id</span>
<span class="go">[...] (){stop}</span>
<span class="go">[(&#39;spongebob&#39;, Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)),</span>
<span class="go">(&#39;sandy&#39;, Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)),</span>
<span class="go">(&#39;sandy&#39;, Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;))]</span></pre></div>
</div>
<p>选择ORM实体和列以及将行转换为Python对象的通用方法进一步讨论在   <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-columns"><span class="std std-ref">选择ORM实体和属性</span></a>  中。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-columns"><span class="std std-ref">选择ORM实体和属性</span></a>  - 在   :ref:` queryguide_toplevel`  中</p>
</div>
</section>
<section id="sql">
<h3>从带标签的SQL表达式中进行选择<a class="headerlink" href="#sql" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.label()</span></code></a>   方法以及在ORM属性上也有同名方法提供了列或表达式的SQL标签，允许它在结果集中有一个特定的名称。当通过名称引用结果行中的任意SQL表达式时，这可能是有用的：</p>
</div></blockquote>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">cast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="go">...     (&quot;Username: &quot; + user_table.c.name).label(&quot;username&quot;),</span>
<span class="go">... ).order_by(user_table.c.name)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     for row in conn.execute(stmt):</span>
<span class="go">...         print(f&quot;{row.username}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">username</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;用户名：&#39;</span><span class="err">，</span><span class="p">)</span>
</div><span class="go">用户名：帕特里克</span>
<span class="go">用户名：桑迪</span>
<span class="go">用户名：海绵宝宝</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tutorial-order-by-label"><span class="std std-ref">按照标签排序或分组</span></a>  - 我们创建的标签名称也可以在   :class:` _sql.Select`  的 ORDER BY 或 GROUP BY 子句中引用。</p>
</div>
</section>
<section id="tutorial-select-arbitrary-text">
<span id="id5"></span><h3>使用文本列表达式选择<a class="headerlink" href="#tutorial-select-arbitrary-text" title="Permalink to this heading">¶</a></h3>
<p>当我们使用   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  函数构造   :class:` _sql.Select`  对象时，
通常传递给它的是使用   <a class="reference internal" href="metadata.html#tutorial-working-with-metadata"><span class="std std-ref">表元数据</span></a>  定义的一系列   :class:` _schema.Table`  和   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  对象，或者在使用 ORM 时，我们可能会发送 ORM 映射的表示表列的属性。但是，有时还需要在语句中制造任意的 SQL 块，例如常量字符串表达式，或者仅仅是一些更易于直接编写的任意 SQL。</p>
<p>引入的   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>  构造，在   :ref:` tutorial_working_with_transactions`  中可以直接嵌入到   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>  构造中，例如下面我们制造了一个硬编码的字符串字面量 ` <cite>‘some phrase’`</cite>，并将其嵌入到 SELECT 语句中:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;some phrase&#39;&quot;</span><span class="p">),</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="go">{execsql}BEGIN (implicit)</span>
<span class="go">SELECT &#39;some phrase&#39;, user_account.name</span>
<span class="go">FROM user_account ORDER BY user_account.name</span>
<span class="go">[generated in ...] ()</span>
<span class="go">{stop}[(&#39;some phrase&#39;, &#39;patrick&#39;), (&#39;some phrase&#39;, &#39;sandy&#39;), (&#39;some phrase&#39;, &#39;spongebob&#39;)]</span>
<span class="go">{execsql}ROLLBACK{stop}</span></pre></div>
</div>
<p>虽然   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>  构造可以在大多数地方用于插入字面 SQL 短语，但我们实际上更多地处理每个表示单个列表达式的文字单位。在这种常见情况下，我们可以使用   :func:` _sql.literal_column`  构造函数从我们的文本片段中获取更多的功能。此对象类似于   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> ，但它代表一个明确的单“列”，可以在子查询和其他表达式中带标签并引用。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">literal_column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;&#39;some phrase&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">),</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">p</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">{execsql}BEGIN (implicit)</span>
<span class="go">SELECT &#39;some phrase&#39; AS p, user_account.name</span>
<span class="go">FROM user_account ORDER BY user_account.name</span>
<span class="go">[generated in ...] ()</span>
<span class="go">{stop}some phrase, patrick</span>
<span class="go">some phrase, sandy</span>
<span class="go">some phrase, spongebob</span>
<span class="go">{execsql}ROLLBACK{stop}</span></pre></div>
</div>
<p>请注意，在使用   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>  或   :func:` _sql.literal_column`  时，我们编写的是一个可用语法分析的表达式，而不是一个文字值。因此，我们必须包含所需的任何引号或语法，以出现我们想要呈现的 SQL。</p>
</section>
</section>
<section id="where">
<span id="tutorial-select-where-clause"></span><h2>WHERE 子句<a class="headerlink" href="#where" title="Permalink to this heading">¶</a></h2>
<p>SQLAlchemy 允许我们通过结合   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  等对象和标准 Python 运算符来构成 SQL 表达式，例如 ` <cite>name = ‘squidward’`</cite> 或 <code class="docutils literal notranslate"><span class="pre">user_id</span> <span class="pre">&gt;</span> <span class="pre">10</span></code>。对于布尔表达式，大多数 Python 运算符（如 <code class="docutils literal notranslate"><span class="pre">==</span></code>，<code class="docutils literal notranslate"><span class="pre">！=</span></code>，<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>，<code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 等）会生成新的 SQL 表达式对象，而不是普通的布尔 <code class="docutils literal notranslate"><span class="pre">True/False</span></code> 值：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">)</span>
<span class="go">user_account.name = :name_1</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">address.user_id &gt; :user_id_1</span></pre></div>
</div>
<p>我们可以将这样的表达式传递给  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a>  方法，通过生成 WHERE 子句：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">))</span>
<span class="go">{printsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">WHERE user_account.name = :name_1</span></pre></div>
</div>
<p>要生成由 AND 连接的多个表达式，可多次调用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a>  方法：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}SELECT address.email_address</span>
<span class="go">FROM address, user_account</span>
<span class="go">WHERE user_account.name = :name_1 AND address.user_id = user_account.id</span></pre></div>
</div>
<p>单调用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a>  方法也接受多个表达式：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}SELECT address.email_address</span>
<span class="go">FROM address, user_account</span>
<span class="go">WHERE user_account.name = :name_1 AND address.user_id = user_account.id</span></pre></div>
</div>
<p>“AND” 和 “OR” 连接都可以直接使用   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a>  和   :func:` _sql.or_`  函数进行连接，如下所示：ORM实体查询:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(Address.email_address).where(</span>
<span class="go">...         and_(</span>
<span class="go">...             or_(User.name == &quot;squidward&quot;, User.name == &quot;sandy&quot;),</span>
<span class="go">...             Address.user_id == User.id,</span>
<span class="go">...         )</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_2</span><span class="p">)</span>
<span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>如果只是对单个实体进行“相等”比较，还有一种流行的方法，称为  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by" title="sqlalchemy.sql.expression.Select.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.filter_by()</span></code></a>  ，它接受与列键或ORM属性名称匹配的关键字参数。它将筛选左侧FROM子句或最后加入的实体:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">fullname_1</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/operators.html"><span class="doc">运算符参考</span></a>  - SQL表达式运算符函数的描述</p>
</div>
</section>
<section id="fromjoin">
<span id="tutorial-select-join"></span><h2>显式FROM子句和JOIN<a class="headerlink" href="#fromjoin" title="Permalink to this heading">¶</a></h2>
<p>如前所述，FROM子句通常是**推断出来的**基于设置在列子句中的表达式以及  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 的其他元素。</p>
<p>如果我们从特定的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 在COLUMNS子句中设置了一个单列，它也将该  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 放入FROM子句中:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>如果我们从两个表中取列，则得到以逗号分隔的FROM子句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="p">,</span><span class="w"> </span><span class="n">address</span>
</div></pre></div>
</div>
<p>为了将这两个表JOIN起来，我们通常使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>  方法，它允许我们显式地指示JOIN的左侧和右侧:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(user_table.c.name, address_table.c.email_address).join_from(</span>
<span class="go">...         user_table, address_table</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>另一个是  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>  方法，它只指示JOIN的右侧，左侧被推断出来:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<aside class="sidebar">
<p class="sidebar-title">ON子句是推断出来的</p>
<p>当使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>  或  :meth:` _sql.Select.join`  时，我们可能会发现在简单的外键情况下，JOIN的ON子句也为我们推断出来了。下一节中会详细介绍。</p>
</aside>
<p>我们还有另一种选择，可以显式地向FROM子句添加元素，如果它没有以我们想要的方式从columns子句中进行推断，我们使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a>  方法来实现这一点，如下所示，我们将` <cite>user_table``作为FROM子句中的第一个元素，并使用  :meth:`_sql.Select.join</cite>  来建立` <a href="#id6"><span class="problematic" id="id7">`</span></a>address_table``作为第二个元素:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>另一个例子是，如果我们的列子句不足以提供FROM子句的信息，我们可能想使用常见的SQL表达式``count(*)``进行SELECT，我们使用SQLAlchemy元素  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.func</span></code></a>  来生成SQL` <a href="#id8"><span class="problematic" id="id9">`</span></a>count()``函数:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(:</span><span class="n">count_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">orm_queryguide_select_from</span>  - 在   :ref:` queryguide_toplevel`  - 中包含有关  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a>  和  :meth:` _sql.Select.join`  交互的其他示例和注意事项。</p>
</div>
<section id="on">
<span id="tutorial-select-join-onclause"></span><h3>设置ON子句<a class="headerlink" href="#on" title="Permalink to this heading">¶</a></h3>
<p>JOIN的先前的示例说明类似于  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> ` user_table``和``address_table``的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code> 对象包括一个单一的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> 定义，该定义用于形成此ON子句。</p>
<p>如果JOIN的左侧和右侧目标没有这样的约束条件，或存在多个约束条件，则需要直接指定ON子句。  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>  和  :meth:` _sql.Select.join_from`  都接受一个额外的ON子句参数，该参数使用与我们在 <a class="reference internal" href="#tutorial-select-where-clause"><span class="std std-ref">WHERE 子句</span></a> 中看到的相同的SQL表达式机制来表示：</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}SELECT address.email_address</span>
<span class="go">FROM user_account JOIN address ON user_account.id = address.user_id.. container:: orm-header</span></pre></div>
</div>
<p><strong>ORM Tip</strong> - 使用ORM实体时，还有一种生成ON子句的方法，
这种方法需要使用   <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code>  构造函数，比如上一节中
声明映射类的部分。这是另一个主题，您可以在   <span class="xref std std-ref">tutorial_joining_relationships</span>
中详细了解。</p>
</div></blockquote>
</section>
<section id="outer-full-join">
<h3>OUTER 和 FULL  join<a class="headerlink" href="#outer-full-join" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>   和  :meth:` _sql.Select.join_from`  方法都接受
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.join.isouter</span></code></a>   和  :paramref:` _sql.Select.join.full`  关键字参数，</p>
</div></blockquote>
<p>分别表示 LEFT OUTER JOIN 和 FULL OUTER JOIN:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">FULL</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>还有一个方法  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a>  等价于使用 ` <cite>.join(…, isouter=True)`</cite>。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>SQL 还有一个 “RIGHT OUTER JOIN”。SQLAlchemy 并不直接生成该语句，
而是调换表的顺序，使用 “LEFT OUTER JOIN” 代替。</p>
</div>
</section>
</section>
<section id="order-by-group-by-having">
<span id="tutorial-order-by-group-by-having"></span><h2>ORDER BY, GROUP BY, HAVING<a class="headerlink" href="#order-by-group-by-having" title="Permalink to this heading">¶</a></h2>
<p>SELECT SQL 语句包含的一个子句叫做 ORDER BY，它用于按照指定的顺序返回所选行。</p>
<p>GROUP BY 子句的构造方式与 ORDER BY 子句类似，并且其目的是将所选行分成特定的组，
这些组上可以调用聚合函数。HAVING 子句通常与 GROUP BY 一起使用，
其形式与 WHERE 子句类似，但是其作用于组内使用的聚合函数。</p>
<section id="order-by">
<span id="tutorial-order-by"></span><h3>ORDER BY<a class="headerlink" href="#order-by" title="Permalink to this heading">¶</a></h3>
<dl>
<dt>ORDER BY 子句构造为基于 SQL 表达式构造的   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  或类似对象。</dt><dd><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a>   方法按位置接受一个或多个表达式:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
</div></pre></div>
</div>
</dd>
</dl>
<p>升序/降序可以从  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc" title="sqlalchemy.sql.expression.ColumnElement.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.asc()</span></code></a>  和  :meth:` _sql.ColumnElement.desc`
修饰符中获得，从 ORM 绑定的属性中也有这些方法:：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="o">.</span><span class="n">desc</span><span class="p">()))</span>
<span class="go">{printsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account ORDER BY user_account.fullname DESC</span></pre></div>
</div>
<p>上述语句将按照 <code class="docutils literal notranslate"><span class="pre">user_account.fullname</span></code> 列以降序排序返回行。</p>
</section>
<section id="group-by-having">
<span id="tutorial-group-by-w-aggregates"></span><h3>使用 GROUP BY / HAVING 的聚合函数<a class="headerlink" href="#group-by-having" title="Permalink to this heading">¶</a></h3>
<p>在 SQL 中，聚合函数允许将跨多行的列表达式聚合在一起，以生成单个结果。
例如，计数、计算平均值以及在一组值中定位最大或最小值。</p>
<p>SQLAlchemy 使用称为  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a>  的命名空间以开放的方式提供 SQL 函数。
这是一个特殊的构造函数对象，当给定特定 SQL 函数的名称以及零个或多个要传递给函数的参数时，
它将创建一个新的   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a>  实例，参数就像在所有其他情况下一样，
是 SQL 表达式构造。例如，要对 <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> 列渲染 SQL COUNT() 函数，
我们调用 <code class="docutils literal notranslate"><span class="pre">count()</span></code> 函数名称:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count_fn</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">count_fn</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">count</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
</div></pre></div>
</div>
<p>本教程稍后在   <a class="reference internal" href="#tutorial-functions"><span class="std std-ref">使用SQL功能</span></a>  中详细介绍了 SQL 函数。</p>
<p>在 SQL 中使用聚合函数时，GROUP BY 子句是必不可少的，因为它允许将行分区为组，
而聚合函数将分别应用于每个组。在在 SELECT 语句的 COLUMNS 子句中请求非聚合列时，
SQL 要求这些列都受到 GROUP BY 子句的约束，直接或者间接基于主键关联。
然后，HAVING 子句类似于 WHERE 子句，但是它是基于聚合值而不是直接行内容筛选行。</p>
<p>SQLAlchemy 使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.group_by" title="sqlalchemy.sql.expression.Select.group_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.group_by()</span></code></a>  和  :meth:` _sql.Select.having`  方法支持这两个子句。
下面我们示例说明选择用户名称字段以及地址计数，对于那些拥有多个地址的用户：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(</span>
<span class="go">...         select(User.name, func.count(Address.id).label(&quot;count&quot;))</span>
<span class="go">...         .join(Address)</span>
<span class="go">...         .group_by(User.name)</span>
<span class="go">...         .having(func.count(Address.id) &gt; 1)</span>
<span class="go">...     )</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</div><span class="go">    [(&#39;sandy&#39;, 2)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</section>
<section id="tutorial-order-by-label">
<span id="id10"></span><h3>按照标签排序或分组<a class="headerlink" href="#tutorial-order-by-label" title="Permalink to this heading">¶</a></h3>
<p>在一些数据库后端中，一种非常重要的技术是能够对已经在列数据中声明的表达式进行 ORDER BY 或 GROUP BY ，而不必在 ORDER BY 或 GROUP BY 子句中重新声明该表达式并使用来自 COLUMNS 子句的该列的名称或标记名称。通过把该名称的字符串文本传递到  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a>   或  :meth:` _sql.Select.group_by`  方法中即可使用这种形式。 传递的文本不会直接呈现，而是以应用程序中声明表达式名称的形式呈现，如果找不到匹配项，则会引发错误。 也可以在这种形式中使用单元修饰符  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.asc" title="sqlalchemy.sql.expression.asc"><code class="xref py py-func docutils literal notranslate"><span class="pre">asc()</span></code></a>  和   :func:` .desc`  ：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">desc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address.user_id, func.count(Address.id).label(&quot;num_addresses&quot;))</span>
<span class="go">...     .group_by(&quot;user_id&quot;)</span>
<span class="go">...     .order_by(&quot;user_id&quot;, desc(&quot;num_addresses&quot;))</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">num_addresses</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">num_addresses</span><span class="w"> </span><span class="k">DESC</span>
</div></pre></div>
</div>
</section>
</section>
<section id="tutorial-using-aliases">
<span id="id11"></span><h2>使用别名<a class="headerlink" href="#tutorial-using-aliases" title="Permalink to this heading">¶</a></h2>
<p>现在，我们正在从多个表中进行选择并使用连接，我们很快就会遇到需要在语句的 FROM 子句中多次引用同一个表的情况。我们使用 SQL 别名来实现这一点，它是一种为表或子查询提供替代名称的语法，从而可以在语句中引用。</p>
<p>在 SQLAlchemy 表达式语言中，这些“名称”代替由于  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>  方法在核心中构造的。  :class:` _sql.Alias`   集合内具有 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象的名称空间。 例如，以下 SELECT 返回所有唯一的用户名对：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias_1</span> <span class="o">=</span> <span class="n">user_table</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias_2</span> <span class="o">=</span> <span class="n">user_table</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">user_alias_1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_alias_2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">user_alias_1</span><span class="p">,</span> <span class="n">user_alias_2</span><span class="p">,</span> <span class="n">user_alias_1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">user_alias_2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}SELECT user_account_1.name, user_account_2.name AS name_1</span>
<span class="go">FROM user_account AS user_account_1</span>
<span class="go">JOIN user_account AS user_account_2 ON user_account_1.id &gt; user_account_2.id</span></pre></div>
</div>
<section id="tutorial-orm-entity-aliases">
<span id="id12"></span><h3>ORM实体别名<a class="headerlink" href="#tutorial-orm-entity-aliases" title="Permalink to this heading">¶</a></h3>
<p>ORM的类似于  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a>  方法的函数是ORM   :func:` _orm.aliased` <a href="#id13"><span class="problematic" id="id14">`</span></a>User``实体中选择包含两个特定电子邮件地址的所有对象：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">aliased</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_alias_1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_alias_2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">address_alias_1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">address_alias_1</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s2">&quot;patrick@aol.com&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">address_alias_2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">address_alias_2</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s2">&quot;patrick@gmail.com&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{printsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">JOIN address AS address_1 ON user_account.id = address_1.user_id</span>
<span class="go">JOIN address AS address_2 ON user_account.id = address_2.user_id</span>
<span class="go">WHERE address_1.email_address = :email_address_1</span>
<span class="go">AND address_2.email_address = :email_address_2</span></pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>正如在   <a class="reference internal" href="#tutorial-select-join-onclause"><span class="std std-ref">设置ON子句</span></a>  中提到的，ORM 提供了使用   :func:` _orm.relationship`  构造的另一种连接方式。上面使用别名的示例在   :ref:<a href="#id15"><span class="problematic" id="id16">`</span></a>tutorial_joining_relationships_aliased 中 `  来演示。</p>
</div>
</section>
</section>
<section id="ctes">
<span id="tutorial-subqueries-ctes"></span><h2>子查询和公共表达式CTEs<a class="headerlink" href="#ctes" title="Permalink to this heading">¶</a></h2>
<p>在SQL中，子查询是在括号内呈现在上下文中放置在封闭语句内的SELECT语句。</p>
<p>本节将介绍所谓的“非标量”子查询，通常放置在较大的 SELECT 语句的 FROM 子句中。我们还将介绍公共表达式 (Common Table Expression) 或 CTE ，它与子查询用法相似但还包括其他功能。</p>
<p>SQLAlchemy 使用   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>  对象表示子查询和   :class:` _sql.CTE`  来表示公共表达式，通常从  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a>  和  :meth:` _sql.Select.cte`  方法中获取。任何一个对象都可以用作较大的   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  构造中的FROM元素。</p>
<p>我们可以构建一个   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> ，该   :class:` _sql.Subquery`  将从’address’表中选择行的聚合计数(聚合功能和 GROUPBY 已在  :ref:<a href="#id17"><span class="problematic" id="id18">`</span></a>tutorial_group_by_w_aggregates ` 中介绍）：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="n">子查询</span></pre></div>
</div>
<hr class="docutils" />
<p>对于基本的子查询，我们可以使用   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>  类创建一个SELECT子查询，即：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="p">)</span></pre></div>
</div>
<p>如果您把打印输出的命令行COPY到Python代码块中，您会得到以下结果：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
<span class="go">SELECT count(address.id) AS count, address.user_id</span>
<span class="go">FROM address GROUP BY address.user_id</span></pre></div>
</div>
<p>将子查询转换为普通的SELECT语句可以直接调用以返回只含SELECT查询和不含括号的SELECT语句：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
<span class="go">SELECT count(address.id) AS count, address.user_id</span>
<span class="go">FROM address GROUP BY address.user_id</span></pre></div>
</div>
<p>与框架其他FROM元素相同，   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>  对象具有  :attr:` _sql.Subquery.c`  命名空间。我们可以使用这个命名空间引用 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 列，以及用我们定制的标签 <code class="docutils literal notranslate"><span class="pre">count</span></code> 表达式:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
<span class="go">SELECT anon_1.user_id, anon_1.count</span>
<span class="go">FROM (SELECT count(address.id) AS count, address.user_id AS user_id</span>
<span class="go">FROM address GROUP BY address.user_id) AS anon_1</span></pre></div>
</div>
<p>在子查询对象中选择行后，可以将该对象应用于较大的   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>  ，以将数据连接到 ` <cite>user_account`</cite> 表上：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">user_table</span><span class="p">,</span> <span class="n">subq</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">SELECT user_account.name, user_account.fullname, anon_1.count</span>
<span class="go">FROM user_account JOIN (SELECT count(address.id) AS count, address.user_id AS user_id</span>
<span class="go">FROM address GROUP BY address.user_id) AS anon_1 ON user_account.id = anon_1.user_id</span></pre></div>
</div>
<p>为了从 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表连接到 <code class="docutils literal notranslate"><span class="pre">address</span></code> ，我们使用了  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>  方法。尽管 SQL 子查询本身并没有任何约束，但 SQLAlchemy 可以在表示该列的约束时作用于列上的约束，通过确定 ` <cite>subq.c.user_id`</cite> 值由 <code class="docutils literal notranslate"><span class="pre">address_table.c.user_id</span></code> 列派生而来，派生的列扩展了该外键约束关系，然后生成了 ON 子句。</p>
<section id="id19">
<h3>公共表达式语句 (CTEs)<a class="headerlink" href="#id19" title="Permalink to this heading">¶</a></h3>
<p>在SQLAlchemy中，使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a>  方法的调用更改为使用  :meth:` _sql.Select.cte`  即可，然后可以使用生成的对象作为FROM元素来使用，但渲染的 SQL 则是完全不同的公共表达式语法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
    <span class="o">.</span><span class="n">cte</span><span class="p">()</span>
<span class="p">)</span></pre></div>
</div>
<p>查询输出结果基本相同：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
   <span class="n">WITH</span> <span class="n">anon_1</span> <span class="n">AS</span>
   <span class="p">(</span><span class="n">SELECT</span> <span class="n">count</span><span class="p">(</span><span class="n">address</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="n">AS</span> <span class="n">count</span><span class="p">,</span> <span class="n">address</span><span class="o">.</span><span class="n">user_id</span> <span class="n">AS</span> <span class="n">user_id</span>
   <span class="n">FROM</span> <span class="n">address</span> <span class="n">GROUP</span> <span class="n">BY</span> <span class="n">address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
    <span class="n">SELECT</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">user_id</span>
   <span class="n">FROM</span> <span class="n">anon_1</span>

<span class="p">:</span><span class="n">class</span><span class="p">:</span><span class="err">`</span><span class="n">_sql</span><span class="o">.</span><span class="n">CTE</span><span class="err">`</span> <span class="n">构造还提供了使用</span><span class="err">“</span><span class="n">递归</span><span class="err">”</span><span class="n">样式的能力</span><span class="err">。</span><span class="n">在更复杂的情况下</span><span class="err">，</span><span class="n">CTE可能由INSERT</span><span class="err">，</span><span class="n">UPDATE或DELETE语句的</span> <span class="n">RETURNING</span> <span class="n">子句组成</span><span class="err">。</span></pre></div>
</div>
<p>在两种情况下，子查询和CTE在SQL级别上都被命名为“匿名”名称。在Python代码中，我们不需要提供这些名称。  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>  或  :meth:` _sql.Select.cte`  方法的第一个参数传递来提供呈现的名称。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a>  - 关于子查询的更多细节</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a>  - CTE的示例，包括如何使用 RECURSIVE 以及面向数据操作语言（DDL）的 CTEs</p>
</div>
</section>
<section id="orm-ctes">
<span id="tutorial-subqueries-orm-aliased"></span><h3>ORM实体子查询/CTEs<a class="headerlink" href="#orm-ctes" title="Permalink to this heading">¶</a></h3>
</section>
</section>
</section>
<section id="orm-orm-aliased-user-address-sql-fromclause-class-sql-alias-orm-aliased-class-sql-select-schema-table-scalar-and-correlated-subqueries">
<h1>在ORM中，  <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> ` User`` 或 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类)与代表行源的任何  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a>  的   :class:` _sql.Alias`  相关联。下面的示例说明如何使用   <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> ，生成的   :class:` _sql.Select`  构造最终导出与同一映射   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  相关的行。Scalar and Correlated Subqueries<a class="headerlink" href="#orm-orm-aliased-user-address-sql-fromclause-class-sql-alias-orm-aliased-class-sql-select-schema-table-scalar-and-correlated-subqueries" title="Permalink to this heading">¶</a></h1>
<p>标量(subquery)是一种返回恰好零行或一行以及一个列的子查询功能。子查询然后在封闭的SELECT语句的COLUMNS或WHERE子句中使用，与FROM子句中的常规子查询不同。相关(subquery)是指在封闭的SELECT语句中提到了一个表的标量(subquery)。</p>
<p>SQLAlchemy使用_column.ScalarSelect构造表示标量(subquery)，该构造是_column.ColumnElement表达式层次结构的一部分，与使用_subquery.Subquery构造表示的常规子查询不同，该构造位于column.FromClause层次结构中。</p>
<p>标量(subquery)通常与聚合函数一起使用，但不一定是这样，之前在:ref：<a href="#id20"><span class="problematic" id="id21">`</span></a>tutorial_group_by_w_aggregates`中介绍。标量(subquery)可以通过使用_selectable.Select.scalar_subquery方法进行显式指示。它的默认字符串形式在被它本身字符串化时呈现为一个普通的SELECT语句，该语句从两个表中进行选择：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .scalar_subquery()</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
<span class="go">SELECT count(address.id) AS count_1</span>
<span class="go">FROM address, user_account</span>
<span class="go">WHERE user_account.id = address.user_id</span></pre></div>
</div>
<p>上述“subq”对象现在在_column.SQL表达式层次结构中，因为它可以像任何其他列表达式一样使用：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(SELECT count(address.id) AS count_1</span>
<span class="go">FROM address, user_account</span>
<span class="go">WHERE user_account.id = address.user_id) = :param_1</span></pre></div>
</div>
<p>虽然标量(subquery)本身在字符串化时通过FROM子句呈现出”user_account”和”address”，但在将其嵌入到处理”user_account”表的封闭 :func: ‘_sql.select’结构中时，“user_account”表会自动与标量(subquery)相关联，这意味着它不会将其呈现为标量(subquery)的FROM子句中。：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;address_count&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">SELECT user_account.name, (SELECT count(address.id) AS s_1</span>
<span class="go">FROM address</span>
<span class="go">WHERE user_account.id = address.user_id) AS address_count</span>
<span class="go">FROM user_account</span></pre></div>
</div>
<p>简单的关联(subquery)通常会按预期执行所需的操作。然而，在相关性不明确的情况下，SQLAlchemy 会让我们知道需要更多的明确性:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...         subq.label(&quot;address_count&quot;),</span>
<span class="go">...     )</span>
<span class="go">...     .join_from(user_table, address_table)</span>
<span class="go">...     .order_by(user_table.c.id, address_table.c.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">InvalidRequestError: Select statement &#39;&lt;... Select object at ...&gt;&#39; returned</span>
<span class="go">no FROM clauses due to auto-correlation; specify correlate(&lt;tables&gt;) to</span>
<span class="go">control correlation manually.</span></pre></div>
</div>
<p>为了指明 “user_table” 是我们想要相关的表，我们使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate" title="sqlalchemy.sql.expression.ScalarSelect.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScalarSelect.correlate()</span></code></a>  或  :meth:` _sql.ScalarSelect.correlate_except`  方法来指定:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .scalar_subquery()</span>
<span class="go">...     .correlate(user_table)</span>
<span class="go">... )</span></pre></div>
</div>
<p>该语句类似于其他列一样返回给定列的数据:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(</span>
<span class="go">...         select(</span>
<span class="go">...             user_table.c.name,</span>
<span class="go">...             address_table.c.email_address,</span>
<span class="go">...             subq.label(&quot;address_count&quot;),</span>
<span class="go">...         )</span>
<span class="go">...         .join_from(user_table, address_table)</span>
<span class="go">...         .order_by(user_table.c.id, address_table.c.id)</span>
<span class="go">...     )</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;, 1), (&#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;, 2),</span>
<span class="go"> (&#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;, 2)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p id="tutorial-lateral-correlation">横跨 LATERAL 相关性是 SQL 相关性的一种特殊子类，允许可选择的单元在单个 FROM 子句中引用另一个可选择的单元。这是一个极其特殊的用例，虽然是 SQL 标准的一部分，但仅已知适用于最近版本的 PostgreSQL。</p>
<p>通常，如果 SELECT 语句引用它的 FROM 子句中的 “table1 JOIN (SELECT…) AS subquery”，则右侧的子查询可能不能参照左侧的“table1”表达式; 相关性只能参照完全包含此 SELECT 的另一个 SELECT 的一部分的表。LATERAL 关键字允许我们将这个行为反过来，允许来自右侧 JOIN 的相关性。</p>
<p>SQLAlchemy 使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a>  方法支持此功能，该方法创建一个称为   :class:` .Lateral`  的对象。   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a>  与   :class:` .Subquery`  和   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>  属于同一系列，但当将构造添加到 SELECT 的 FROM 子句时，还包括相关性行为。下面的示例说明了使用 LATERAL 的 SQL 查询，选择“用户帐户 / 电子邮件地址计数”数据，就像上一节中所讨论的那样:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count(address_table.c.id).label(&quot;address_count&quot;),</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...         address_table.c.user_id,</span>
<span class="go">...     )</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .lateral()</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(user_table.c.name, subq.c.address_count, subq.c.email_address)</span>
<span class="go">...     .join_from(user_table, subq)</span>
<span class="go">...     .order_by(user_table.c.id, subq.c.email_address)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">address_count</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="k">LATERAL</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span>
</div></pre></div>
</div>
<p>在上述示例中，JOIN 的右侧是相关到左侧的 “user_account” 表的子查询。</p>
<p>使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a>  时，也会将  :meth:` _expression.Select.correlate`  和  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a>  方法应用于   :class:` .Lateral`  结构。</p>
<p>参见:</p>
<blockquote>
<div><blockquote>
<div><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a></p>
</div></blockquote>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a></p>
</div></blockquote>
<section id="union-union-all">
<span id="tutorial-union"></span><h2>UNION，UNION ALL 和其他集合操作<a class="headerlink" href="#union-union-all" title="Permalink to this heading">¶</a></h2>
<p>在 SQL 中，可以使用 UNION 或 UNION ALL SQL 操作将 SELECT 语句合并在一起，这将生成由一个或多个语句一起产生的所有行的集合。也可以进行其他的集合操作，例如：INTERSECT [ALL] 和 EXCEPT [ALL]。</p>
<p>SQLAlchemy 的   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>  构造支持此类组合，使用类似   :func:` _sql.union` ，   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.intersect" title="sqlalchemy.sql.expression.intersect"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect()</span></code></a>  和   :func:` _sql.except_` ,   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.intersect_all" title="sqlalchemy.sql.expression.intersect_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect_all()</span></code></a>  和   :func:` _sql.except_all` 。这些函数都接受任意数量的子可选择项，通常是   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>  构造，但也可以是现有的组合。</p>
<p>这些函数生成的结构是   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> ，它的使用方式与   :class:` _sql.Select`  结构相同，除了</p>
<section id="id22">
<h3>使用联合查询选择ORM实体<a class="headerlink" href="#id22" title="Permalink to this heading">¶</a></h3>
<p>前面的示例演示了如何通过给定两个   <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象构建 UNION ，然后返回数据库行。如果我们想要使用 UNION 或者其他集合操作来选择 ORM 实体中的行，有两种方法可以使用。在这两种方法中，我们首先构建一个表示我们要执行的 SELECT / UNION / etc 语句的   :func:` _sql.select`  或者   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a>  对象；这个语句应该是针对目标 ORM 实体或者它们的底层映射的   :class:` _schema.Table`  对象来组成的:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sandy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union_all</span><span class="p">(</span><span class="n">stmt1</span><span class="p">,</span> <span class="n">stmt2</span><span class="p">)</span></pre></div>
</div>
<p>对于不在子查询中的简单 SELECT with UNION ，可以使用  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement" title="sqlalchemy.sql.expression.Select.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.from_statement()</span></code></a>  方法在 ORM 对象获取上下文中使用。使用这种方法，UNION 语句代表整个查询；在使用  :meth:` _sql.Select.from_statement`  后不能添加其他条件:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">orm_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for obj in session.execute(orm_stmt).scalars():</span>
<span class="go">...         print(obj)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;)</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>如果想要以更灵活的方式将 UNION 或其他相关联的构造作为实体相关组件，则可以使用   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a>  构造函数通过  :meth:` _sql.CompoundSelect.subquery`  将其组织成子查询，然后使用   <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a>  函数将其链接到 ORM 对象。这与   :ref:` tutorial_subqueries_orm_aliased`  中介绍的方法相同，首先创建一个自定义“映射”，将我们想要的实体映射到子查询上，然后选择从那个新实体进行选择，就像它是任何其他映射类一样。在下面的例子中，我们可以添加其他条件，例如 ORDER BY ，以外部的 UNION 进行过滤或排序，因为我们可以按子查询导出的列进行过滤或排序:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">subquery</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_alias</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_alias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for obj in session.execute(orm_stmt).scalars():</span>
<span class="go">...         print(obj)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">fullname</span><span class="p">..</span><span class="w"> </span><span class="n">_tutorial_exists</span><span class="p">:</span>
</div></pre></div>
</div>
</section>
</section>
<section id="id23">
<h2>存在子查询<a class="headerlink" href="#id23" title="Permalink to this heading">¶</a></h2>
<p>SQL中的EXISTS关键词是一个运算符，与 <span class="xref std std-ref">标量子查询</span> 一起使用，
根据SELECT语句是否返回行来返回布尔值true或false。 SQLAlchemy包含一个称为</p>
<blockquote>
<div><p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Exists" title="sqlalchemy.sql.expression.Exists"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exists</span></code></a> 的  <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a> 对象变体，它将生成一个</p>
</div></blockquote>
<p>EXISTS子查询，并且最方便地使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists" title="sqlalchemy.sql.expression.SelectBase.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.exists()</span></code></a> 方法生成。
以下我们生成一个EXISTS，以便我们可以返回具有多个相关行的” user_account “行：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .group_by(address_table.c.user_id)</span>
<span class="go">...     .having(func.count(address_table.c.id) &gt; 1)</span>
<span class="go">... ).exists()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(select(user_table.c.name).where(subq))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</div><span class="go">[(&#39;sandy&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>EXISTS构造通常更多地用作否定，例如NOT EXISTS，因为它提供了一种定位相关表没有行的行的SQL
高效的形式。 下面我们选择没有电子邮件地址的用户名称；请注意二进制否定运算符（<code class="docutils literal notranslate"><span class="pre">~</span></code>）
在第二个WHERE子句中使用：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(address_table.c.id).where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">... ).exists()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(select(user_table.c.name).where(~subq))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="p">(</span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">))</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;patrick&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</section>
<section id="tutorial-functions">
<span id="id24"></span><h2>使用SQL功能<a class="headerlink" href="#tutorial-functions" title="Permalink to this heading">¶</a></h2>
<p>在本文档的前面部分，最先引入了  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a>
对象，它作为用于创建新的   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a>  对象的工厂，
当用在像   <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>  这样的结构中时，会产生一个 SQL 函数集合，
通常由一个名称、一些括号（虽然不总是如此）和可能一些参数组成。 常见SQL函数的示例包括：</p>
<ul>
<li><p>count() 函数，一个返回多少行数据的聚合函数：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">())</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
</li>
<li><p>lower() 函数，一个将字符串转换为小写的字符串函数：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="s2">&quot;A String With Much UPPERCASE&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">lower</span><span class="p">(:</span><span class="n">lower_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">lower_1</span>
</div></pre></div>
</div>
</li>
<li><p>now() 函数，提供当前日期和时间；作为一种常见函数，SQLAlchemy 知道如何为每个后端以不同的方式呈现
这个函数，在SQLite的情况下使用CURRENT_TIMESTAMP函数：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">now_1</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="p">[(</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">(...),)]</span>
<span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</li>
</ul>
<dl class="simple">
<dt>由于大多数数据库后端都具有几十甚至几百个不同的SQL函数，</dt><dd><p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a>   在接受任何可能的名称时尽可能宽容。</p>
</dd>
</dl>
<p>从此命名空间访问的任何名称都被自动视为SQL功能，其以通用方式呈现:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">some_crazy_function</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">17</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">some_crazy_function</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">some_crazy_function_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">some_crazy_function_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<dl class="simple">
<dt>同时，一组相对较小的极其常见的SQL函数，例如   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a> 、</dt><dd><p><a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a> 、  :class:` _functions.concat`  提供了自己的预打包版本，</p>
</dd>
</dl>
<p>这些版本提供了一些正确的typing信息以及特定于后端的SQL。在某些情况下，尽管某个函数在SQL表达式中的功能相同，但其SQL生成情况可能不同。下面的示例对比了针对PostgreSQL方言和Oracle方言的   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a>  函数时所产生的SQL生成：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<span class="go">{printsql}SELECT now() AS now_1{stop}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">oracle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">oracle</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<span class="go">{printsql}SELECT CURRENT_TIMESTAMP AS now_1 FROM DUAL{stop}</span></pre></div>
</div>
<section id="id25">
<h3>函数有返回类型<a class="headerlink" href="#id25" title="Permalink to this heading">¶</a></h3>
<p>由于函数是列表达式，因此它们也具有描述在生成的SQL表达式中该表达式的SQL   <a class="reference internal" href="../core/types.html"><span class="std std-ref">数据类型</span></a>  的SQL返回类型。我们将这些类型在这里称为”SQL返回类型”，指的是在数据库端SQL表达式的上下文中函数返回的SQL值的类型，而不是Python函数的”返回类型”。</p>
<p>可以通过引用  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Function.type</span></code>  属性来访问任何SQL函数的SQL返回类型，通常是为了调试目的：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">DateTime()</span></pre></div>
</div>
<p>在使用表达式的上下文中，这些SQL返回类型非常重要。例如，在执行数学运算符时，如果表达式的数据类型类似于   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>  或   :class:` _types.Numeric` ，则这些运算符将工作得更好；为了使JSON访问器能够工作，必须使用一种诸如   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>  的类型。某些类别的函数返回整个行而不是列值，因此需要引用特定的列；这些函数称为   :ref:` 表值函数 &lt;tutorial_functions_table_valued&gt;` 。</p>
<p>对于需要在创建的函数中应用特定类型的情况，我们可以使用  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function.params.type_" title="sqlalchemy.sql.functions.Function"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Function.type_</span></code></a>  参数来传递它；类型参数可以是   :class:` _types.TypeEngine`  类或实例。在下面的示例中，我们将   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>  类传递给生成PostgreSQL ` <cite>json_object()`</cite> 函数，注意SQL返回类型将为JSON类型：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function_expr</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">json_object</span><span class="p">(</span><span class="s1">&#39;{a, 1, b, &quot;def&quot;, c, 3.5}&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">JSON</span><span class="p">)</span></pre></div>
</div>
<p>通过使用   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>  数据类型创建我们的JSON函数，SQL表达式对象具有了JSON相关的功能，例如访问元素：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">function_expr</span><span class="p">[</span><span class="s2">&quot;def&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="go">{printsql}SELECT json_object(:json_object_1)[:json_object_2] AS anon_1</span></pre></div>
</div>
</section>
<section id="id26">
<h3>内置函数有预配置的返回类型<a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h3>
<p>针对常见聚合函数，如   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a> 、  :class:` _functions.max` 、  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.min" title="sqlalchemy.sql.functions.min"><code class="xref py py-class docutils literal notranslate"><span class="pre">min</span></code></a> ，以及极少数日期函数，如   :class:` _functions.now`  和字符串函数，SQL返回类型会得到适当的设置，有时基于使用情况。例如，   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a>  函数和类似的聚合过滤函数将根据给定的参数设置SQL返回类型：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_int&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">type</span>
<span class="go">Integer()</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_str&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">type</span>
<span class="go">String()</span></pre></div>
</div>
<p>日期和时间函数通常对应于由   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> 、  :class:` _types.Date`  或   <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Time" title="sqlalchemy.types.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">Time</span></code></a>  描述的SQL表达式：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">DateTime()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">current_date</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">Date()</span></pre></div>
</div>
<p>已知的字符串函数，如   <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a> ，将知道SQL表达式的类型是   :class:` _types.String` 。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">String()</span></pre></div>
</div>
<p>但是，对于大多数SQL函数，SQLAlchemy并没有将其明确地包括在其非常小的已知函数列表中配置。例如，尽管通常使用SQL函数 <code class="docutils literal notranslate"><span class="pre">func.lower()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">func.upper()</span></code> 来转换字符串的大小写，但SQLAlchemy实际上并不知道这些函数，因此它们具有”null” SQL返回类型：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="s2">&quot;lowercase&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<section id="upper-lower-sqlalchemy-sqlalchemy-python-sqlalchemy">
<h4>对于简单的函数，如 <code class="docutils literal notranslate"><span class="pre">upper</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lower</span></code>，通常不太重要，因为可以在不需要SQLAlchemy在处理方面进行特殊类型处理的情况下从数据库接收字符串值，SQLAlchemy的类型强制转换规则通常也可以正确猜测意图；Python <code class="docutils literal notranslate"><span class="pre">+</span></code> 操作符也可以在大多数情况下使用，因为SQLAlchemy通常可以发现合适的类型。窗口函数<a class="headerlink" href="#upper-lower-sqlalchemy-sqlalchemy-python-sqlalchemy" title="Permalink to this heading">¶</a></h4>
<p>窗口函数是一种特殊用途的SQL聚合函数，它计算了作为单个结果行进行处理的组中返回的行的聚合值。虽然像`MAX()`这样的函数会给你一个集合中最高的列值，但使用同一函数作为“窗口函数”将为您提供每行的最高值，就像是在该行之前*的一样。</p>
<p>在SQL中，窗口函数允许您指定应应用函数的行，这是”分区”值，它考虑了不同子集合的窗口，并且”order by”表达式非常重要，包括其行应用到的聚合函数的顺序。
在SQLAlchemy中，由  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a>  命名空间生成的所有SQL函数都包括一个方法  :meth:` _functions.FunctionElement.over` ，它赋予了窗口函数或”OVER”语法；生成的构造是   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Over" title="sqlalchemy.sql.expression.Over"><code class="xref py py-class docutils literal notranslate"><span class="pre">Over</span></code></a> 。</p>
<p>与窗口函数一起常用的函数是`row_number()`函数，它仅计算行数。我们可以针对用户名将此行计数进行分区，以为单个用户的电子邮件地址编号：</p>
<p><code class="docutils literal notranslate"><span class="pre">`pycon+sql</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">stmt</span> <span class="pre">=</span> <span class="pre">(</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">select(</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">func.row_number().over(partition_by=user_table.c.name),</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">user_table.c.name,</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">address_table.c.email_address,</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">)</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">.select_from(user_table)</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">.join(address_table)</span>
<span class="pre">...</span> <span class="pre">)</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">with</span> <span class="pre">engine.connect()</span> <span class="pre">as</span> <span class="pre">conn:</span>&#160; <span class="pre">#</span> <span class="pre">doctest:+SKIP</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">result</span> <span class="pre">=</span> <span class="pre">conn.execute(stmt)</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">print(result.all())</span>
<span class="pre">...</span>
<span class="pre">[(1,</span> <span class="pre">'sandy',</span> <span class="pre">'sandy&#64;sqlalchemy.org'),</span> <span class="pre">(2,</span> <span class="pre">'sandy',</span> <span class="pre">'sandy&#64;squirrelpower.org'),</span> <span class="pre">(1,</span> <span class="pre">'spongebob',</span> <span class="pre">'spongebob&#64;sqlalchemy.org')]</span>
<span class="pre">`</span></code></p>
<p>在上述示例中，使用  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.over.partition_by</span></code></a>  参数使得` PARTITION BY`子句在 OVER 子句中呈现出来。
我们也可以使用 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.over.order_by</span></code></a> 子句：</p>
<p><code class="docutils literal notranslate"><span class="pre">`pycon+sql</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">stmt</span> <span class="pre">=</span> <span class="pre">(</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">select(</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">func.count().over(order_by=user_table.c.name),</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">user_table.c.name,</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">address_table.c.email_address,</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">)</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">.select_from(user_table)</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">.join(address_table)</span>
<span class="pre">...</span> <span class="pre">)</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">with</span> <span class="pre">engine.connect()</span> <span class="pre">as</span> <span class="pre">conn:</span>&#160; <span class="pre">#</span> <span class="pre">doctest:+SKIP</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">result</span> <span class="pre">=</span> <span class="pre">conn.execute(stmt)</span>
<span class="pre">...</span>&#160;&#160;&#160;&#160; <span class="pre">print(result.all())</span>
<span class="pre">...</span>
<span class="pre">[(2,</span> <span class="pre">'sandy',</span> <span class="pre">'sandy&#64;sqlalchemy.org'),</span> <span class="pre">(2,</span> <span class="pre">'sandy',</span> <span class="pre">'sandy&#64;squirrelpower.org'),</span> <span class="pre">(3,</span> <span class="pre">'spongebob',</span> <span class="pre">'spongebob&#64;sqlalchemy.org')]</span>
<span class="pre">`</span></code></p>
<p>窗口函数的其他选项包括使用范围；有关更多示例，请参见   <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.over" title="sqlalchemy.sql.expression.over"><code class="xref py py-func docutils literal notranslate"><span class="pre">over()</span></code></a> 。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>请注意，  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a>  方法只适用于那些实际上是聚合函数的SQL函数；虽然   :class:` _sql.Over`  构造会很愉快地为给定的任何SQL函数呈现自己，但如果函数本身不是SQL聚合函数，则数据库将拒绝表达式。.. _tutorial_functions_within_group:</p>
</div>
<section id="within-group-filter">
<h5>WITHIN GROUP, FILTER和特殊修改器<a class="headerlink" href="#within-group-filter" title="Permalink to this heading">¶</a></h5>
<p>“Within Group” SQL语法与”有序集”或”假设集合”函数一起使用。
通常的”有序集”函数包括``percentile_cont()``和``rank()``。
SQLAlchemy包括内置实现``_functions.rank``、<code class="docutils literal notranslate"><span class="pre">_functions.dense_rank</span></code>、
<code class="docutils literal notranslate"><span class="pre">_functions.mode</span></code>、<code class="docutils literal notranslate"><span class="pre">_functions.percentile_cont``和``_functions.percentile_disc</span></code>,
它们包括一个  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group" title="sqlalchemy.sql.functions.FunctionElement.within_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.within_group()</span></code></a>  方法:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     func.unnest(</span>
<span class="go">...         func.percentile_disc([0.25, 0.5, 0.75, 1]).within_group(user_table.c.name)</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">unnest</span><span class="p">(</span><span class="n">percentile_disc</span><span class="p">(:</span><span class="n">percentile_disc_1</span><span class="p">)</span><span class="w"> </span><span class="n">WITHIN</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
</div></pre></div>
</div>
<dl>
<dt>“Filter”由某些后端支持，以将聚合函数的范围限制为与返回的总行范围相比的特定子集，可以使用</dt><dd><p><a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter" title="sqlalchemy.sql.functions.FunctionElement.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.filter()</span></code></a>  方法:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count(address_table.c.email_address).filter(user_table.c.name == &quot;sandy&quot;),</span>
<span class="go">...         func.count(address_table.c.email_address).filter(</span>
<span class="go">...             user_table.c.name == &quot;spongebob&quot;</span>
<span class="go">...         ),</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">)</span><span class="w"> </span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">)</span><span class="w"> </span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(2, 1)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</dd>
</dl>
</section>
<section id="tutorial-functions-table-valued">
<span id="id27"></span><h5>表值函数<a class="headerlink" href="#tutorial-functions-table-valued" title="Permalink to this heading">¶</a></h5>
<p>表值SQL函数支持包含命名子元素的标量表示。
常用于JSON和ARRAY导向函数及如`_functions.generate_series()`等函数，
表值函数在FROM子句中指定，然后被引用为表，有时甚至被引用为列。
这种形式的函数在PostgreSQL数据库中非常突出，
但某些形式的表值函数也被SQLite、Oracle和SQL Server支持。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-valued-overview"><span class="std std-ref">Table values, Table and Column valued functions, Row and Tuple objects</span></a>  - 在   :ref:` postgresql_toplevel`  文档中。</p>
</div></blockquote>
<p>虽然很多数据库支持表值和其他特殊形式，但PostgreSQL通常是最需要这些功能的地方。
查看此部分以获取PostgreSQL语法的其他示例以及其他功能。</p>
</div>
<p>SQLAlchemy提供了  <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued" title="sqlalchemy.sql.functions.FunctionElement.table_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.table_valued()</span></code></a>  方法作为基本的“表值函数”结构，
它将函数  :_data:``  _sql.func` <cite>对象转换为包含一系列命名列的FROM子句，基于传递的字符串名称位置。
这会返回一个 :class:`_sql.TableValuedAlias</cite> 对象，这是一个启用函数的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 构造，
它可以像其他在  <a class="reference internal" href="#tutorial-using-aliases"><span class="std std-ref">使用别名</span></a> 中介绍的FROM子句一样使用。下面我们示例了`_functions.json_each()`函数，
该函数虽然在PostgreSQL上很常见，但也被现代版本的SQLite支持:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">onetwothree</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">json_each</span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">table_valued</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">onetwothree</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onetwothree</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     result.all()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">value</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">json_each</span><span class="p">(</span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;two&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;three&#39;</span><span class="p">)</span>
</div><span class="go">[(&#39;two&#39;,), (&#39;three&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>上面，我们使用SQLite和PostgreSQL支持的`json_each()` JSON函数生成了一个单列的表值表达式，
该列被称为`value`，然后选择了其三行中的两行。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-valued"><span class="std std-ref">Table-Valued Functions</span></a>  - 在   :ref:` postgresql_toplevel`  文档中 -</p>
</div></blockquote>
<p>此部分将详细介绍其他语法，例如特殊列派生和“WITH ORDINALITY”，这些语法已知有效地使用PostgreSQL。</p>
</div>
</section>
<section id="tutorial-functions-column-valued">
<span id="id28"></span><h5>列值函数 - 表值函数作为标量列<a class="headerlink" href="#tutorial-functions-column-valued" title="Permalink to this heading">¶</a></h5>
</section>
</section>
</section>
</section>
<section id="postgresqloracle">
<h2>PostgreSQL和Oracle支持的一种特殊语法是指向“表值函数作为标量列”的语法。数据类型转换与强制转换<a class="headerlink" href="#postgresqloracle" title="Permalink to this heading">¶</a></h2>
<p>在SQL中，我们经常需要明确表示表达式的数据类型，无论是告诉数据库在另一种不明确的表达式中期望什么类型，还是在某些情况下想要将SQL表达式的隐含数据类型转换成其他类型。SQL CAST关键字用于此任务，在SQLAlchemy中由  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> ` user_table.c.id``列对象生成SQL表达式``CAST(user_account.id AS VARCHAR)``：</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">cast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">String</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">result</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">{execsql}BEGIN (implicit)</span>
<span class="go">SELECT CAST(user_account.id AS VARCHAR) AS id</span>
<span class="go">FROM user_account</span>
<span class="go">[...] ()</span>
<span class="go">{stop}[(&#39;1&#39;,), (&#39;2&#39;,), (&#39;3&#39;,)]</span></pre></div>
</div>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> .cast` 成为 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 的字符串表达式将获得JSON下标和比较运算符，例如：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;{&#39;a&#39;: &#39;b&#39;}&quot;</span><span class="p">,</span> <span class="n">JSON</span><span class="p">)[</span><span class="s2">&quot;a&quot;</span><span class="p">])</span>
<span class="go">{printsql}CAST(:param_1 AS JSON)[:param_2]</span></pre></div>
</div>
</div></blockquote>
<section id="type-coerce-python">
<h3>type_coerce() - 一个仅限于Python的“转换”<a class="headerlink" href="#type-coerce-python" title="Permalink to this heading">¶</a></h3>
<p>有时需要让SQLAlchemy知道表达式的数据类型，出于上述所有原因，但不要在SQL端呈现CAST表达式，因为这可能会影响已无需CAST而正常工作的SQL操作。为这个相当普遍的用例，有另一个与  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> .type_coerce` ，它设置了一个Python表达式作为特定的SQL数据库类型，但不会在数据库方面呈现“CAST”关键字或数据类型。  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> .type_coerce` 将Python结构作为JSON字符串传递到MySQL的JSON函数之一：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">type_coerce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="kn">import</span> <span class="n">mysql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">type_coerce</span><span class="p">({</span><span class="s2">&quot;some_key&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">}},</span> <span class="n">JSON</span><span class="p">)[</span><span class="s2">&quot;some_key&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">mysql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span></pre></div>
</div>
<p>以上，因为我们使用  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> ，所以调用了MySQL的` <cite>JSON_EXTRACT`</cite> SQL函数，此时Python的``__getitem__``运算符，在这种情况下为``[‘some_key’]``，由此允许渲染``JSON_EXTRACT``路径表达式（未显示出来，但在这种情况下，它最终将是``’$.”some_key”’<a href="#id29"><span class="problematic" id="id30">``</span></a>）。</p>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="data_insert.html" title="previous chapter">使用 INSERT 语句</a>
        Next:
        <a href="data_update.html" title="next chapter">使用UPDATE和DELETE语句</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:59:04

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


