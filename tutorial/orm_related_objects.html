<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    处理 ORM 相关对象（Related Objects）
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="SQLAlchemy统一教程" href="index.html" />
        <link rel="next" title="进一步阅读" href="further_reading.html" />
        <link rel="prev" title="使用ORM进行数据操作" href="orm_data_manipulation.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy统一教程">SQLAlchemy统一教程</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="engine.html">建立连接 - 引擎</a></span></li>
<li><span class="link-container"><a class="reference external" href="dbapi_transactions.html">处理事务和DBAPI</a></span></li>
<li><span class="link-container"><a class="reference external" href="metadata.html">使用数据库元数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="data.html">处理数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm_data_manipulation.html">使用ORM进行数据操作</a></span></li>
<li class="selected"><span class="link-container"><strong>处理 ORM 相关对象（Related Objects）</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id1">持久化和加载关系对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="#session">将对象添加到会话（Session）中</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-loading-relationships">加载关联</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-select-relationships">在查询中使用关联</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#tutorial-joining-relationships">使用关联进行连接</a></span></li>
<li><span class="link-container"><a class="reference external" href="#where">关系 WHERE 运算符</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#tutorial-orm-loader-strategies">载入策略</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#in-load">选择 In Load</a></span></li>
<li><span class="link-container"><a class="reference external" href="#joined-load">Joined Load</a></span></li>
<li><span class="link-container"><a class="reference external" href="#join-eager-load">显式 JOIN + Eager load</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#querying-and-eager-loading">```查询与提前加载（Querying and Eager Loading）</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#raiseload">Raiseload</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="further_reading.html">进一步阅读</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="orm_data_manipulation.html" title="previous chapter">使用ORM进行数据操作</a></li>
                <li><b>Next:</b>
                <a href="further_reading.html" title="next chapter">进一步阅读</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy统一教程">SQLAlchemy统一教程</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#orm-related-objects">处理 ORM 相关对象（Related Objects）</a><ul>
<li><a class="reference internal" href="#id1">持久化和加载关系对象</a></li>
<li><a class="reference internal" href="#session">将对象添加到会话（Session）中</a></li>
<li><a class="reference internal" href="#tutorial-loading-relationships">加载关联</a></li>
<li><a class="reference internal" href="#tutorial-select-relationships">在查询中使用关联</a><ul>
<li><a class="reference internal" href="#tutorial-joining-relationships">使用关联进行连接</a></li>
<li><a class="reference internal" href="#where">关系 WHERE 运算符</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-orm-loader-strategies">载入策略</a><ul>
<li><a class="reference internal" href="#in-load">选择 In Load</a></li>
<li><a class="reference internal" href="#joined-load">Joined Load</a></li>
<li><a class="reference internal" href="#join-eager-load">显式 JOIN + Eager load</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-and-eager-loading">```查询与提前加载（Querying and Eager Loading）</a><ul>
<li><a class="reference internal" href="#raiseload">Raiseload</a></li>
</ul>
</li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar tutorial-orm_related_objects" >
        
<section class="orm-header" id="orm-related-objects">
<span id="tutorial-orm-related-objects"></span><h1>处理 ORM 相关对象（Related Objects）<a class="headerlink" href="#orm-related-objects" title="Permalink to this heading">¶</a></h1>
<p>本节中，我们将介绍 ORM 的另一个重要概念，即 ORM 如何与引用其他对象的映射类进行交互。在“声明映射类”一节中，映射类示例通过使用称为 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 的结构来实现。这个结构定义了两个不同的映射类之间的链接关系，或者自映射类，后者称为**自引用关系**。</p>
<p>为了描述 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 的基本思想，首先我们将简短地回顾一下映射，省略 <code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code> 映射和其他指令：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="c1"># ... mapped_column() mappings</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="c1"># ... mapped_column() mappings</span>

    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>上面，<code class="docutils literal notranslate"><span class="pre">User</span></code> 类现在有一个 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 属性，<code class="docutils literal notranslate"><span class="pre">Address</span></code> 类有一个 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性。 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 结构与 <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 结构配合使用，用于检查 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象之间的表关系，这些对象与 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类映射。由于代表 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象具有引用到 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>， <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 可以明确地确定 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类向 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类存在一种 <span class="xref std std-term">一对多</span> 关系，以及 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 关系；<code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表中的一个特定行可以被 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中的多行引用。</p>
<p>所有一对多关系自然都对应着另一方的 <span class="xref std std-term">多对一</span> 关系，在本例中，是被称为 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 的关系。如上面看到的 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code> 参数，两个 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 对象都配置了另一个名称，这表明两个 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 结构应被视为相互补充；下一节中我们将看到它是如何运作的。</p>
<section id="id1">
<h2>持久化和加载关系对象<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>我们可以通过演示 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 对对象实例的行为来开始。如果我们创建一个新的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象，我们可以注意到，在访问 <code class="docutils literal notranslate"><span class="pre">.addresses</span></code> 元素时，有一个 Python 列表:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;pkrabs&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Pearl Krabs&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span></pre></div>
</div>
<p>此对象是 Python <code class="docutils literal notranslate"><span class="pre">list</span></code> 的 SQLALchemy 特定版本，它具有跟踪并响应其变化的能力。即使我们从未将其分配给对象，这个集合也会自动出现，这类似于在 <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">使用ORM Unit of Work模式插入行</span></a> 中观察到的行为，其中注意到我们没有明确将值赋给的基于列的属性也会自动显示为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，而不是像 Python 的通常行为那样引发 <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">u1</span></code> 对象仍然是 <span class="xref std std-term">transient</span> 的，而我们从 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 中获取的 <code class="docutils literal notranslate"><span class="pre">list</span></code> 未被更改，因此它实际上还没有与该对象相关联，但是随着我们对其进行更改，它将成为 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象的状态的一部分。</p>
<p>该集合特定于 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类，它是唯一可以在其中持久化的 Python 对象类型。使用 <code class="docutils literal notranslate"><span class="pre">list.append()</span></code> 方法，我们可以添加 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;pearl.krabs@gmail.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span></pre></div>
</div>
<p>此时，预期的 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 集合包含新的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=None, email_address=&#39;pearl.krabs@gmail.com&#39;)]</span></pre></div>
</div>
<p>由于我们使用了 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code> 参数，在两个引用不同名称的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 对象上进行了配置，可以从 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象导航到 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象，我们还可以从 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象导航回“父” <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">user</span>
<span class="go">User(id=None, name=&#39;pkrabs&#39;, fullname=&#39;Pearl Krabs&#39;)</span></pre></div>
</div>
<p>在这两个  <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 对象之间的互补属性赋值/列表变异将被考虑。若我们创建另一个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象并将其分配给 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性，那么``Address`` 对象将成为该``User`` 对象上的``User.addresses`` 集合的一部分：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;pearl@aol.com&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=None, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=None, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>我们实际上在 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 构造函数中使用了 <code class="docutils literal notranslate"><span class="pre">user</span></code> 参数作为关键字参数，其与在 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类上声明的其他映射属性一样被接受。它等效于在事实之后分配 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性：</p>
<blockquote>
<div><p># 等效作用于 a2 = Address(user=u1)
&gt;&gt;&gt; a2.user = u1</p>
</div></blockquote>
</section>
<section id="session">
<span id="tutorial-orm-cascades"></span><h2>将对象添加到会话（Session）中<a class="headerlink" href="#session" title="Permalink to this heading">¶</a></h2>
<p>我们现在有一个关联的双向结构中的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和两个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象，但正如在 <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">使用ORM Unit of Work模式插入行</span></a> 中所述，在它们与 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 对象相关联之前，这些对象被称为 <span class="xref std std-term">transient</span>。</p>
<p>我们使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>，并注意到当我们将 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code> 方法应用于“主” <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象时，相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象也被添加到同一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 中:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span></pre></div>
</div>
<p>上面的行为中，当 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 接收到 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象，并沿着 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 关系寻找一个相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象时，它会遵循“save-update cascade”，并决定使用同一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 对象插入所有相关的记录。ORM 参考文档在 <span class="xref std std-ref">unitofwork_cascades</span> 中详细介绍了这种行为。</p>
<p>三个对象现在处于 <span class="xref std std-term">pending</span> 状态；这意味着它们已准备好成为插入操作的对象，但这尚未进行；所有三个对象还没有分配主键，并且 <code class="docutils literal notranslate"><span class="pre">a1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a2</span></code> 对象还有一个名为 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 的属性，引用有一个 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> 引用 <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> 列的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>；因为这些对象尚未与真正的数据库行相关联，因此它们也是 <code class="docutils literal notranslate"><span class="pre">None</span></code>：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">None</span></pre></div>
</div>
<p>此时，我们可以看到单元操作（unit of work）过程提供的特别方便；回顾 <a class="reference internal" href="data_insert.html#tutorial-core-insert-values-clause"><span class="std std-ref">INSERT 通常会自动生成 “values” 子句</span></a> 中，在 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中插入行时，使用了一些复杂的语法，以便自动将 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 列与 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行的那些列相关联。此外，在 <code class="docutils literal notranslate"><span class="pre">address</span></code> 行之前必须先执行插入 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行，因为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 行**依赖于**它们的父行 <code class="docutils literal notranslate"><span class="pre">user_account</span></code>，在其 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 列中需要一个值。当使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 时，所有这些繁琐的工作都是由它来处理的，即使是最执着的 SQL 纯洁主义者也可以从 INSERT、UPDATE 和 DELETE 语句的自动化中获益。当我们通过 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code> 提交事务时，所有步骤按正确顺序执行，此外新生成的 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行的主键将正确应用于 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 列：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<div class='show_sql'><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">fullname</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pkrabs&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Pearl Krabs&#39;</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span>
<span class="p">[...</span><span class="w"> </span><span class="p">(</span><span class="n">insertmanyvalues</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">supported</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pearl.krabs@gmail.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span>
<span class="p">[</span><span class="n">insertmanyvalues</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">supported</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pearl@aol.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
</section>
<section id="tutorial-loading-relationships">
<span id="id2"></span><h2>加载关联<a class="headerlink" href="#tutorial-loading-relationships" title="Permalink to this heading">¶</a></h2>
<p>在上一步中，我们调用了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code>，它发出了一个事务的 COMMIT命令，然后使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.commit.expire_on_commit</span></code> 对所有对象进行过期，以便它们在下一个事务中刷新。</p>
<p>下一次访问这些对象的属性时，我们将看到主键属性的 SELECT 语句已经发出，例如当我们查看 <code class="docutils literal notranslate"><span class="pre">u1</span></code> 对象的新生成主键时：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">id</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_name</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">6</span></pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">u1</span></code> <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象现在具有持久化的集合 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>，我们也可以访问它。由于该集合由 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中的另一组行组成，因此当我们再次访问此集合时，将再次发出 <span class="xref std std-term">lazy load</span> 以检索对象：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">[Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=5, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>ORM 中的集合和关联属性在内存中是持久的。一旦集合或属性被填充，直到重新 <span class="xref std std-term">expired</span>，SQL 才不会再次发出。我们可以再次访问 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code>，添加或删除项目，这不会产生任何新的 SQL 调用：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=5, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>如果我们不采取明确的步骤对其进行优化，懒加载可能会很快地变得耗费资源。所有那些未加载的属性的网络构成“懒加载”的状态都被精心地优化，以便不执行冗余操作;由于 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 集合被刷新，根据 <span class="xref std std-term">identity map</span>，这实际上是与我们已经处理过的 <code class="docutils literal notranslate"><span class="pre">a1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a2</span></code> 对象相同的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 实例，因此我们已经完成了加载此特定对象图中的所有属性。</p>
<p>关系载入的加载方式是一个非常重要的主题，需要单独讨论。下一节在 <a class="reference internal" href="#tutorial-orm-loader-strategies"><span class="std std-ref">载入策略</span></a> 中会介绍这些概念。</p>
</section>
<section id="tutorial-select-relationships">
<span id="id3"></span><h2>在查询中使用关联<a class="headerlink" href="#tutorial-select-relationships" title="Permalink to this heading">¶</a></h2>
<p>在上一节中，我们介绍了 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 在处理**映射类实例**时的行为，也就是 <code class="docutils literal notranslate"><span class="pre">u1</span></code>、<code class="docutils literal notranslate"><span class="pre">a1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a2</span></code> 等 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类的实例。在本节中，我们将介绍 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 作为映射类**类级别行为**的行为，其中它有助于自动化 SQL 查询的构建。</p>
<section id="tutorial-joining-relationships">
<span id="id4"></span><h3>使用关联进行连接<a class="headerlink" href="#tutorial-joining-relationships" title="Permalink to this heading">¶</a></h3>
<p>“选择 JOIN”一节和“选择 ON Clause”一节介绍了 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 方法来组成 SQL 连接子句。为了描述如何在表之间进行连接，这些方法可以根据表元数据结构中单个含糊的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> 对象的存在推断出 ON 子句，或者我们可以提供显示的 SQL 表达式构造，表示一个特定的 ON 子句。</p>
<p>在使用 ORM 实体时，为了帮助我们设置 join 的 ON 子句，还提供了另一种机制，即利用我们在映射中设置的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 对象，例如在“声明映射类”一节中演示的方式。与 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象之间的表关系将在 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 中使用，该对象将作为**单个参数**传递到 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 方法中，其中它表示右侧的连接，并在一次指定中同时指定On子句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>如果没有指定 ON 子句，那么在 <code class="docutils literal notranslate"><span class="pre">User</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 的连接中仍然起作用，是因为两个映射的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象之间有一个 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>，而不是在 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类上的 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 对象：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">))</span>
<span class="go">{printsql}SELECT address.email_address</span>
<span class="go">FROM user_account JOIN address ON user_account.id = address.user_id</span></pre></div>
</div>
<p>有关如何使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 的示例，可参见 <span class="xref std std-ref">orm_queryguide_joins</span>。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>在 <span class="xref std std-ref">queryguide_toplevel</span> 中的 <span class="xref std std-ref">orm_queryguide_joins</span></p>
</div>
</section>
<section id="where">
<span id="tutorial-relationship-operators"></span><h3>关系 WHERE 运算符<a class="headerlink" href="#where" title="Permalink to this heading">¶</a></h3>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 中还有一些其他类型的 SQL 生成帮助程序，通常在生成语句的 WHERE 子句时非常有用。请参见 <span class="xref std std-ref">queryguide_relationship_operators</span> 中的示例。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>在 <span class="xref std std-ref">queryguide_toplevel</span> 中 <span class="xref std std-ref">orm_queryguide_relationship_operators</span></p>
</div>
</section>
</section>
<section id="tutorial-orm-loader-strategies">
<span id="id5"></span><h2>载入策略<a class="headerlink" href="#tutorial-orm-loader-strategies" title="Permalink to this heading">¶</a></h2>
<p>在 <a class="reference internal" href="#tutorial-loading-relationships"><span class="std std-ref">加载关联</span></a> 中，介绍了当我们处理映射对象的实例时，访问使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 映射的属性在默认情况下将发出 <span class="xref std std-term">lazy load</span>，以加载应该存在于该集合中的对象。</p>
<p>延迟加载是 ORM 模式中最著名的模式之一，也是最具争议的。当许多 ORM 对象都引用同一相关对象（例如，许多 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象都引用相同的 <code class="docutils literal notranslate"><span class="pre">User</span></code>），操作这些对象时会产生大量冗余查询，可能会加起来（也被称为 <span class="xref std std-term">N加1</span> 问题），更糟糕的是它们是隐式发出的。如果不能注意到这些隐式查询，当他们在数据库事务不再可用时尝试访问他们或者在使用其他并发模式（如 <a class="reference internal" href="../orm/extensions/asyncio.html"><span class="std std-ref">asyncio</span></a>）时都会引发错误。</p>
<p>同时，懒加载是一个非常受欢迎和有用的模式，如果与正在使用的并发方法兼容并且没有引起问题，则可以多方面受益于 SQLAlchemy 的 ORM。</p>
<p>首先，使用 ORM 懒加载的有效方法是**测试应用程序，启用 SQL 追踪，查看已发出的 SQL 语句**。如果出现许多看起来非常像可以合并在一起的冗余 SELECT 语句，如果对已经与其 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 分离的对象尝试执行这些语句，则可能会引发错误。如果使用另一种并发方法，例如 <a class="reference internal" href="../orm/extensions/asyncio.html"><span class="std std-ref">asyncio</span></a>，这些隐式查询实际上根本不起作用。</p>
<p>最重要的是，使用 ORM 加载延迟式加载的首要步骤是**测试应用程序，启用 SQL 追踪，并查看输出的 SQL**语句。</p>
<p>总之，负责管理对象状态的 ORM 查询层放置了很多重点在能够控制和优化这种加载行为方面。</p>
<p>最重要的基本概念是要掌握如何使用加载器策略来提高性能。</p>
<p>加载器策略被表示为对象，可以使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.options" title="sqlalchemy.sql.expression.Select.options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.options()</span></code></a> 方法将其与 SELECT 语句关联起来，例如:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go">for user_obj in session.execute(</span>
<span class="go">    select(User).options(selectinload(User.addresses))</span>
<span class="go">).scalars():</span>
<span class="go">    user_obj.addresses  # 访问已经加载的地址集合</span></pre></div>
</div>
<p>它们也可以在 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 中默认配置，使用 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.lazy</span></code> 选项，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s2">&quot;selectin&quot;</span>
    <span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>每种加载器策略对象都会向一条 SELECT 语句中添加某种类型的信息，稍后，当 :class:<a href="#id6"><span class="problematic" id="id7">`</span></a>_orm.Session`决定应该如何加载和/或在访问属性时如何行事时，这些信息将被使用。</p>
<p>下面的章节将介绍一些最常用的加载器策略。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>两个 <span class="xref std std-ref">loading_toplevel</span> 中的部分：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#relationship-lazy-option"><span class="std std-ref">在映射时配置加载器策略</span></a> - 关于如何在 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship`()</span></code> 中配置此策略</p></li>
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#relationship-loader-options"><span class="std std-ref">使用加载程序选项加载关系</span></a> - 关于使用查询时加载器策略的详细信息</p></li>
</ul>
</div>
<section id="in-load">
<h3>选择 In Load<a class="headerlink" href="#in-load" title="Permalink to this heading">¶</a></h3>
<p>在现代 SQLAlchemy 中，最有用的加载器是 <code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code> 加载程序。此选项解决了“N加1”问题的最常见形式，即一组对象引用相关集合。 <code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code> 将确保使用单个查询前端加载要加载的集合的完整一系列对象。它使用的 SELECT 语句的形式通常可以针对相关表本身进行发射，无需加入连接或次查询，并且仅针对未加载集合的那些父对象查询进行查询。下面的例子演示了 <code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code>，加载所有的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象及其所有相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象；虽然我们仅在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code> 中传递一次 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造，但在访问数据库时，实际上发出了两个 SELECT 语句，第二个 SELECT 用于获取相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">selectinload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(</span>
<span class="go">...         f&quot;{row.User.name}  ({&#39;, &#39;.join(a.email_address for a in row.User.addresses)})&quot;</span>
<span class="go">...     )</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
</div><span class="go">spongebob  (spongebob@sqlalchemy.org)</span>
<span class="go">sandy  (sandy@sqlalchemy.org, sandy@squirrelpower.org)</span>
<span class="go">patrick  ()</span>
<span class="go">squidward  ()</span>
<span class="go">ehkrabs  ()</span>
<span class="go">pkrabs  (pearl.krabs@gmail.com, pearl@aol.com)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">selectin_eager_loading</span> - 在 <span class="xref std std-ref">loading_toplevel</span> 中</p>
</div>
</section>
<section id="joined-load">
<h3>Joined Load<a class="headerlink" href="#joined-load" title="Permalink to this heading">¶</a></h3>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code> 构建一个 JOIN 语句，用于修改即将传递到数据库的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 的方式。具体而言，在返回一个主实体行时，它向其中添加了几列，可以加载相关联的对象。</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code> 策略最适合加载相关的多对一对象，因为仅需要为要选取的主实体行添加一些附加列。为了提高效率，它还接受一个 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">joinedload.innerjoin</span></code> 选项，因此可以使用内连接代替外连接等选项，例如下面这个选项，我们知道所有 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象都有关联的 <code class="docutils literal notranslate"><span class="pre">User</span></code>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">joinedload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .options(joinedload(Address.user, innerjoin=True))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(f&quot;{row.Address.email_address} {row.Address.user.name}&quot;)</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span>
<span class="n">user_account_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">spongebob@sqlalchemy.org spongebob</span>
<span class="go">sandy@sqlalchemy.org sandy</span>
<span class="go">sandy@squirrelpower.org sandy</span>
<span class="go">pearl.krabs@gmail.com pkrabs</span>
<span class="go">pearl@aol.com pkrabs</span></pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code> 也适用于集合，也就是一对多关系，但是它会导致递归方式将主要行乘以关联项，以一种让结果集按级数以数量级增长的递归方式增加发送给的数据量，对于嵌套集合和/或更大的集合来说非常低效，因此与其他选项（如 <code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code>）相比，必须在每种情况下进行评估。</p>
<p>重要提示：</p>
<p>对于许多业务对象，往往没有必要使用多对一的即时加载，因为“N加1”问题在常见情况下的存在要少得多。例如，如果许多对象都引用同一个相关对象（例如，许多 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象都引用相同的 <code class="docutils literal notranslate"><span class="pre">User</span></code>），SQL 仅一次针对该 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象进行查询，使用正常的懒加载。懒加载例程尽可能地在当前 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 中查找相关对象主键。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#joined-eager-loading"><span class="std std-ref">连接式“通常负载”</span></a> - 在 <span class="xref std std-ref">loading_toplevel</span> 中</p>
</div>
</section>
<section id="join-eager-load">
<span id="tutorial-orm-loader-strategies-contains-eager"></span><h3>显式 JOIN + Eager load<a class="headerlink" href="#join-eager-load" title="Permalink to this heading">¶</a></h3>
<p>假设我们使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 渲染连接从 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表中加载 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 行，我们还可以利用它来在返回的每个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象上即时加载 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性的内容。本质上，这就是我们使用“连接加载”（joined eager loading），并自己渲染连接。使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code> 选项可以实现这个普遍使用的用例。该选项与 <code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code> 非常相似，只是它假设我们已经设置了 JOIN，并将其用于返回的每个对象上的相关属性中，例如：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">contains_eager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .join(Address.user)</span>
<span class="go">...     .where(User.name == &quot;pkrabs&quot;)</span>
<span class="go">...     .options(contains_eager(Address.user))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(f&quot;{row.Address.email_address} {row.Address.user.name}&quot;)</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pkrabs&#39;</span><span class="p">,)</span>
</div><span class="go">pearl.krabs@gmail.com pkrabs</span>
<span class="go">pearl@aol.com pkrabs</span></pre></div>
</div>
<p>上面，我们过滤了 <code class="docutils literal notranslate"><span class="pre">user_account.name</span></code> 行并在 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性中加载了 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 的行。如果我们单独应用 <code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code>，则会多次加入 SQL 查询：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;pkrabs&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>  <span class="c1"># SELECT has a JOIN and LEFT OUTER JOIN unnecessarily</span>
<span class="go">{printsql}SELECT address.id, address.email_address, address.user_id,</span></pre></div>
</div>
</section>
</section>
<section id="querying-and-eager-loading">
<h2><a href="#id8"><span class="problematic" id="id9">``</span></a><a href="#id10"><span class="problematic" id="id11">`</span></a>查询与提前加载（Querying and Eager Loading）<a class="headerlink" href="#querying-and-eager-loading" title="Permalink to this heading">¶</a></h2>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">查询与提前加载</span></p>
<p>Two sections in <span class="xref std std-ref">加载顶层</span>:</p>
<ul class="simple">
<li><p><span class="xref std std-ref">急加载的基础知识</span> - 详细描述了上述问题</p></li>
<li><p><span class="xref std std-ref">包含急加载</span> - 使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code></p></li>
</ul>
</div>
<section id="raiseload">
<h3>Raiseload<a class="headerlink" href="#raiseload" title="Permalink to this heading">¶</a></h3>
<p>值得一提的另一种加载器策略是 <code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code>。
此选项用于完全阻止应用程序出现 <span class="xref std std-term">N plus one</span> 问题，
这是通过导致通常会是懒加载的内容引发错误来实现的。
它有两个变体，可以通过 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">raiseload.sql_only</span></code> 选项进行控制，
以阻止需要 SQL 的懒加载，还是所有 “load” 操作，包括那些只需要查询 current
<code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>。</p>
<p>可以使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code> 的一种方法是在 <code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code> 上直接配置它，
方法是将 <code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.lazy</span></code> 设置为值 <code class="docutils literal notranslate"><span class="pre">&quot;raise_on_sql&quot;</span></code>，以使特定的映射中，
某个关系永远不会尝试发出 SQL：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;user_account&quot;</span>
<span class="go">...     id: Mapped[int] = mapped_column(primary_key=True)</span>
<span class="go">...     addresses: Mapped[List[&quot;Address&quot;]] = relationship(</span>
<span class="go">...         back_populates=&quot;user&quot;, lazy=&quot;raise_on_sql&quot;</span>
<span class="go">...     )</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;address&quot;</span>
<span class="go">...     id: Mapped[int] = mapped_column(primary_key=True)</span>
<span class="go">...     user_id: Mapped[int] = mapped_column(ForeignKey(&quot;user_account.id&quot;))</span>
<span class="go">...     user: Mapped[&quot;User&quot;] = relationship(back_populates=&quot;addresses&quot;, lazy=&quot;raise_on_sql&quot;)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>使用这样的映射，应用程序被阻止懒加载，
表明特定查询需要指定加载器策略：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">scalars</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.id FROM user_account</span>
<span class="go">[...] ()</span>
<span class="go">{stop}&gt;&gt;&gt; u1.addresses</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">sqlalchemy.exc.InvalidRequestError</span>: <span class="n">&#39;User.addresses&#39; is not available due to lazy=&#39;raise_on_sql&#39;</span></pre></div>
</div>
<p>异常将表明该集合应在前期加载：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">scalars</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{execsql}SELECT user_account.id</span>
<span class="go">FROM user_account</span>
<span class="go">[...] ()</span>
<span class="go">SELECT address.user_id AS address_user_id, address.id AS address_id</span>
<span class="go">FROM address</span>
<span class="go">WHERE address.user_id IN (?, ?, ?, ?, ?, ?)</span>
<span class="go">[...] (1, 2, 3, 4, 5, 6)</span></pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lazy=&quot;raise_on_sql&quot;</span></code> 选项也会尝试在许多对一关系方面变得更加智能；
在上面的示例中，如果一个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性未加载，
但该 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象在同一 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 中，则 “raiseload” 策略不会引发错误。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#prevent-lazy-with-raiseload"><span class="std std-ref">防止懒加载</span></a> - 在 <span class="xref std std-ref">加载顶层</span></p>
</div>
</section>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="orm_data_manipulation.html" title="previous chapter">使用ORM进行数据操作</a>
        Next:
        <a href="further_reading.html" title="next chapter">进一步阅读</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 10:07:19

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


