<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    使用事务和DBAPI
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="SQLAlchemy统一教程" href="index.html" />
        <link rel="next" title="使用数据库元数据" href="metadata.html" />
        <link rel="prev" title="建立连接 - Engine" href="engine.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy统一教程">SQLAlchemy统一教程</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="engine.html">建立连接 - Engine</a></span></li>
<li class="selected"><span class="link-container"><strong>使用事务和DBAPI</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#tutorial-getting-connection">获取连接</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-committing-data">提交更改</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-statement-execution">语句执行的基本知识</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#tutorial-fetching-rows">提取行数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-sending-parameters">发送参数</a></span></li>
<li><span class="link-container"><a class="reference external" href="#tutorial-multiple-parameters">发送多个参数</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#orm-session">使用 ORM Session 执行</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="metadata.html">使用数据库元数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="data.html">使用数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm_data_manipulation.html">使用ORM操作数据</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm_related_objects.html">使用 ORM 相关对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="further_reading.html">更多阅读</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="engine.html" title="previous chapter">建立连接 - Engine</a></li>
                <li><b>Next:</b>
                <a href="metadata.html" title="next chapter">使用数据库元数据</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy统一教程">SQLAlchemy统一教程</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#dbapi">使用事务和DBAPI</a><ul>
<li><a class="reference internal" href="#tutorial-getting-connection">获取连接</a></li>
<li><a class="reference internal" href="#tutorial-committing-data">提交更改</a></li>
<li><a class="reference internal" href="#tutorial-statement-execution">语句执行的基本知识</a><ul>
<li><a class="reference internal" href="#tutorial-fetching-rows">提取行数据</a></li>
<li><a class="reference internal" href="#tutorial-sending-parameters">发送参数</a></li>
<li><a class="reference internal" href="#tutorial-multiple-parameters">发送多个参数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#orm-session">使用 ORM Session 执行</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar tutorial-dbapi_transactions" >
        
<section id="dbapi">
<span id="tutorial-working-with-transactions"></span><h1>使用事务和DBAPI<a class="headerlink" href="#dbapi" title="Permalink to this heading">¶</a></h1>
<p>现在我们已经准备好使用  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 。此外，我们还将介绍ORM的这些对象的外观，称为  :class:` _orm.Session` 。</p>
<div class="orm-header docutils container">
<p><strong>适用于ORM读者的注意事项</strong></p>
<p>当使用ORM时， <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 由称为 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 的另一个对象管理。现代SQLAlchemy中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 强调了一种事务性和SQL执行模式，这在很大程度上与下文中讨论的 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 相同，因此，虽然这个子部分是针对Core的，但是这里的所有概念基本上也与ORM使用相关，并建议所有ORM学习者使用。下面将对 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 使用的执行模式与 <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 进行对比。</p>
</div>
<p>由于我们还没有介绍SQLAlchemy表达式语言是SQLAlchemy的主要特性，因此我们将使用这个软件包中的一种简单构造，称为 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 构造，该构造允许我们将SQL语句编写为文本SQL。请放心，在日常SQLAlchemy使用中，文本SQL往往是大多数任务的例外，尽管它始终完全可用。</p>
<section class="core-header" id="tutorial-getting-connection">
<span id="id1"></span><h2>获取连接<a class="headerlink" href="#tutorial-getting-connection" title="Permalink to this heading">¶</a></h2>
<p>从用户界面的角度看， <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 对象的唯一目的是提供称为 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 的数据库连接单位。当直接处理Core时， <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象是与数据库交互的全部操作。由于 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 表示与数据库打开的资源，因此我们希望始终将此对象的使用范围限制为特定上下文，并且最好使用Python上下文管理器格式，也称为“with语句”。下面我们使用一个文本SQL语句说明“Hello World”。稍后将讨论名为 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 的文本SQL构造的更多细节：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(text(&quot;select &#39;hello world&#39;&quot;))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">select</span><span class="w"> </span><span class="s1">&#39;hello world&#39;</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;hello world&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>在上面的示例中，上下文管理器提供了一个数据库连接，并将操作放置在事务内。Python DBAPI的默认行为包括始终存在事务；当连接的范围为“released”时，将发出ROLLBACK来结束事务。这个事务**不会自动提交**。我们通常需要调用  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.commit" title="sqlalchemy.engine.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.commit()</span></code></a>  来提交数据，如下一节所示。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>对于特殊情况，可以使用“autocommit”模式。本文后面将会讨论。</p>
</div>
<p>我们的SELECT的结果也返回一个称为 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> 的对象，稍后我们将讨论它，但是暂时添加的最好是确保在“connect”块内使用此对象，并且不将其传递到连接范围之外。</p>
</section>
<section class="core-header" id="tutorial-committing-data">
<span id="id2"></span><h2>提交更改<a class="headerlink" href="#tutorial-committing-data" title="Permalink to this heading">¶</a></h2>
<p>我们刚刚学习到，DBAPI连接不会自动提交。如果我们想要提交一些数据怎么办？可以更改我们上面的示例以创建一个表并插入一些数据，随后使用  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.commit" title="sqlalchemy.engine.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.commit()</span></code></a>  方法在我们获取 :class:` _engine.Connection`对象的块**内**提交事务：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go"># &quot;commit as you go&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     conn.execute(text(&quot;CREATE TABLE some_table (x int, y int)&quot;))</span>
<span class="go">...     conn.execute(</span>
<span class="go">...         text(&quot;INSERT INTO some_table (x, y) VALUES (:x, :y)&quot;),</span>
<span class="go">...         [{&quot;x&quot;: 1, &quot;y&quot;: 1}, {&quot;x&quot;: 2, &quot;y&quot;: 4}],</span>
<span class="go">...     )</span>
<span class="go">...     conn.commit()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="nb">int</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>

<span class="o">&lt;</span><span class="n">sqlalchemy</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="k">cursor</span><span class="p">.</span><span class="n">CursorResult</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)]</span>
<span class="o">&lt;</span><span class="n">sqlalchemy</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="k">cursor</span><span class="p">.</span><span class="n">CursorResult</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
<p>在上面的代码中，我们发出了两个通常是事务性的 SQL 语句，一个是 “CREATE TABLE” 语句 <a class="footnote-reference brackets" href="#id4" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>，另一个是参数化的 “INSERT” 语句（参数化的语法在下面的   <a class="reference internal" href="#tutorial-multiple-parameters"><span class="std std-ref">发送多个参数</span></a>  节中会进一步讨论）。我们执行  :meth:` _engine.Connection.commit`  方法，将我们在该块内的操作提交，以便事务生效。当我们在代码块内调用此方法之后，可以继续运行更多 SQL 语句，并且如果我们选择了，可以在随后的语句中再次调用  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.commit" title="sqlalchemy.engine.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.commit()</span></code></a> 。SQLAlchemy 将这种风格称之为 <strong>逐步提交</strong>。</p>
<p>另一种提交数据的方式是，在事先声明我们的 “connect” 代码块是事务块的情况下。为了实现该操作模式，我们使用  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine.begin" title="sqlalchemy.engine.Engine.begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.begin()</span></code></a>  方法来获取连接，而不是使用  :meth:` _engine.Engine.connect`  的范围，并将其封装到一个事务中，以确保最终提交数据（如果该块成功）或回滚（如果抛出异常）。这种风格可以被称之为 <strong>一次性开启事务</strong>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go"># &quot;一次性开启事务&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     conn.execute(</span>
<span class="go">...         text(&quot;INSERT INTO some_table (x, y) VALUES (:x, :y)&quot;),</span>
<span class="go">...         [{&quot;x&quot;: 6, &quot;y&quot;: 8}, {&quot;x&quot;: 9, &quot;y&quot;: 10}],</span>
<span class="go">...     )</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)]</span>
<span class="o">&lt;</span><span class="n">sqlalchemy</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="k">cursor</span><span class="p">.</span><span class="n">CursorResult</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
<p>一次性开启事务的风格通常更简洁，并在一开始就指示整个块的意图。然而，在本教程中，我们通常使用 “逐步提交” 的方式，因为这种方式更灵活，便于演示。</p>
<aside class="topic">
<p class="topic-title">什么是 “BEGIN (implicit)”？</p>
<p>你可能注意到日志中在事务块开头处出现了 “BEGIN (implicit)” 字样。这里的 “implicit” 表示 SQLAlchemy 实际上**没有向数据库发送任何指令**；它只是认为这是 DBAPI 隐式事务的开始。你可以注册   <a class="reference internal" href="../core/events.html#core-sql-events"><span class="std std-ref">事件回调函数</span></a>  来拦截此事件，进行进一步处理。</p>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>DDL 是指 SQL 子集，该子集指示数据库创建、修改或删除表等模式层面的结构。DDL（例如 “CREATE TABLE” ）建议在事务块内运行并以 COMMIT 结束，因为许多数据库使用事务 DDL 使得模式更改在事务提交之前不会生效。但是，正如稍后将要看到的，我们通常让 SQLAlchemy 在更高级别操作中运行 DDL 序列，我们通常不需要担心 COMMIT。</p>
</aside>
</aside>
</section>
<section class="core-header" id="tutorial-statement-execution">
<span id="id5"></span><h2>语句执行的基本知识<a class="headerlink" href="#tutorial-statement-execution" title="Permalink to this heading">¶</a></h2>
<p>我们已经看到了一些示例，演示了如何使用称为  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>  的方法远程运行 SQL 语句，与称为   :func:` _sql.text`  的其他对象一起使用，并返回名为   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  的对象。在本节中，我们将更加详细地说明这些组件的机制和相互作用。</p>
<div class="orm-header docutils container">
<p>当使用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code>  方法时，大部分此节的内容同样适用于现代 ORM 的使用方式，该方法与  :meth:` _engine.Connection.execute`  的工作方式非常相似，包括 ORM 结果行是使用同样的   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  接口，被 Core 使用。</p>
</div>
<section class="orm-addin" id="tutorial-fetching-rows">
<span id="id6"></span><h3>提取行数据<a class="headerlink" href="#tutorial-fetching-rows" title="Permalink to this heading">¶</a></h3>
<p>我们首先将通过运行文本 SELECT语句，从我们的刚刚创建的表中选取数据，来具体演示   <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  对象。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(text(&quot;SELECT x, y FROM some_table&quot;))</span>
<span class="go">...     for row in result:</span>
<span class="go">...         print(f&quot;x: {row.x}  y: {row.y}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">some_table</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">x: 1  y: 1</span>
<span class="go">x: 2  y: 4</span>
<span class="go">x: 6  y: 8</span>
<span class="go">x: 9  y: 10</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>在上述代码中，我们执行的 “SELECT” 语句是选取表中的所有行。返回的对象称为  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> ，代表结果行的可迭代对象。</p>
<blockquote>
<div><blockquote>
<div><p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>  方法，返回所有 :class:` _engine.Row`对象的列表。它还实现了Python迭代器接口，使我们可以直接遍历 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象的集合。</p>
</div></blockquote>
<p><a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象本身旨在像Python`命名元组&lt;<a class="reference external" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.namedtuple">https://docs.python.org/zh-cn/3/library/collections.html#collections.namedtuple</a>&gt;`_一样。下面我们举例说明了各种访问行的方法。</p>
</div></blockquote>
<ul>
<li><p><strong>元组赋值</strong> - 这是最Python化的风格，即根据接收顺序将变量分配给每个行位置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;select x, y from some_table&quot;</span><span class="p">))</span>

<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="o">...</span></pre></div>
</div>
</li>
<li><p><strong>整数索引</strong> - 元组是Python序列，因此也可以进行常规的整数访问：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;select x, y from some_table&quot;</span><span class="p">))</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></pre></div>
</div>
</li>
<li><p><strong>属性名称</strong> - 因为这些是Python命名元组，元组具有与每个列名称匹配的动态属性名称。这些名称通常是SQL语句为每行分配到的列名。虽然它们通常是可以预测的，并且还可以通过标签进行控制，但在更少定义的情况下，它们可能受特定于数据库的行为的影响：</p>
<blockquote>
<div><p>result = conn.execute(text(“select x, y from some_table”))</p>
<dl>
<dt>for row in result:</dt><dd><p>y = row.y</p>
<p># 说明如何使用Python的f-strings
print(f”Row: {row.x} {y}”)</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p><strong>映射访问</strong> - 要将行接收为Python**映射**对象，这实际上是Python的接口的只读版本与常见的“dict”对象，  <code class="xref py py-class docutils literal notranslate"><span class="pre">结果</span></code>  修饰符将变换成一个 :class:` _engine.MappingResult`对象；这是一个结果对象，它生成类似于字典的 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.RowMapping" title="sqlalchemy.engine.RowMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowMapping</span></code></a> 对象而不是 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;select x, y from some_table&quot;</span><span class="p">))</span>

<span class="k">for</span> <span class="n">dict_row</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">mappings</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">dict_row</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">dict_row</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span></pre></div>
</div>
</li>
</ul>
</section>
<section class="orm-addin" id="tutorial-sending-parameters">
<span id="id7"></span><h3>发送参数<a class="headerlink" href="#tutorial-sending-parameters" title="Permalink to this heading">¶</a></h3>
<p>SQL语句通常由要与语句本身一起传递的数据附件，如我们之前在INSERT示例中看到的一样。因此  <code class="xref py py-meth docutils literal notranslate"><span class="pre">sqlalchemy.engine.连接()</span></code>  方法也接受参数，这些参数被称为  :term:` bound parameters`  。一个初步的示例可能是，如果我们只想将SELECT语句限制为仅符合某些条件的行，例如仅当“y”值大于传递给函数的某个值时，我们添加名为“y”的新参数的WHERE条件到我们的语句中；  <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> ` :y``”接受这些条件。然后将“<code class="docutils literal notranslate"><span class="pre">:y</span></code>”的实际值以字典的形式作为  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>  的第二个参数传递：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(text(&quot;SELECT x, y FROM some_table WHERE y &gt; :y&quot;), {&quot;y&quot;: 2})</span>
<span class="go">...     for row in result:</span>
<span class="go">...         print(f&quot;x: {row.x}  y: {row.y}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
</div><span class="go">x: 2  y: 4</span>
<span class="go">x: 6  y: 8</span>
<span class="go">x: 9  y: 10</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>在已记录SQL输出中，可以看到绑定参数`:y`在发送到SQLite数据库时被转换为问号。这是因为SQLite数据库驱动程序使用了称为”问号参数样式”的格式，这是DBAPI规范允许的六种不同格式之一。SQLAlchemy将这些格式抽象为仅使用冒号的“命名”格式。</p>
<aside class="topic">
<p class="topic-title">始终使用绑定参数</p>
<p>如本节开头所述，文本SQL不是我们使用SQLAlchemy的常规方式。然而，当使用文本SQL时，Python字面值，甚至是非字符串，如整数或日期，应**永远不会直接将其字符串化为SQL字符串**；应该**始终使用参数**。这最为人所知的是避免SQL注入攻击的方法，当数据不受信任时。但是，它也允许SQLAlchemy方言和/或DBAPI正确地处理后端传入的输入。除了纯文本SQL用例外，SQLAlchemy的核心表达式API还确保Python字面值在适当的位置以绑定参数的形式传递。</p>
</aside>
</section>
<section id="tutorial-multiple-parameters">
<span id="id8"></span><h3>发送多个参数<a class="headerlink" href="#tutorial-multiple-parameters" title="Permalink to this heading">¶</a></h3>
<p>在   <a class="reference internal" href="#tutorial-committing-data"><span class="std std-ref">提交更改</span></a>  中的例子中，我们执行了一个INSERT语句，其中看起来我们能够一次向数据库插入多个行。对于 “INSERT”、”UPDATE” 和 “DELETE” 等 DML 语句，我们可以通过传递一个字典列表而不是单个字典来向  :meth:` _engine.Connection.execute`  方法发送**多个参数集**，这表明单个SQL语句应该被调用多次，每次针对一个参数集。这种执行风格称为  <span class="xref std std-term">executemany</span> ：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     conn.execute(</span>
<span class="go">...         text(&quot;INSERT INTO some_table (x, y) VALUES (:x, :y)&quot;),</span>
<span class="go">...         [{&quot;x&quot;: 11, &quot;y&quot;: 12}, {&quot;x&quot;: 13, &quot;y&quot;: 14}],</span>
<span class="go">...     )</span>
<span class="go">...     conn.commit()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">[(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">)]</span>
<span class="o">&lt;</span><span class="n">sqlalchemy</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="k">cursor</span><span class="p">.</span><span class="n">CursorResult</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="p">...</span><span class="o">&gt;</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
<p>上述操作相当于针对每个参数集运行给定的INSERT语句一次，但该操作将针对许多行进行优化以提高性能。</p>
<p>“execute” 和 “executemany” 之间的一个关键行为差异在于，后者不支持返回结果行，即使语句包含 RETURNING 子句。这个规则有一个例外情况，就是当使用 Core 的   <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a>  构造函数时，也就是后面将在本教程的   :ref:` tutorial_core_insert`  中介绍时，它还使用了  <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.returning" title="sqlalchemy.sql.expression.Insert.returning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.returning()</span></code></a>  方法来表示 RETURNING。在这种情况下，SQLAlchemy 使用特殊逻辑重新组织 INSERT 语句，以便针对多行调用 INSERT 语句同时仍支持 RETURNING。</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<blockquote>
<div><p><span class="xref std std-term">executemany</span>  - 在  :doc:` Glossary &lt;/glossary&gt;`  中，描述了用于大多数 “executemany” 执行的 DBAPI 级</p>
</div></blockquote>
<p><a class="reference external" href="https://peps.python.org/pep-0249/#executemany">cursor.executemany()</a> 方法。</p>
<blockquote>
<div><p><span class="xref std std-ref">engine_insertmanyvalues</span>  - 在   :ref:` connections_toplevel`  中，描述了  <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.Insert.returning" title="sqlalchemy.sql.expression.Insert.returning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Insert.returning()</span></code></a>  所使用的专门逻辑，以便在使用 “executemany” 执行时提供结果集。</p>
</div></blockquote>
</div>
</section>
</section>
<section class="orm-header" id="orm-session">
<span id="tutorial-executing-orm-session"></span><h2>使用 ORM Session 执行<a class="headerlink" href="#orm-session" title="Permalink to this heading">¶</a></h2>
<p>正如先前提到的那样，上面大部分的模式和例子也适用于使用 ORM，所以在这里我们将介绍这种用法，以便在本教程继续时，我们可以在 Core 和 ORM 中使用每种模式和技术。</p>
<p>在使用 ORM 时，基本的事务/数据库交互对象称为   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 。在现代 SQLAlchemy 中，这个对象被用在与   :class:` _engine.Connection`  非常相似的方式中。事实上，当   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  被使用时，它在内部引用了一个   :class:` _engine.Connection` ，它用于发出 SQL。</p>
<p>当使用   <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  与非 ORM 构造函数一起使用时，它会传递我们给它的 SQL 语句，并且一般不会做与   :class:` _engine.Connection`  直接相比有太大的不同，因此我们可以在这里使用简单的文本 SQL 操作来进行说明。</p>
<blockquote>
<div><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  有几种不同的创建模式，但这里我们将介绍最基本的一种模式，该模式与使用   :class:` _engine.Connection`  的方式完全相同，即在上下文管理器中构造它：</p>
</div></blockquote>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT x, y FROM some_table WHERE y &gt; :y ORDER BY x, y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     result = session.execute(stmt, {&quot;y&quot;: 6})</span>
<span class="go">...     for row in result:</span>
<span class="go">...         print(f&quot;x: {row.x}  y: {row.y}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">x: 6  y: 8</span>
<span class="go">x: 9  y: 10</span>
<span class="go">x: 11  y: 12</span>
<span class="go">x: 13  y: 14</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>上面的例子可以与前面   <a class="reference internal" href="#tutorial-sending-parameters"><span class="std std-ref">发送参数</span></a>  中的例子进行比较 - 我们直接将对 ` <cite>with engine.connect() as conn`</cite> 的调用替换为 <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">Session(engine)</span> <span class="pre">as</span> <span class="pre">session</span></code>，然后像使用  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>  方法一样使用  :meth:` _orm.Session.execute`  方法。另外，与  <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>  方法实现“即时提交”的行为，如下例所示，使用文本更新语句改变了一些数据：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     result = session.execute(</span>
<span class="go">...         text(&quot;UPDATE some_table SET y=:y WHERE x=:x&quot;),</span>
<span class="go">...         [{&quot;x&quot;: 9, &quot;y&quot;: 11}, {&quot;x&quot;: 13, &quot;y&quot;: 15}],</span>
<span class="go">...     )</span>
<span class="go">...     session.commit()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">some_table</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">y</span><span class="o">=?</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">x</span><span class="o">=?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">[(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">)]</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
<p>在上面的示例中，我们使用了绑定参数“executemany”风格的方法调用了一个UPDATE语句，结束整个块时使用了“即时提交”的方法。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<dl class="simple">
<dt>事实上， <code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code> 在事务结束后并不会保持 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象。</dt><dd><p>需要在下一次使用SQL查询数据库时，它会从 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> 重新获得一个 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 对象。</p>
</dd>
</dl>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code>  方法与  :meth:` _engine.Connection.execute`  方法的使用方式，即可开始后续的示例。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/session_basics.html#session-basics"><span class="std std-ref">使用会话的基础</span></a>  - 介绍了 :class:` _orm.Session`对象的基本创建和使用模式。</p>
</div>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="engine.html" title="previous chapter">建立连接 - Engine</a>
        Next:
        <a href="metadata.html" title="next chapter">使用数据库元数据</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:59:04

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


