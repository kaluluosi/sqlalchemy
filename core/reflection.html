<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>
            
    
    从数据库反射对象
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="模式定义语言 (Schema Definition Language)" href="schema.html" />
        <link rel="next" title="列INSERT/UPDATE默认值" href="defaults.html" />
        <link rel="prev" title="使用MetaData描述数据库" href="metadata.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.19</span>


        | Release Date: July 15, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy 核心">SQLAlchemy 核心</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="expression_api.html">SQL语句和表达式API</a></span></li>
<li><span class="link-container"><a class="reference external" href="schema.html">模式定义语言 (Schema Definition Language)</a></span><ul>
<li><span class="link-container"><a class="reference external" href="metadata.html">使用MetaData描述数据库</a></span></li>
<li class="selected"><span class="link-container"><strong>从数据库反射对象</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#id2">重写反映列</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id3">反映视图</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id4">一次反映所有表格</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id5">从其他模式反映表</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id6">反射的限制</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id7">从数据库无关类型反映</a></span></li>
<li><span class="link-container"><a class="reference external" href="#id8">反射的限制</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="defaults.html">列INSERT/UPDATE默认值</a></span></li>
<li><span class="link-container"><a class="reference external" href="constraints.html">定义约束和索引</a></span></li>
<li><span class="link-container"><a class="reference external" href="ddl.html">自定义 DDL</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="types.html">SQL 数据类型对象</a></span></li>
<li><span class="link-container"><a class="reference external" href="engines_connections.html">引擎与连接使用</a></span></li>
<li><span class="link-container"><a class="reference external" href="api_basics.html">Core API基础知识</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="metadata.html" title="previous chapter">使用MetaData描述数据库</a></li>
                <li><b>Next:</b>
                <a href="defaults.html" title="next chapter">列INSERT/UPDATE默认值</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy 核心">SQLAlchemy 核心</a></li>
                    <ul><li><a href="schema.html" title="模式定义语言 (Schema Definition Language)">模式定义语言 (Schema Definition Language)</a></li>
                </ul>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#id1">从数据库反射对象</a><ul>
<li><a class="reference internal" href="#id2">重写反映列</a></li>
<li><a class="reference internal" href="#id3">反映视图</a></li>
<li><a class="reference internal" href="#id4">一次反映所有表格</a></li>
<li><a class="reference internal" href="#id5">从其他模式反映表</a></li>
<li><a class="reference internal" href="#id6">反射的限制</a></li>
<li><a class="reference internal" href="#id7">从数据库无关类型反映</a></li>
<li><a class="reference internal" href="#id8">反射的限制</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar core-reflection" >
        
<section id="id1">
<h1>从数据库反射对象<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>一个   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象可以被传输到数据库中，从而加载关于自身的信息。这个过程被称为“自反”（reflection）。在最简单的情况下，您只需要指定表名、一个   :class:` ~sqlalchemy.schema.MetaData`  对象和“autoload_with”参数。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;messages&quot;</span><span class="p">,</span> <span class="n">metadata_obj</span><span class="p">,</span> <span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">messages</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
<span class="go">[&#39;message_id&#39;, &#39;message_name&#39;, &#39;date&#39;]</span></pre></div>
</div>
<p>上述操作将使用给定的引擎查询数据库对“messages”表的信息，然后根据此信息生成与手动构造的 Python 相同的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>  and   :class:` ~sqlalchemy.schema.ForeignKey`  等对象。</p>
<p>当反映表时，如果给定表通过外键引用另一个表，则将创建一个第二个   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象，表示连接   :class:` ~sqlalchemy.schema.MetaData`  对象。例如，假设表“shopping_cart_items”引用名为“shopping_carts”的表。反射“shopping_cart_items”表会导致也加载“shopping_carts”表：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shopping_cart_items</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;shopping_cart_items&quot;</span><span class="p">,</span> <span class="n">metadata_obj</span><span class="p">,</span> <span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;shopping_carts&quot;</span> <span class="ow">in</span> <span class="n">metadata_obj</span><span class="o">.</span><span class="n">tables</span>
<span class="go">True</span></pre></div>
</div>
<p>如果您只命名表，则可以访问已生成的“shopping_carts”表:</p>
<blockquote>
<div><p>shopping_carts = Table(“shopping_carts”, metadata_obj)</p>
</div></blockquote>
<p>当然，最好使用 “autoload_with=engine” 参数。这是因为如果尚未加载表的属性，则只加载该表。如果表没有被加载，那么自反操作会自动加载。加载后，对同名的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  的新调用不会发出任何反射查询。</p>
<section id="id2">
<h2>重写反映列<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>可以在反映表时使用显式值覆盖单个列。这对于指定自定义数据类型、数据库中可能未配置的主键等约束非常有用。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mytable</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;mytable&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">metadata_obj</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span>
<span class="gp">... </span>        <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span>    <span class="p">),</span>  <span class="c1"># override reflected &#39;id&#39; to have primary key</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;mydata&quot;</span><span class="p">,</span> <span class="n">Unicode</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>  <span class="c1"># override reflected &#39;mydata&#39; to be Unicode</span>
<span class="gp">... </span>    <span class="c1"># additional Column objects which require no change are reflected normally</span>
<span class="gp">... </span>    <span class="n">autoload_with</span><span class="o">=</span><span class="n">some_engine</span><span class="p">,</span>
<span class="go">)</span></pre></div>
</div>
</section>
<section id="id3">
<h2>反映视图<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>反射系统也可以反映视图。基本用法与表相同:</p>
<blockquote>
<div><p>my_view = Table(“some_view”, metadata, autoload_with=engine)</p>
</div></blockquote>
<p>上面，“my_view”是一个   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象，其中包含   :class:` ~sqlalchemy.schema.Column`  对象，表示视图“some_view”中每个列的名称和类型。</p>
<p>通常，在反射视图时，当未在数据库中配置主键时，至少需要一个主键约束，如果有外键，那么也应该配置外键。</p>
<p>使用“override”功能对此进行说明，显式指定作为主键或具有外键约束的那些列。</p>
<blockquote>
<div><dl class="simple">
<dt>my_view = Table(</dt><dd><p>“some_view”,
metadata,
Column(“view_id”, Integer, primary_key=True),
Column(“related_thing”, Integer, ForeignKey(“othertable.thing_id”)),
autoload_with=engine,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</section>
<section id="id4">
<h2>一次反映所有表格<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象也可以获取表的列表并反射整个表集。这是通过使用   :func:` ~sqlalchemy.schema.MetaData.reflect`  方法来实现的。调用后，所有定位的表都存在于   <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象的表字典中：</p>
<blockquote>
<div><p>metadata_obj = MetaData()
metadata_obj.reflect(bind=someengine)
users_table = metadata_obj.tables[“users”]
addresses_table = metadata_obj.tables[“addresses”]</p>
</div></blockquote>
</div></blockquote>
<p>“metadata.reflect()”还提供了一种方便的方法来清除或删除数据库中的所有行：</p>
<blockquote>
<div><p>metadata_obj = MetaData()
metadata_obj.reflect(bind=someengine)
for table in reversed(metadata_obj.sorted_tables):</p>
<blockquote>
<div><p>someengine.execute(table.delete())</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="id5">
<h2>从其他模式反映表<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>部分   <a class="reference internal" href="metadata.html#schema-table-schema-name"><span class="std std-ref">指定模式名称</span></a>  介绍了表模式的概念，这是数据库中包含表和其他对象的命名空间，可以通过显式指定来指定。当反应   :class:` _schema.Table`  对象以及其他对象时，如视图、索引和序列，可以使用  <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table.params.schema" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.schema</span></code></a>  参数设置此模式。还可以使用  :paramref:` _schema.MetaData.schema`  参数将此模式设置为   <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象的缺省模式。</p>
<p>此模式参数的使用直接影响反射功能在其被请求反射对象时将要寻找的位置。例如，通过使用  <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData.params.schema" title="sqlalchemy.schema.MetaData"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">MetaData.schema</span></code></a>  参数配置的默认模式名称“project”：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="s2">&quot;project&quot;</span><span class="p">)</span></pre></div>
</div>
<p>然后，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code>  将使用配置的“project”类作为所反映对象的位置：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># uses `schema` configured in metadata_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">someengine</span><span class="p">)</span></pre></div>
</div>
<p>结果就是   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象从 “project” 模式反射而来，并以该名称的模式限定形式填充。</p>
<p>同样，在包括  <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table.params.schema" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.schema</span></code></a>  参数的个别   :class:` _schema.Table`  对象中，将从该数据库模式反射该模式中的项目。如果以“schema-qualified” 的方式进行反射，则会覆盖正在拥有项目的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  集合上配置的缺省模式：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;messages&quot;</span><span class="p">,</span> <span class="n">metadata_obj</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;project&quot;</span><span class="p">,</span> <span class="n">autoload_with</span><span class="o">=</span><span class="n">someengine</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">messages</span>
<span class="go">Table(&#39;messages&#39;, MetaData(), Column(&#39;message_id&#39;, INTEGER(), table=&lt;messages&gt;), schema=&#39;project&#39;)</span></pre></div>
</div>
<p>最后，  <code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code>  方法本身也允许传递  :paramref:` _schema.MetaData.reflect.schema`  参数，因此我们可以为一个默认配置的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象加载来自“project”模式的表：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">someengine</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;project&quot;</span><span class="p">)</span></pre></div>
</div>
<p>我们可以调用  <code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.reflect()</span></code>  任何次数，以传递不同的  :paramref:` _schema.MetaData.schema`  参数（或根本不传递任何参数）来继续将对象填充到   <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象中：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># add tables from the &quot;customer&quot; schema</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">someengine</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;customer&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># add tables from the default schema</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">someengine</span><span class="p">)</span></pre></div>
</div>
</section>
<section id="id6">
<h2>反射的限制<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>反射过程是使用仅在关系数据库中表示的信息重新创建   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  元数据。这个过程本质上无法恢复未实际存储在数据库中的架构方面：客户端默认值，无论是使用 Python 函数还是使用   :class:` _schema.Column`  的“默认”关键字定义的 SQL 表达式（请注意，这与 “server_default” 特别是反射的“default”关键字不同），列信息，例如放置在  <code class="xref py py-attr docutils literal notranslate"><span class="pre">Column.info</span></code>  字典中的数据等等。</p>
<p>关系数据库还在许多情况下以不同于 SQLAlchemy 中指定的格式报告表元数据。从反射返回的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象不能始终可靠地用于生成与原始 Python 定义的   :class:` _schema.Table`  对象相同的 DDL。这种情况发生在包括服务器默认值、列关联序列和有关约束和数据类型的各种怪癖等方面。服务器端默认值可能会用“::&lt;type&gt;”转换指令（通常 PostgreSQL 将包含一个“::&lt;type&gt;”转换）或不同的引用方案返回。</p>
<p>另一类限制包括部分或尚未完全定义反射的架构结构。最近提高了反映处理事项方面的功能，例如可以反映视图、索引和外键选项等。截止到此写作，像 CHECK 约束、table comments 和触发器等结构不能反映。</p>
</section>
<section id="id7">
<h2>从数据库无关类型反映<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>反映列时，无论是  <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table.params.autoload_with" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.autoload_with</span></code></a>  的  :meth:` _reflection.Inspector.get_columns`  方法，数据类型都会尽可能地特定于目标数据库。这意味着如果从 MySQL 数据库反射 “integer” 数据类型，则类型将由   <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.INTEGER" title="sqlalchemy.dialects.mysql.INTEGER"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.mysql.INTEGER</span></code></a>  类表示，其中包括 MySQL 特定的属性，例如“display_width”。或在 PostgreSQL 上，可能返回 PostgreSQL 特定数据类型，如   :class:` sqlalchemy.dialects.postgresql.INTERVAL`  或   <a class="reference internal" href="../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM" title="sqlalchemy.dialects.postgresql.ENUM"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.postgresql.ENUM</span></code></a> 。</p>
<p>反射中存在这样的用例，即给定一个   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  要传输到不同的数据库供应商。为了适应这种用例，可以使用  :meth:` _events.DDLEvents.column_reflect`  事件拦截列反射。 使用  <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.as_generic" title="sqlalchemy.types.TypeEngine.as_generic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.as_generic()</span></code></a>  方法，可以将这些特定于供应商的数据类型实时转换为 SQLAlchemy 后端无关数据类型，用于上面的例子。例如，类型如   :class:` _types.Integer` 、  <a class="reference internal" href="type_basics.html#sqlalchemy.types.Interval" title="sqlalchemy.types.Interval"><code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></a> 、  :class:` _types.Enum`  可以替换特殊数据类型   <a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.MEDIUMINT" title="sqlalchemy.dialects.mysql.MEDIUMINT"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.mysql.MEDIUMINT</span></code></a>  和   :class:` sqlalchemy.dialects.mysql.TINYINT` ，我们可以选择使用  <a class="reference internal" href="events.html#sqlalchemy.events.DDLEvents.column_reflect" title="sqlalchemy.events.DDLEvents.column_reflect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DDLEvents.column_reflect()</span></code></a>  事件来处理这些问题。自定义的处理程序将使用  :meth:` _types.TypeEngine.as_generic`  方法将上述 MySQL 特定类型对象转换为通用类型，方法是在传递给事件处理程序的列字典条目中将“type”条目替换为列字典。这个字典格式至  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Inspector.get_columns()</span></code>  中已经被描述：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">metadata_obj</span><span class="p">,</span> <span class="s2">&quot;column_reflect&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">genericize_datatypes</span><span class="p">(</span><span class="n">inspector</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">column_dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">column_dict</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">column_dict</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_generic</span><span class="p">()</span></pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_generic_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">metadata_obj</span><span class="p">,</span> <span class="n">autoload_with</span><span class="o">=</span><span class="n">mysql_engine</span><span class="p">)</span></pre></div>
</div>
<p>现在我们获得了一个新的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象，它是通用的并使用   :class:` _types.Integer`  代替这些数据类型。我们现在可以在 PostgreSQL 数据库（例如）上发出“CREATE TABLE”语句：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pg_engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_generic_table</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">pg_engine</span><span class="p">)</span>
<span class="go">{execsql}CREATE TABLE my_table (</span>
<span class="go">    id SERIAL NOT NULL,</span>
<span class="go">    data1 VARCHAR(50),</span>
<span class="go">    data2 INTEGER,</span>
<span class="go">    data3 INTEGER,</span>
<span class="go">    PRIMARY KEY (id)</span>
<span class="go">)</span></pre></div>
</div>
<p>注意，SQLAlchemy 通常会为其他行为提供良好的猜测，例如 MySQL 的“AUTO_INCREMENT”指令通常使用“SERIAL”自动增加的数据类型最接近地在 PostgreSQL 中表示。</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4: </span>添加了  <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.as_generic" title="sqlalchemy.types.TypeEngine.as_generic"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.as_generic()</span></code></a>  方法， 并且还通过改进  :meth:` _events.DDLEvents.column_reflect`  事件的使用，以便可以方便地应用于   <a class="reference internal" href="metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>  对象。</p>
</div>
</section>
<section id="id8">
<h2>反射的限制<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>反射过程是使用仅在关系数据库中表示的信息重新创建   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  元数据。这个过程本质上无法恢复未实际存储在数据库中的架构方面：客户端默认值、列信息、例如放置在  :attr:` _schema.Column.info`  字典中的数据等等。反映从反射返回的对象不能始终可靠地用于生成与原始 Python 定义的   <a class="reference internal" href="metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>  对象相同的 DDL。这种情况发生在包括服务器默认值、列关联序列和有关约束和数据类型的各种怪癖等方面。服务器端默认值可能会用“::&lt;type&gt;”转换指令（通常 PostgreSQL 将包含一个“::&lt;type&gt;”转换）或不同的引用方案返回。</p>
<p>另一类限制包括部分或尚未完全定义反射的架构结构。最近提高了反映处理事项方面的功能，例如可以反映视图、索引和外键选项等。截止到此写作，像 CHECK 约束、table comments、触发器等结构还没有反映。</p>
</section>
</section>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="metadata.html" title="previous chapter">使用MetaData描述数据库</a>
        Next:
        <a href="defaults.html" title="next chapter">列INSERT/UPDATE默认值</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 7.0.1.

    Documentation last generated: 2023/8/18 18:58:45

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.19',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


